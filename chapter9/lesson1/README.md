# 9.1 Состояние гонки

В последовательной программе, т.е. в программе с единственной горутиной, все этапы программы выполняются в
знакомом порядке, определяемом логикой программы. Например, в последовательности инструкций первая выполняется до второй
и т.д. В программе с двумя или более горутинами этапы каждой горутины выполняются в знакомом порядке, но в
общем случае мы не знаем, предшествует ли событие `x` в одной горутине событию `у` в другой горутине,
происходит ли оно после `х` или одновременно с ним. Если мы не можем уверенно сказать, что одно событие **предшествует**
другому, такие события `х` и `у` являются **параллельными**.

Рассмотрим функцию, которая правильно работает в последовательной программе. Она является **безопасной с точки зрения
параллельности**, если продолжает работать правильно даже при параллельном вызове, т.е. при вызове из двух или более
горутин **без какой бы то ни было дополнительной синхронизации**. Мы можем обобщить это понятие для множества
сотрудничающих функций, таких как методы и операции определенного типа. **Тип является безопасным с точки зрения
параллельности, если все доступные методы и операции являются таковыми**.

Можно сделать программу безопасной с точки зрения параллельности, не делая каждый конкретный тип в этой программе
таковым. В действительности безопасные с точки зрения параллельности типы являются скорее исключением, чем правилом, так
что получать параллельный доступ к переменной следует, **только если в документации для ее типа сказано, что это
безопасно**. Мы избегаем одновременного доступа к большинству переменных, **ограничивая** их одной горутиной или
поддерживая высокоуровневый инвариант **взаимного исключения**. Мы поясним эти термины далее в этой главе.

В противоположность этому от экспортируемых функций уровня пакета обычно ожидается безопасность с точки зрения
параллельности. Поскольку переменные уровня пакета не могут быть ограничены одной горутиной, функции, которые их
изменяют, должны обеспечивать взаимное исключение.

Существует множество причин, по которым функция может не работать при параллельном вызове, включая **взаимоблокировки**,
**динамические взаимоблокировки и голодание**. У нас не хватит места для обсуждения всех этих явлений, поэтому мы
сосредоточимся на наиболее важном — **состоянии гонки**.

`Состояние гонки` — это ситуация, в которой программа не дает правильный результат для некоторого чередования операций
нескольких горутин. Состояния гонки **крайне вредны**, поскольку могут **оставаться скрытыми в программе и проявляться
очень редко**, возможно, только при большой нагрузке или при использовании некоторых компиляторов, на определенных
платформах или для конкретной архитектуры. Это делает их сложными для воспроизведения и диагностики.

Традиционно серьезность состояния гонки поясняется через метафору финансовых потерь, поэтому мы рассмотрим простую
программу для работы с банковскими счетами:

```go
// Package bank реализует банк с единственным счетом. 
package bank

var balance int

func Deposit(amount int) { balance = balance + amount }

func Balance() int { return balance }
```

(Мы могли бы написать тело функции `Deposit` как `balance += amount`, что было бы эквивалентно, но **более длинная
запись позволит упростить объяснение.**)

Для такой тривиальной программы очевидно с первого взгляда, что любая последовательность вызовов `Deposit` и `Balance`
даст правильный ответ, т.е. `Balance` будет сообщать о верной сумме всех положенных в банк вкладов. Однако, если мы
вызываем эти функции не последовательно, а **одновременно**, больше не гарантируется, что `Balance` даст правильный
ответ.
Рассмотрим две следующие горутины, которые представляют собой две операции с общим банковским счетом:

``` go
// Алиса:
go func() {
	bank.Deposit(200)                // A1
	fmt.Println("=", bank.Balance()) // A2
}()

// Боб
go bank.Deposit(100)                 // B
```

Алиса вкладывает 200 долларов, а затем проверяет свой баланс, в то время как Боб вкладывает 100 долларов. Поскольку шаги
`А1` и `А2` выполняются одновременно с `В`, мы не можем предсказать точный их порядок. Интуитивно может показаться, что
есть только три возможности упорядочения, которые мы будем называть “Алиса первая”, “Боб первый” и “Алиса/Боб/Алиса”. В
следующей таблице показаны значения переменной `balance` после каждого шага (строки в кавычках представляют вывод
баланса на печать):

| Алиса первая | Боб первый | Алиса/Боб/Алиса |
|--------------|------------|-----------------|
| 0            | 0          | 0               |
| A1       200 | B      100 | A1          200 |
| A2   "= 200" | A1     300 | B           300 |
| B        300 | A2 "= 300" | A2      "= 300" |

Во всех случаях окончательный баланс составляет 300 долларов. Единственной вариацией является то, включает ли баланс
Алисы транзакции Боба, но в любом случае клиенты удовлетворены.

Но интуиция нас обманывает. Есть и четвертый возможный результат, в котором вклад Боба происходит посреди вклада Алисы,
после прочтения значения баланса (`balance + amount`), но до его обновления (`balance = ...`), приводя к исчезновению
транзакции Боба. Дело в том, что операция вклада Алисы `А1` на самом деле представляет собой последовательность двух
операций, чтения и записи; назовем их `A1r` и `A1w`. Вот как выглядит чередование, вызывающее проблемы:

| Состояние гонки |                        |
|----------------:|------------------------|
|               0 |                        |
|         `A1r` 0 | ... = balance + amount |
|           B 100 |                        |
|       `A1w` 200 | balance = ...          |
|      A2 "= 200" |                        |

После `A1r` выражение `balance + amount` равно **200**, и именно это значение записывается во время `A1w`, несмотря на
выполненный вклад. Окончательный баланс составляет всего 200 долларов. Банк стал на 100 долларов богаче за счет Боба.
Эта программа содержит разновидность состояния гонки, которая называется **гонкой данных**. Гонка данных осуществляется,
когда две горутины **одновременно** обращаются к одной и той же переменной и по крайней мере **одно из обращений
является записью**.

Все оказывается еще хуже, если гонка данных включает переменную типа, большего, чем одно машинное слово, такого как
интерфейс, строка или срез. Приведенный далее код обновляет значение переменной `х` одновременно двумя срезами разной
длины:

``` go
var x []int
go func() { x = make([]int, 10) }()
go func() { x = make([]int, 1000000) }()
x[999999] = 1 // Примечание: неопределенное поведение; возможно повреждение памяти!
```

Значение `х` в последней инструкции не определено; это может быть `nil`, срез длиной `10` или срез длиной `1 ООО ООО`.
Но вспомните, что у среза есть три составные части: `указатель`, `длина` и `емкость`. Если указатель получен из первого
вызова `make`, а длина — из второго, `х` становится _химерой_, срезом, длина которого составляет
`1 ООО ООО`, но базовый массив имеет только 10 элементов. В этом случае сохранение `999 999-го` элемента выполняет
запись в некоторой далеко отстоящей ячейке памяти с последствиями, которые невозможно предсказать и трудно локализовать
и отлаживать. Это семантическое минное поле называется `неопределенным поведением` и хорошо известно программистам на
языке С; к счастью, в Go такие неприятности встречаются куда реже, чем в С.

Даже интуитивная идея, что параллельная программа представляет собой чередование нескольких последовательных программ,
является ложной. Как мы увидим в разделе 9.4, гонка данных может приводить к еще более странным результатам. Многие
программисты — даже некоторые из самых умных — иногда предлагают обоснования для допуска известной гонки данных в своей
программе: “стоимость взаимного исключения слишком высока”, “эта логика — только для протоколирования”, “я не возражаю
против потери некоторых сообщений” и т.д. Отсутствие проблем при использовании данных компилятора и платформы может дать
ложную уверенность в благополучности ситуации. Хорошее практическое правило гласит, что `не существует такого понятия,
как доброкачественная гонка данных`. Так как же избегать гонки данных в наших программах?

Мы повторим определение, поскольку это очень важно: гонка данных осуществляется, `когда две горутины одновременно
обращаются к одной и той же переменной и по крайней мере одно из обращений представляет собой запись`. Из этого
определения следует, что существует три способа избежать гонки данных.

Первый способ — `не записывать переменную`. Рассмотрим приведенную ниже карту с отложенным заполнением при первом
запросе ключа. Если `Icon` вызывается последовательно, программа работает нормально, но если `Icon` вызывается
параллельно, при обращении к карте имеется гонка данных.

``` go
var icons = make(map[string]image.Image)

func loadIcon(name string) image.Image

// Примечание: небезопасно с точки зрения параллельности!
func Icon(name string) image.Image {
	icon, ok := icons[name]
	if !ok {
		icon = loadIcon(name)
		icons[name] = icon
	}
	return icon
}
```

Если вместо этого мы инициализируем карту всеми необходимыми записями перед созданием дополнительных
горутин и никогда не будем изменять его снова, то любое количество горутин может безопасно одновременно
вызывать `Icon`, поскольку каждая из них только читает карту:

``` go
var icons = map[string]image.Image{
	"spades.png":   loadIcon("spades.png"),
	"hearts.png":   loadIcon("hearts.png"),
	"diamonds.png": loadIcon("diamonds.png"),
	"clubs.png":    loadIcon("clubs.png"),
}
// Безопасно с точки зрения параллельности.
func Icon(name string) image.Image {return icons[name]}
```

В приведенном выше примере переменная `icons` присваивается во время инициализации пакета, которая `происходит` до того,
как запускается функция `main` программы. После инициализации `icons` никогда не изменяется. Структуры данных, которые
`никогда не изменяются` или являются `неизменяемыми` по своей сути, **безопасны с точки зрения параллельности и не
требуют синхронизации**. Но очевидно, что мы не можем использовать этот подход, если обновления играют существенную
роль, как в случае банковского счета.

Второй способ избежать гонки данных — `избегать обращения к переменной из нескольких горутин`. Это подход,
использованный многими из программ предыдущей главы. Например, главная горутина в параллельном веб-сканере (раздел 8.6)
является единственной горутиной, обращающейся к карте `seen`, a горутина `broadcaster` чат-сервера (раздел 8.10)
является единственной горутиной, обращающейся к карте `clients`. Эти переменные ограничены одной горутиной.

Поскольку другие горутины не могут получить непосредственный доступ к переменной, они должны использовать канал
для запроса у ограничивающей go- подпрограммы получения значения или обновления переменной. Это то, что подразумевается
мантрой Go "**не связывайтесь путем совместного использования памяти; совместно используйте память путем связи**".
Горутина, посредничающая в доступе к ограниченной переменной с использованием запроса по каналу, называется
`горутиной управления (монитором)` для данной переменной. Например, горутина `broadcaster` управляет доступом
к карте `clients`.

Вот пример банка, переписанный с переменной `balance`, которая ограничивается монитором `teller` (см. bank1.go):

```go
package bank

var deposits = make(chan int) // Отправление вклада
var balances = make(chan int) // Получение баланса

func Deposit(amount int) { deposits <- amount }
func Balance() int       { return <-balances }

func teller() {
	var balance int // balance ограничен горутиной teller
	for {
		select {
		case amount := <-deposits:
			balance += amount
		case balances <- balance:
		}
	}
}

func init() {
	go teller() // Запуск управляющей горутины
}
```

Даже когда переменная не может быть ограничена одной горутиной на все ее время жизни, ограничение все же может
быть решением проблемы параллельного доступа. Например, распространено совместное использование переменной горутинами в
конвейере путем передачи ее адреса от одной стадии к другой по каналу. Если каждый этап конвейера
воздерживается от доступа к переменной после ее отправки на следующий этап, все обращения к такой переменной
последовательны. По сути, переменная ограничена одной стадией конвейера, а затем ограничивается следующей и т.д. Такой
подход иногда называют `последовательным ограничением`.

В приведенном ниже примере `Cake` **последовательно ограничены**, сначала горутиной `baker`, затем — горутиной
`icer`:

``` go
type Cake struct { state string }

func baker(cooked chan<- *Cake) {
	for {
		cake := new(Cake)
		cake.state = "cooked"
		cooked <- state // baker больше не будет работать с этим cake
	}
}

func icer (iced chan<- *Cake, cooked <-chan *Cake) {
	for cake := range cooked {
		cake.state = "iced"
		iced <- cake // icer больше не будет работать с этим cake
	}
}
```

Третий способ избежать гонки данных состоит в том, чтобы позволить многим горутинам обращаться к переменной, но
только по одной за раз. Этот подход известен как **взаимное исключение** и является темой следующего раздела.

## Выводы:

* В программе с двумя или более горутинами все этапы каждой горутины выполняются в знакомом порядке, но в общем случае
  мы не знаем, предшествует ли событие `x` в одной горутине событию `y` в другой горутине, происходит ли оно после `х`
  или одновременно с ним; это делает параллельное программирование более сложным, но позволяет достичь высокой
  производительности и эффективности в использовании ресурсов.
* Функция считается безопасной с точки зрения параллельности, если продолжает работать правильно **даже при параллельном
  вызове**, т.е. при вызове из двух или более горутин **без дополнительной синхронизации**; это важно для написания
  стабильных и надежных программ, которые можно масштабировать и оптимизировать.
* Тип является **безопасным с точки зрения параллельности**, если все доступные методы и операции являются таковыми;
  однако, безопасные типы являются скорее _исключением_, чем правилом, поэтому необходимо внимательно следить за
  документацией и использовать синхронизацию, когда это нужно.
* От экспортируемых функций уровня пакета обычно ожидается безопасность с точки зрения параллельности, так как они могут
  быть вызваны из разных горутин одновременно и должны обеспечивать взаимное исключение.
* `Состояние гонки` — это ситуация, в которой программа не дает правильный результат для некоторого чередования операций
  нескольких горутин; состояния гонки сложны для воспроизведения и диагностики, поэтому необходимо избегать их
  появления, применяя механизмы синхронизации и обеспечивая параллельную безопасность функций и типов.
* `Гонка данных` возникает, **когда две горутины одновременно обращаются к одной и той же переменной, и по крайней мере
  одно из обращений является записью**; гонки данных могут привести к неопределенному поведению и сложным для отладки
  ошибкам, поэтому их предотвращение является крайне важным аспектом параллельного программирования на языке Golang.
* **Не существует такого понятия, как доброкачественная гонка данных, поэтому всегда стоит избегать их возникновения для
  стабильности и надежности программ;**
* Способы избежания гонки данных на языке Golang:
	1. **Не записывать переменную**: инициализировать все необходимые записи перед созданием дополнительных горутин и не
	   изменять их впоследствии; это позволяет обеспечить безопасность в параллельном выполнении кода и упрощает
	   синхронизацию;
	2. Ограничить доступ к переменной одной горутиной: другие горутины должны использовать каналы для запросов получения
	   или изменения значения ограниченной переменной; в этом случае используется мантра Go "**не связывайтесь путем
	   совместного использования памяти; совместно используйте память путем связи**", что помогает избегать гонок данных
	   и упрощает работу с переменными;
	3. Использовать взаимное исключение, позволяя многим горутинам обращаться к переменной, но только по одной за раз;
	   это известно как `механизм мьютексов (mutex)` и является одним из основных инструментов синхронизации в Golang,
	   который обеспечивает правильное взаимодействие горутин с общим ресурсом;
* Польза использования этих подходов и механизмов состоит в обеспечении корректной работы программы в условиях
  параллельного выполнения, снижении вероятности возникновения ошибок и упрощении процесса синхронизации между
  горутинами;