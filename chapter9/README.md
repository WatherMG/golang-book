# 9. Параллельность и совместно используемые переменные

В предыдущей главе мы представили несколько программ, которые используют горутины и каналы для выражения
параллелизма непосредственным и естественным путем. Однако, поступая так, мы затушевывали целый ряд важных и тонких
вопросов, которые программисты должны учитывать при написании параллельного кода.

В этой главе мы более детально рассмотрим механику параллелизма. В частности, мы укажем на некоторые из проблем,
связанных с совместным использованием переменных несколькими горутинами, и рассмотрим аналитические методы
распознавания этих проблем и шаблоны их решений. Наконец мы поясним некоторые технические различия между
горутинами и потоками операционной системы.

# Выводы к главе:

<!-- TOC -->

* [9.1. Состояния гонки](#91-состояния-гонки)
* [9.2. Взаимные исключения: sync.Mutex](#92-взаимные-исключения-syncmutex)
* [9.3. Мьютексы чтения/записи: sync.RWMutex](#93-мьютексы-чтениязаписи-syncrwmutex)
* [9.4. Синхронизация памяти](#94-синхронизация-памяти)
* [9.5. Отложенная инициализация: sync.Once](#95-отложенная-инициализация-synconce)
* [9.6. Детектор гонки](#96-детектор-гонки)
* [9.7. Пример: параллельный неблокирующий кеш](#97-пример-параллельный-неблокирующий-кеш)
* [9.8. Go-подпрограммы и потоки](#98-go-подпрограммы-и-потоки)
	* [9.8.1 Растущие стеки](#981-растущие-стеки)
	* [9.8.2 Планирование go-подпрограмм](#982-планирование-go-подпрограмм)
	* [9.8.3 GOMAXPROCS](#983-gomaxprocs)
	* [9.8.4 Go-подпрограммы не имеют идентификации](#984-go-подпрограммы-не-имеют-идентификации)

<!-- TOC -->
____

# 9.1. Состояния гонки

* В программе с двумя или более горутинами все этапы каждой горутины выполняются в знакомом порядке, но в общем случае
  мы не знаем, предшествует ли событие `x` в одной горутине событию `y` в другой горутине, происходит ли оно после `х`
  или одновременно с ним; это делает параллельное программирование более сложным, но позволяет достичь высокой
  производительности и эффективности в использовании ресурсов.
* Функция считается безопасной с точки зрения параллельности, если продолжает работать правильно **даже при параллельном
  вызове**, т.е. при вызове из двух или более горутин **без дополнительной синхронизации**; это важно для написания
  стабильных и надежных программ, которые можно масштабировать и оптимизировать.
* Тип является **безопасным с точки зрения параллельности**, если все доступные методы и операции являются таковыми;
  однако, безопасные типы являются скорее _исключением_, чем правилом, поэтому необходимо внимательно следить за
  документацией и использовать синхронизацию, когда это нужно.
* От экспортируемых функций уровня пакета обычно ожидается безопасность с точки зрения параллельности, так как они могут
  быть вызваны из разных горутин одновременно и должны обеспечивать взаимное исключение.
* `Состояние гонки` — это ситуация, в которой программа не дает правильный результат для некоторого чередования операций
  нескольких горутин; состояния гонки сложны для воспроизведения и диагностики, поэтому необходимо избегать их
  появления, применяя механизмы синхронизации и обеспечивая параллельную безопасность функций и типов.
* Гонка данных возникает, **когда две горутины одновременно обращаются к одной и той же переменной, и по крайней мере
  одно из обращений является записью**; гонки данных могут привести к неопределенному поведению и сложным для отладки
  ошибкам, поэтому их предотвращение является крайне важным аспектом параллельного программирования на языке Golang.
* **Не существует такого понятия, как доброкачественная гонка данных, поэтому всегда стоит избегать их возникновения для
  стабильности и надежности программ;**
* Способы избежания гонки данных на языке Golang:
	1. **Не записывать переменную**: инициализировать все необходимые записи перед созданием дополнительных горутин и не
	   изменять их впоследствии; это позволяет обеспечить безопасность в параллельном выполнении кода и упрощает
	   синхронизацию;
	2. Ограничить доступ к переменной одной горутиной: другие горутины должны использовать каналы для запросов получения
	   или изменения значения ограниченной переменной; в этом случае используется мантра Go "**не связывайтесь путем
	   совместного использования памяти; совместно используйте память путем связи**", что помогает избегать гонок данных
	   и упрощает работу с переменными;
	3. Использовать взаимное исключение, позволяя многим горутинам обращаться к переменной, но только по одной за раз;
	   это известно как `механизм мьютексов (mutex)` и является одним из основных инструментов синхронизации в Golang,
	   который обеспечивает правильное взаимодействие горутин с общим ресурсом;
* Польза использования этих подходов и механизмов состоит в обеспечении корректной работы программы в условиях
  параллельного выполнения, снижении вероятности возникновения ошибок и упрощении процесса синхронизации между
  горутинами;

____

# 9.2. Взаимные исключения: sync.Mutex

* `Бинарный семафор` (канал емкостью 1) используется для гарантии одновременного доступа к совместно используемой
  переменной только одной горутиной;
* Для более удобного механизма взаимного исключения можно использовать тип `Mutex` из пакета `sync` с методами `Lock`
  и `Unlock` для захвата и освобождения токена блокировки соответственно;
* `Мьютекс` **охраняет совместно используемые переменные**, и важно соблюдать соглашение об объявлении этих переменных
  сразу после объявления самого мьютекса;
* `Критический раздел` - область кода между `Lock` и `Unlock`, в которой горутина может безопасно читать и
  модифицировать совместно используемые переменные;
* `Монитор` - механизм блокировок, функций и переменных, который позволяет одной или нескольким функциям инкапсулировать
  переменные и обеспечивать последовательный доступ к ним для нескольких горутин;
* Использование инструкции `defer` позволяет отложить вызов `Unlock` и автоматически продлить критический раздел до
  конца функции, облегчая обработку освобождения блокировки на всех путях выполнения, включая пути ошибок;
* Отложенный вызов `Unlock` будет выполняться даже при `панике` во время выполнения критического раздела, что может быть
  важным в программах, использующих `recover`;
* Важно обеспечить `атомарность` операций (либо операция выполняется полностью, либо вообще не выполняется), чтобы
  избежать побочных эффектов, вызванных неправильной обработкой конкурентных операций, таких как временное опускание
  значения переменной ниже нуля или ложное отклонение транзакции;
* В Golang следует предпочитать ясность и последовательность кода, избегая преждевременной оптимизации и активно
  использовать `defer` и `мьютексы` для обеспечения безопасности при параллельном программировании;
* Функция `Deposit` может вызвать `взаимоблокировку (deadlock)` из-за попытки **захватить мьютекс дважды**; это
  происходит из-за `нереентерабельности мьютексов`, то есть **они не позволяют блокировать уже заблокированный
  мьютекс**;
* `Мьютексы` используются для обеспечения сохранения инвариантов совместно используемых переменных в критических точках
  **во время выполнения программы**, что позволяет избежать ошибок и несогласованности данных;
* Распространенное `решение` проблемы `реентерабельности мьютексов` - разделение функций на две: **неэкспортируемую
  функцию**, которая делает реальную работу, и **экспортируемую функцию**, которая выполняет блокировку до вызова
  первой;
* Инкапсуляция помогает поддерживать инварианты структур данных и параллелизма, а также уменьшает неожиданные
  взаимодействия в программе, что приводит к более стабильному и безопасному коду;
* Важно **не экспортировать мьютексы и переменные, которые они защищают**, независимо от того, являются ли они
  переменными уровня пакета или полями структуры, для соблюдения инкапсуляции и поддержания порядка в коде;
* Использование мьютексов и принципов инкапсуляции в коде на языке Golang способствует созданию надежных и
  производительных приложений, так как минимизирует возможность ошибок из-за совместного доступа к переменным и
  параллельного выполнения.

____

# 9.3. Мьютексы чтения/записи: sync.RWMutex
* Бывает ситуация, когда операции `чтения` безопасны параллельно, а операции `записи` требуют исключительного доступа;
  для такого сценария подходит блокировка `"несколько читателей, один писатель"`, которая в Go реализуется
  через `sync.RWMutex`;
* `RWMutex` отличается от обычного мьютекса тем, что разделяет блокировки на `читателей (RLock)` и `писателей (Lock)`,
  что позволяет параллельно выполнять операций чтения и ускоряет выполнение программы;
* `RLock` следует использовать только тогда, **когда в критическом разделе кода не происходит `записи` совместно
  используемых переменных**;
* Если в функции не только `чтение`, но и `обновление переменных` (например, счетчиков или кеша), лучше использовать
  `исключительную блокировку (Lock)` для безопасности;
* `RWMutex` рационально применять, когда большинству горутин требуется блокировка `читателей`, и за блокировку ведется
  состязание; такая блокировка работает медленнее обычных мьютексов из-за более сложной внутренней бухгалтерии, но
  обеспечивает параллельное выполнение операций чтения и ускоряет выполнение программы;
* `sync.RWMutex` - позволяет `нескольким горутинам одновременно читать данные` из общей переменной, но только `одной
  горутине изменять` их. Это означает, что если одна горутина получает `блокировку для записи (используя метод Lock)`,
  все остальные горутины, которые пытаются получить блокировку для `чтения (используя метод RLock)` или для записи,
  будут заблокированы до тех пор, пока первая горутина `не разблокирует RWMutex (используя метод Unlock)`. Однако если
  несколько горутин получают блокировку для чтения, они могут одновременно читать данные без
  блокировки друг друга.
____

# 9.4. Синхронизация памяти

____

# 9.5. Отложенная инициализация: sync.Once

____

# 9.6. Детектор гонки

____

# 9.7. Пример: параллельный неблокирующий кеш

____

# 9.8. Go-подпрограммы и потоки

____

## 9.8.1 Растущие стеки

____

## 9.8.2 Планирование go-подпрограмм

____

## 9.8.3 GOMAXPROCS

____

## 9.8.4 Go-подпрограммы не имеют идентификации

____