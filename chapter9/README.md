# 9. Параллельность и совместно используемые переменные

В предыдущей главе мы представили несколько программ, которые используют горутины и каналы для выражения
параллелизма непосредственным и естественным путем. Однако, поступая так, мы затушевывали целый ряд важных и тонких
вопросов, которые программисты должны учитывать при написании параллельного кода.

В этой главе мы более детально рассмотрим механику параллелизма. В частности, мы укажем на некоторые из проблем,
связанных с совместным использованием переменных несколькими горутинами, и рассмотрим аналитические методы
распознавания этих проблем и шаблоны их решений. Наконец мы поясним некоторые технические различия между
горутинами и потоками операционной системы.

# Выводы к главе:

<!-- TOC -->

* [9.1. Состояния гонки](#91-состояния-гонки)
* [9.2. Взаимные исключения: sync.Mutex](#92-взаимные-исключения-syncmutex)
* [9.3. Мьютексы чтения/записи: sync.RWMutex](#93-мьютексы-чтениязаписи-syncrwmutex)
* [9.4. Синхронизация памяти](#94-синхронизация-памяти)
* [9.5. Отложенная инициализация: sync.Once](#95-отложенная-инициализация-synconce)
* [9.6. Детектор гонки](#96-детектор-гонки)
* [9.7. Пример: параллельный неблокирующий кеш](#97-пример-параллельный-неблокирующий-кеш)
* [9.8. Go-подпрограммы и потоки](#98-go-подпрограммы-и-потоки)
	* [9.8.1 Растущие стеки](#981-растущие-стеки)
	* [9.8.2 Планирование go-подпрограмм](#982-планирование-go-подпрограмм)
	* [9.8.3 GOMAXPROCS](#983-gomaxprocs)
	* [9.8.4 Go-подпрограммы не имеют идентификации](#984-go-подпрограммы-не-имеют-идентификации)

<!-- TOC -->
____

# 9.1. Состояния гонки

* В программе с двумя или более горутинами все этапы каждой горутины выполняются в знакомом порядке, но в общем случае
  мы не знаем, предшествует ли событие `x` в одной горутине событию `y` в другой горутине, происходит ли оно после `х`
  или одновременно с ним; это делает параллельное программирование более сложным, но позволяет достичь высокой
  производительности и эффективности в использовании ресурсов.
* Функция считается безопасной с точки зрения параллельности, если продолжает работать правильно **даже при параллельном
  вызове**, т.е. при вызове из двух или более горутин **без дополнительной синхронизации**; это важно для написания
  стабильных и надежных программ, которые можно масштабировать и оптимизировать.
* Тип является **безопасным с точки зрения параллельности**, если все доступные методы и операции являются таковыми;
  однако, безопасные типы являются скорее _исключением_, чем правилом, поэтому необходимо внимательно следить за
  документацией и использовать синхронизацию, когда это нужно.
* От экспортируемых функций уровня пакета обычно ожидается безопасность с точки зрения параллельности, так как они могут
  быть вызваны из разных горутин одновременно и должны обеспечивать взаимное исключение.
* `Состояние гонки` — это ситуация, в которой программа не дает правильный результат для некоторого чередования операций
  нескольких горутин; состояния гонки сложны для воспроизведения и диагностики, поэтому необходимо избегать их
  появления, применяя механизмы синхронизации и обеспечивая параллельную безопасность функций и типов.
* Гонка данных возникает, **когда две горутины одновременно обращаются к одной и той же переменной, и по крайней мере
  одно из обращений является записью**; гонки данных могут привести к неопределенному поведению и сложным для отладки
  ошибкам, поэтому их предотвращение является крайне важным аспектом параллельного программирования на языке Golang.
* **Не существует такого понятия, как доброкачественная гонка данных, поэтому всегда стоит избегать их возникновения для
  стабильности и надежности программ;**
* Способы избежания гонки данных на языке Golang:
	1. **Не записывать переменную**: инициализировать все необходимые записи перед созданием дополнительных горутин и не
	   изменять их впоследствии; это позволяет обеспечить безопасность в параллельном выполнении кода и упрощает
	   синхронизацию;
	2. Ограничить доступ к переменной одной горутиной: другие горутины должны использовать каналы для запросов получения
	   или изменения значения ограниченной переменной; в этом случае используется мантра Go "**не связывайтесь путем
	   совместного использования памяти; совместно используйте память путем связи**", что помогает избегать гонок данных
	   и упрощает работу с переменными;
	3. Использовать взаимное исключение, позволяя многим горутинам обращаться к переменной, но только по одной за раз;
	   это известно как `механизм мьютексов (mutex)` и является одним из основных инструментов синхронизации в Golang,
	   который обеспечивает правильное взаимодействие горутин с общим ресурсом;
* Польза использования этих подходов и механизмов состоит в обеспечении корректной работы программы в условиях
  параллельного выполнения, снижении вероятности возникновения ошибок и упрощении процесса синхронизации между
  горутинами;

____

# 9.2. Взаимные исключения: sync.Mutex

* `Бинарный семафор` (канал емкостью 1) используется для гарантии одновременного доступа к совместно используемой
  переменной только одной горутиной;
* Для более удобного механизма взаимного исключения можно использовать тип `Mutex` из пакета `sync` с методами `Lock`
  и `Unlock` для захвата и освобождения токена блокировки соответственно;
* `Мьютекс` **охраняет совместно используемые переменные**, и важно соблюдать соглашение об объявлении этих переменных
  сразу после объявления самого мьютекса;
* `Критический раздел` - область кода между `Lock` и `Unlock`, в которой горутина может безопасно читать и
  модифицировать совместно используемые переменные;
* `Монитор` - механизм блокировок, функций и переменных, который позволяет одной или нескольким функциям инкапсулировать
  переменные и обеспечивать последовательный доступ к ним для нескольких горутин;
* Использование инструкции `defer` позволяет отложить вызов `Unlock` и автоматически продлить критический раздел до
  конца функции, облегчая обработку освобождения блокировки на всех путях выполнения, включая пути ошибок;
* Отложенный вызов `Unlock` будет выполняться даже при `панике` во время выполнения критического раздела, что может быть
  важным в программах, использующих `recover`;
* Важно обеспечить `атомарность` операций (либо операция выполняется полностью, либо вообще не выполняется), чтобы
  избежать побочных эффектов, вызванных неправильной обработкой конкурентных операций, таких как временное опускание
  значения переменной ниже нуля или ложное отклонение транзакции;
* В Golang следует предпочитать ясность и последовательность кода, избегая преждевременной оптимизации и активно
  использовать `defer` и `мьютексы` для обеспечения безопасности при параллельном программировании;
* Функция `Deposit` может вызвать `взаимоблокировку (deadlock)` из-за попытки **захватить мьютекс дважды**; это
  происходит из-за `нереентерабельности мьютексов`, то есть **они не позволяют блокировать уже заблокированный
  мьютекс**;
* `Мьютексы` используются для обеспечения сохранения инвариантов совместно используемых переменных в критических точках
  **во время выполнения программы**, что позволяет избежать ошибок и несогласованности данных;
* Распространенное `решение` проблемы `реентерабельности мьютексов` - разделение функций на две: **неэкспортируемую
  функцию**, которая делает реальную работу, и **экспортируемую функцию**, которая выполняет блокировку до вызова
  первой;
* Инкапсуляция помогает поддерживать инварианты структур данных и параллелизма, а также уменьшает неожиданные
  взаимодействия в программе, что приводит к более стабильному и безопасному коду;
* Важно **не экспортировать мьютексы и переменные, которые они защищают**, независимо от того, являются ли они
  переменными уровня пакета или полями структуры, для соблюдения инкапсуляции и поддержания порядка в коде;
* Использование мьютексов и принципов инкапсуляции в коде на языке Golang способствует созданию надежных и
  производительных приложений, так как минимизирует возможность ошибок из-за совместного доступа к переменным и
  параллельного выполнения.

____

# 9.3. Мьютексы чтения/записи: sync.RWMutex

* Бывает ситуация, когда операции `чтения` безопасны параллельно, а операции `записи` требуют исключительного доступа;
  для такого сценария подходит блокировка `"несколько читателей, один писатель"`, которая в Go реализуется
  через `sync.RWMutex`;
* `RWMutex` отличается от обычного мьютекса тем, что разделяет блокировки на `читателей (RLock)` и `писателей (Lock)`,
  что позволяет параллельно выполнять операций чтения и ускоряет выполнение программы;
* `RLock` следует использовать только тогда, **когда в критическом разделе кода не происходит `записи` совместно
  используемых переменных**;
* Если в функции не только `чтение`, но и `обновление переменных` (например, счетчиков или кеша), лучше использовать
  `исключительную блокировку (Lock)` для безопасности;
* `RWMutex` рационально применять, когда большинству горутин требуется блокировка `читателей`, и за блокировку ведется
  состязание; такая блокировка работает медленнее обычных мьютексов из-за более сложной внутренней бухгалтерии, но
  обеспечивает параллельное выполнение операций чтения и ускоряет выполнение программы;
* `sync.RWMutex` - позволяет `нескольким горутинам одновременно читать данные` из общей переменной, но только `одной
  горутине изменять` их. Это означает, что если одна горутина получает `блокировку для записи (используя метод Lock)`,
  все остальные горутины, которые пытаются получить блокировку для `чтения (используя метод RLock)` или для записи,
  будут заблокированы до тех пор, пока первая горутина `не разблокирует RWMutex (используя метод Unlock)`. Однако если
  несколько горутин получают блокировку для чтения, они могут одновременно читать данные без
  блокировки друг друга.

____

# 9.4. Синхронизация памяти

* Синхронизация памяти играет важную роль в многопоточном программировании, так как определяет порядок выполнения
  операций и взаимодействие переменных между горутинами;
* В современных компьютерах может быть несколько процессоров, каждый с собственным кешем оперативной памяти, что может
  привести к непредсказуемому поведению в случае отсутствия правильной синхронизации между горутинами;
* Без использования примитивов синхронизации, таких как `каналы` или `мьютексы`, нет гарантии, что результаты выполнения
  одной горутины **будут видимыми для других горутин**, работающих на других процессорах;
* Примитивы синхронизации (каналы и мьютексы) гарантируют, что все накопленные записи выполняющихся горутин будут
  сброшены и зафиксированы, делая их видимыми для других горутин;
* В случае параллельного доступа к совместно используемым переменным без использования взаимного исключения возникает
  гонка данных, что может привести к неожиданным и недетерминированным результатам;
* Чтобы избежать проблем параллелизма, важно использовать простые и проверенные шаблоны: ограничивать доступ к
  переменным одной горутиной или использовать взаимные исключения для совместно используемых переменных.

____

# 9.5. Отложенная инициализация: sync.Once

* `Отложенная инициализация` - хорошая практика для уменьшения времени запуска программы и экономии ресурсов, поскольку
  она происходит **только тогда, когда это действительно необходимо**;
* Использование отложенной инициализации с одиночной переменной доступной **только одной горутине** может быть
  достигнуто с помощью простого условия проверки на `nil`, но такой подход **не является безопасным для параллельного
  доступа**;
* Для корректной синхронизации между горутинами необходимо использовать мьютексы, такие, как `sync.Mutex`
  или `sync.RWMutex`, которые предотвращают одновременный доступ к общим данным, исключая возможность состояний гонки;
* Использование `sync.RWMutex` позволяет обеспечить более высокую степень параллелизма, но требует более сложной
  реализации;
* Для упрощения синхронизации и решения задачи однократной инициализации можно использовать специализированный
  инструмент - `sync.Once`, который гарантирует, что функция инициализации **вызывается только один раз**;
* Метод `sync.Once.Do()` **принимает функцию инициализации в качестве аргумента**, а выполнение инициализации
  осуществляется **только при первом вызове**, одновременно гарантируя видимость изменений в памяти для всех горутин;
* Использование `sync.Once` позволяет избежать **преждевременного доступа** к переменным и **обеспечивает корректную
  синхронизацию и инициализацию данных в параллельных средах**.

____

# 9.6. Детектор гонки

* Даже при максимальной аккуратности в программировании, существует риск допущения ошибок параллелизма;
* В Go существует инструмент динамического анализа - `детектор гонки`, который помогает обнаруживать эти ошибки;
* Для активации детектора гонки, достаточно добавить флаг `-race` к командам `go build`, `go run` или `go test`;
* Этот флаг приведет к созданию **модифицированной версии приложения или теста** с дополнительным инструментарием для
  анализа обращений к совместно используемым переменным и событиями синхронизации;
* `Детектор гонки` изучает поток событий и определяет случаи возможных гонок данных между горутинами;
* В результате анализа, детектор гонки выдает отчет, содержащий идентификатор переменной и стеки вызовов активных
  функций для лучшего понимания и исправления проблемы;
* Детектор гонки показывает только **фактически выполненные гонки данных во время выполнения**, но не может доказать
  отсутствие других гонок;
* При использовании детектора гонки программа **требует больше памяти и времени на выполнение**, но это оправдано при
  редко
  встречающихся состояниях гонки, так как помогает сэкономить время на отладку;
* Использование детектора гонки в Golang полезно для обеспечения корректной работы приложений, предотвращения ошибок
  параллелизма и ускорения процесса разработки и отладки программ.

____

# 9.7. Пример: параллельный неблокирующий кеш

* Создание `параллельного неблокирующего кеша` может решить **проблему функций с запоминанием в параллельных
  программах**, позволяя кешировать результаты функций и избежать излишнего повторения дорогостоящих операций;
* Пример функции с запоминанием - `httpGetBody`, делающая HTTP GET запрос и читающая тело ответа. Хранение результатов
  этой функции может существенно ускорить программу;
* `Memo`, (memo2) использующий функцию `f` и кеш на основе карты строк, позволяет кешировать результаты выполнения
  функций и предоставлять их быстро при повторных запросах;
* Использование параллелизма в программе может значительно ускорить выполнение операций ввода-вывода, особенно при
  наличии дубликатов `URL-адресов`;
* Простой способ сделать кеш безопасным с точки зрения параллельности - использовать синхронизацию на `основе монитора (
  мьютекс)`, однако это может сериализовать операции ввода-вывода и уменьшить преимущества параллелизма;
* Для решения этой проблемы и обеспечения корректной работы кеша в условиях параллелизма, можно использовать другие
  подходы, например, `разделение блокировок` или `алгоритмы без блокировок`;
* В реализации `Get` (memo3) горутина выполняет блокировку дважды: `для поиска` и `для обновления`; это позволяет
  улучшить производительность и предотвращает блокировки при использовании кеша.
* Некоторые URL могут выбираться дважды при одновременных вызовах `Get`: это приводит к лишней работе, поэтому следует
  использовать подавление повторений для более эффективной работы с кешем.
* В версии 4 `Memo` (memo4) каждый элемент карты является указателем на структуру `entry`, которая содержит результат
  вызова функции `f` и канал с именем `ready`; закрытие канала оповещает другие горутины о готовности результата.
* `Get` включает захват мьютекса, поиск существующей записи `entry`, выделение памяти, вставку новой записи и
  освобождение мьютекса; это обеспечивает параллельность и неблокирование кеша.
* Если существующая запись `entry` не готова, горутина должна ожидать оповещения о готовности перед чтением значения;
  это достигается с помощью чтения из канала `ready`.
* Получение оповещения о готовности и чтение результатов в других горутинах происходит после записи данных в первой
  горутине, поэтому не требуется мьютекс и нет гонок данных.
* Можно использовать альтернативный дизайн кеша с `ограниченной управляющей горутиной и каналами` для отправки запросов
  и получения результатов, что также обеспечит безопасность доступа к данным и параллельность работы.
* Управляющая горутина обрабатывает запросы, вызывает функцию `f`, сохраняет результат и оповещает о готовности с
  помощью методов `call` и `deliver`; эти методы вызываются в отдельных горутинах для предотвращения блокировки
  обработки новых запросов.
* Разные подходы к параллельности и синхронизации данных (**с совместно используемыми переменными и блокировками** или *
  *со взаимодействующими последовательными процессами**) могут быть использованы без чрезмерной сложности, и иногда
  переход от одного подхода к другому упрощает код.
* Знание обоих подходов помогает выбрать наиболее подходящий для конкретной ситуации и создать эффективные параллельные
  алгоритмы и структуры данных на языке Golang.

____

# 9.8. Go-подпрограммы и потоки

## 9.8.1 Растущие стеки

* Потоки операционной системы имеют блок памяти фиксированного размера для стека, обычно около `2 Мбайт`; это область
  для хранения локальных переменных вызовов функций, находящихся в работе или приостановленных;
* Фиксированный размер стека может быть как `слишком большим для простых задач`, так
  и `слишком малым для сложных и глубоко рекурсивных функций`; это создает проблемы с использованием памяти и
  ограничивает количество одновременных потоков;
* В Go используются горутины, которые начинают работу с небольшим стеком, обычно около `2 Кбайт`, что **экономит память
  и позволяет создавать большее количество горутин**;
* Стек горутины может **расти и уменьшаться** в зависимости от необходимости, что обеспечивает более эффективное
  использование памяти, больше одновременных потоков и возможность работы с рекурсивными функциями большей глубины;
* Максимальный размер стека горутины в Go может достигать `1 Гбайта`, что обеспечивает гораздо большую гибкость по
  сравнению со стеками фиксированного размера;
* Использование горутин и динамически изменяемых стеков в Go позволяет повысить производительность и эффективность
  программ, делая их масштабируемыми и адаптивными к различным задачам и условиям выполнения.

____

## 9.8.2 Планирование go-подпрограмм

* `Потоки операционной системы планируются в ядре`, что требует переключения контекста и является медленной операцией
  из-за слабой локальности и обращений к памяти;
* Go имеет собственный планировщик, который использует `m:n-планирование`, мультиплексирование (планирование) `m`
  горутин на `n` потоках операционной системы, чтобы сделать планирование быстрее и эффективнее;
* Планировщик Go вызывается не периодически аппаратным таймером, а `неявно некоторыми конструкциями языка Go`, такими
  как `time.Sleep`, `каналы` и `мьютексы`;
* Когда горутина `блокируется на задаче`, **планировщик переводит ее в спящий режим и запускает другую горутину**, что
  позволяет эффективнее использовать ресурсы;
* Планирование горутин `значительно дешевле`, чем планирование потоков, поскольку не требуется переключение контекста
  ядра;
* Использование планировщика и горутин в Golang делает многопоточное программирование более доступным и быстрым.

____

## 9.8.3 GOMAXPROCS

* Планировщик Go использует параметр `GOMAXPROCS` для определения **количества потоков операционной системы**, которые
  могут одновременно активно выполнять код Go; это позволяет оптимально распределить ресурсы процессора для
  одновременного выполнения задач;
* Значение `GOMAXPROCS` по умолчанию **равно количеству процессоров компьютера (логических)**, что обеспечивает
  оптимальное использование мощности машины для выполняемых программ;
* `Спящие`, `заблокированные в коммуникации` или `заблокированные на операциях ввода-вывода` горутины **не требуют самих
  потоков**, что снижает нагрузку на систему при работе с большим количеством горутин;
* Управление параметром `GOMAXPROCS` возможно через переменную среды или функцию `runtime.GOMAXPROCS`, что позволяет
  адаптировать его значение для конкретных условий и оптимизировать процессы в различных ситуациях;
* Изменение значения `GOMAXPROCS` может привести к изменению поведения программы, исходя из количества доступных потоков
  и одновременно работающих горутин; **это позволяет более точно контролировать процесс выполнения кода и рассчитывать
  заранее требуемые ресурсы системы**;
* Планирование горутин зависит от множества факторов и среды выполнения, что делает каждую ситуацию уникальной и может
  привести к различным результатам при разных условиях.

____

## 9.8.4 Go-подпрограммы не имеют идентификации

____