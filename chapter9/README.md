# 9. Параллельность и совместно используемые переменные

В предыдущей главе мы представили несколько программ, которые используют горутины и каналы для выражения
параллелизма непосредственным и естественным путем. Однако, поступая так, мы затушевывали целый ряд важных и тонких
вопросов, которые программисты должны учитывать при написании параллельного кода.

В этой главе мы более детально рассмотрим механику параллелизма. В частности, мы укажем на некоторые из проблем,
связанных с совместным использованием переменных несколькими горутинами, и рассмотрим аналитические методы
распознавания этих проблем и шаблоны их решений. Наконец мы поясним некоторые технические различия между
горутинами и потоками операционной системы.

# Выводы к главе:

<!-- TOC -->

* [9.1. Состояния гонки](#91-состояния-гонки)
* [9.2. Взаимные исключения: sync.Mutex](#92-взаимные-исключения-syncmutex)
* [9.3. Мьютексы чтения/записи: sync.RWMutex](#93-мьютексы-чтениязаписи-syncrwmutex)
* [9.4. Синхронизация памяти](#94-синхронизация-памяти)
* [9.5. Отложенная инициализация: sync.Once](#95-отложенная-инициализация-synconce)
* [9.6. Детектор гонки](#96-детектор-гонки)
* [9.7. Пример: параллельный неблокирующий кеш](#97-пример-параллельный-неблокирующий-кеш)
* [9.8. Go-подпрограммы и потоки](#98-go-подпрограммы-и-потоки)
	* [9.8.1 Растущие стеки](#981-растущие-стеки)
	* [9.8.2 Планирование go-подпрограмм](#982-планирование-go-подпрограмм)
	* [9.8.3 GOMAXPROCS](#983-gomaxprocs)
	* [9.8.4 Go-подпрограммы не имеют идентификации](#984-go-подпрограммы-не-имеют-идентификации)

<!-- TOC -->
____

# 9.1. Состояния гонки
* В программе с двумя или более горутинами все этапы каждой горутины выполняются в знакомом порядке, но в общем случае
  мы не знаем, предшествует ли событие `x` в одной горутине событию `y` в другой горутине, происходит ли оно после `х`
  или одновременно с ним; это делает параллельное программирование более сложным, но позволяет достичь высокой
  производительности и эффективности в использовании ресурсов.
* Функция считается безопасной с точки зрения параллельности, если продолжает работать правильно **даже при параллельном
  вызове**, т.е. при вызове из двух или более горутин **без дополнительной синхронизации**; это важно для написания
  стабильных и надежных программ, которые можно масштабировать и оптимизировать.
* Тип является **безопасным с точки зрения параллельности**, если все доступные методы и операции являются таковыми;
  однако, безопасные типы являются скорее _исключением_, чем правилом, поэтому необходимо внимательно следить за
  документацией и использовать синхронизацию, когда это нужно.
* От экспортируемых функций уровня пакета обычно ожидается безопасность с точки зрения параллельности, так как они могут
  быть вызваны из разных горутин одновременно и должны обеспечивать взаимное исключение.
* `Состояние гонки` — это ситуация, в которой программа не дает правильный результат для некоторого чередования операций
  нескольких горутин; состояния гонки сложны для воспроизведения и диагностики, поэтому необходимо избегать их
  появления, применяя механизмы синхронизации и обеспечивая параллельную безопасность функций и типов.
* Гонка данных возникает, **когда две горутины одновременно обращаются к одной и той же переменной, и по крайней мере
  одно из обращений является записью**; гонки данных могут привести к неопределенному поведению и сложным для отладки
  ошибкам, поэтому их предотвращение является крайне важным аспектом параллельного программирования на языке Golang.
* **Не существует такого понятия, как доброкачественная гонка данных, поэтому всегда стоит избегать их возникновения для
  стабильности и надежности программ;**
* Способы избежания гонки данных на языке Golang:
	1. **Не записывать переменную**: инициализировать все необходимые записи перед созданием дополнительных горутин и не
	   изменять их впоследствии; это позволяет обеспечить безопасность в параллельном выполнении кода и упрощает
	   синхронизацию;
	2. Ограничить доступ к переменной одной горутиной: другие горутины должны использовать каналы для запросов получения
	   или изменения значения ограниченной переменной; в этом случае используется мантра Go "**не связывайтесь путем
	   совместного использования памяти; совместно используйте память путем связи**", что помогает избегать гонок данных
	   и упрощает работу с переменными;
	3. Использовать взаимное исключение, позволяя многим горутинам обращаться к переменной, но только по одной за раз;
	   это известно как `механизм мьютексов (mutex)` и является одним из основных инструментов синхронизации в Golang,
	   который обеспечивает правильное взаимодействие горутин с общим ресурсом;
* Польза использования этих подходов и механизмов состоит в обеспечении корректной работы программы в условиях
  параллельного выполнения, снижении вероятности возникновения ошибок и упрощении процесса синхронизации между
  горутинами;
____

# 9.2. Взаимные исключения: sync.Mutex

____

# 9.3. Мьютексы чтения/записи: sync.RWMutex

____

# 9.4. Синхронизация памяти

____

# 9.5. Отложенная инициализация: sync.Once

____

# 9.6. Детектор гонки

____

# 9.7. Пример: параллельный неблокирующий кеш

____

# 9.8. Go-подпрограммы и потоки

____

## 9.8.1 Растущие стеки

____

## 9.8.2 Планирование go-подпрограмм

____

## 9.8.3 GOMAXPROCS

____

## 9.8.4 Go-подпрограммы не имеют идентификации

____