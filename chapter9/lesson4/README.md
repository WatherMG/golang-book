# 9.4. Синхронизация памяти

Вы можете удивиться, почему метод `Balance` требует `взаимного исключения`, **основанного на канале или мьютексе**. В
конце концов, в отличие от `Deposit`, он состоит только из одной операции, поэтому нет опасности выполнения другой
горутины "посредине" него. Тому есть две причины. Первая заключается в том, что не менее важно, чтобы метод `Balance`
также не выполнялся посреди некоторых других операций наподобие `Withdraw`. Вторая (и более тонкая) причина в том, что
синхронизация представляет собой нечто большее, чем просто порядок выполнения нескольких горутин; синхронизация
также влияет на память.

В современном компьютере могут быть десятки процессоров, каждый из которых имеет собственный локальный кеш оперативной
памяти. Для повышения эффективности запись в память буферизуется в пределах каждого процессора и сбрасывается в основную
память только по необходимости. Записи в основную память могут быть выполнены не в таком порядке, в каком они
выполнялись записывающими горутинами. Такие примитивы синхронизации, как коммуникационный `канал` и операции
`мьютекса`, **заставляют процессор выполнить сброс и зафиксировать все накопленные записи**, так что результаты
выполнения горутин до этой точки гарантированно будут видимыми для горутин, работающих на других процессорах.

Рассмотрим возможные выводы следующего фрагмента кода:

``` go
var x, y int
go func() {
	x = 1                   // A1
	fmt.Print("y:", y, " ") // A2
}
go func() {
	y = 1                   // B1
	fmt.Print("x:", x, " ") // B2
}
```

Поскольку эти две горутины параллельны и обращаются к совместно используемым переменным без взаимного исключения,
возникает гонка данных. Поэтому мы не должны удивляться тому, что программа не является детерминированной. Мы могли бы
ожидать любого из четырех приведенных ниже результатов, которые соответствуют интуитивному представлению о чередовании
инструкций программы:

```
y:0 x:1
х:0 у:1
х:1 у:1
у:1 х:1
```

Четвертая строка, например, может быть пояснена последовательностью `А1, B1, А2, В2` или
последовательностью `B1, A1, А2, В2`. Однако следующие два вывода могут показаться удивительными:

```
y:0 x:0
x:0 y:0
```

Однако в зависимости от компилятора, процессора и многих других факторов они также могут иметь место. Какой же
последовательностью чередования четырех инструкций можно пояснить такие результаты?

В пределах одной горутины результаты работы каждой инструкции гарантированно осуществляются в порядке исполнения;
горутины `последовательно согласованны`. Однако в отсутствие явной синхронизации с использованием `канала` или
`мьютекса` нет никакой гарантии, что события видимы всем горутинам в одном и том же порядке. Хотя горутина
должна наблюдать результат записи `х = 1` до чтения значения `у`, она необязательно будет наблюдать запись `у`,
сделанную горутиной `B`, поэтому `А` может вывести устаревшее значение `у`.

Соблазнительно попытаться понять параллелизм так, как будто он соответствует `некоторому` чередованию инструкций каждой
горутины, но, как показано в примере выше, современные компиляторы или процессоры работают не совсем так.
Поскольку присваивание и вызов `Print` относятся к разным переменным, компилятор может посчитать, что порядок этих двух
инструкций не может повлиять на результат, и поменять их местами. Если две горутины выполняются на разных
процессорах, каждый со своей кеш-памятью, запись в память одной горутиной не видима для вызова `Print` другой
горутины до тех пор, **пока кеши не будут `синхронизированы` с основной памятью**.

Всех этих проблем параллелизма можно избежать путем последовательного, согласованного применения простых и давно
известных шаблонов. Там, где это возможно, ограничьте переменные одной горутиной; для всех других переменных
используйте взаимные исключения.

## Выводы:

* Синхронизация памяти играет важную роль в многопоточном программировании, так как определяет порядок выполнения
  операций и взаимодействие переменных между горутинами;
* В современных компьютерах может быть несколько процессоров, каждый с собственным кешем оперативной памяти, что может
  привести к непредсказуемому поведению в случае отсутствия правильной синхронизации между горутинами;
* Без использования примитивов синхронизации, таких как `каналы` или `мьютексы`, нет гарантии, что результаты выполнения
  одной горутины **будут видимыми для других горутин**, работающих на других процессорах;
* Примитивы синхронизации (каналы и мьютексы) гарантируют, что все накопленные записи выполняющихся горутин будут
  сброшены и зафиксированы, делая их видимыми для других горутин;
* В случае параллельного доступа к совместно используемым переменным без использования взаимного исключения возникает
  гонка данных, что может привести к неожиданным и недетерминированным результатам;
* Чтобы избежать проблем параллелизма, важно использовать простые и проверенные шаблоны: ограничивать доступ к
  переменным одной горутиной или использовать взаимные исключения для совместно используемых переменных.