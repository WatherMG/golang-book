# 9.3. Мьютексы чтения/записи: `sync.RWMutex`

Увидев внезапное исчезновение 100 долларов, Боб пишет программу для проверки своего баланса в банке сотни раз в секунду.
Он запускает ее у себя дома, на работе и на своем телефоне. Банк замечает, что увеличение трафика замедляет вклады и
снятия, так как все запросы `Balance` выполняются последовательно, выполняя исключительную блокировку и временно
препятствуя выполнению других горутин.

Поскольку функции `Balance` нужно только `читать` состояние переменной, множественные параллельные вызовы этой функции в
действительности будут безопасными, если только не выполняется вызов `Deposit` или `Withdraw`. При таком сценарии нам
нужен особый вид блокировки, который позволяет **операциям `чтения` выполняться параллельно друг с другом**, но
операции `записи` **получают полностью исключительный доступ**. Такая блокировка
называется `несколько читателей, один писатель` и в Go обеспечивается мьютексом `sync.RWMutex`:

``` go
var mu sync.RWMutex
var balance int

func Balance() int {
	mu.RLock()
	defer mu.RUnlock()
	return balance
}
```

Теперь функция `Balance` вызывает методы `RLock` и `RUnlock` для захвата и освобождения блокировки читателя, или
неисключительной блокировки. Функция `Deposit`, оставшаяся неизмененной, вызывает методы `mu.Lock` и `mu.Unlock` для
захвата и освобождения блокировки писателя, или исключительной блокировки.

После этого изменения большинство запросов Боба будут выполняться параллельно один другому и заканчиваться более быстро.
Блокировка будет доступна дольше, и запросы `Deposit` смогут выполняться своевременно.

`RLock` может использоваться, только если в критическом разделе нет записи совместно используемых переменных. В общем
случае мы не должны полагаться на то, что логически предназначенные только для чтения функции или методы не обновляют
также некоторые переменные. Например, метод, который представляется простым методом получения значения, может увеличить
и значение счетчика внутреннего использования, или обновить кеш, чтобы повторные вызовы выполнялись быстрее. Если вы
сомневаетесь, используйте исключительную блокировку `Lock`.

Использовать `RWMutex` выгодно только тогда, когда большинству горутин требуется блокировка читателей, и за
блокировку ведется состязание, т.е. горутинам приходится регулярно ожидать для ее захвата. `RWMutex` требует более
сложной внутренней бухгалтерии, **что делает его медленнее обычных мьютексов**.

## Выводы:

* Бывает ситуация, когда операции `чтения` безопасны параллельно, а операции `записи` требуют исключительного доступа;
  для такого сценария подходит блокировка `"несколько читателей, один писатель"`, которая в Go реализуется
  через `sync.RWMutex`;
* `RWMutex` отличается от обычного мьютекса тем, что разделяет блокировки на `читателей (RLock)` и `писателей (Lock)`,
  что позволяет параллельно выполнять операций чтения и ускоряет выполнение программы;
* `RLock` следует использовать только тогда, **когда в критическом разделе кода не происходит `записи` совместно
  используемых переменных**;
* Если в функции не только `чтение`, но и `обновление переменных` (например, счетчиков или кеша), лучше использовать
  `исключительную блокировку (Lock)` для безопасности;
* `RWMutex` рационально применять, когда большинству горутин требуется блокировка `читателей`, и за блокировку ведется
  состязание; такая блокировка работает медленнее обычных мьютексов из-за более сложной внутренней бухгалтерии, но
  обеспечивает параллельное выполнение операций чтения и ускоряет выполнение программы;
* `sync.RWMutex` - позволяет `нескольким горутинам одновременно читать данные` из общей переменной, но только `одной
  горутине изменять` их. Это означает, что если одна горутина получает `блокировку для записи (используя метод Lock)`,
  все остальные горутины, которые пытаются получить блокировку для `чтения (используя метод RLock)` или для записи,
  будут заблокированы до тех пор, пока первая горутина `не разблокирует RWMutex (используя метод Unlock)`. Однако если
  несколько горутин получают блокировку для чтения, они могут одновременно читать данные без
  блокировки друг друга. 