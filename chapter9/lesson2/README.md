# 9.2. Взаимные исключения: `sync.Mutex`

В разделе 8.6 мы использовали буферизованный канал в качестве `подсчитывающего семафора`, чтобы гарантировать, что
HTTP-запросы одновременно будут выполнять не более 20 go-подпрограмм. Мы используем ту же самую идею и канал емкостью 1
для того, чтобы гарантировать, что одновременно к совместно используемой переменной может обратиться только одна
горутина. Семафор, которым ведет подсчет только до 1, называется `бинарным семафором` (см. bank2.go).

``` go
var (
	sema    = make(chan struct{}, 1) // Бинарный семафор для защиты balance
	balance int
)

func Deposit(amount int) {
	sema <- struct{}{} // Захват токена
	balance = balance + amount
	<-sema // Освобождение токена
}

func Balance() int {
	sema <- struct{}{} // Захват токена
	b := balance
	<-sema // Освобождение токена
	return b
}
```

Такой шаблон `взаимного исключения` настолько полезен, что поддерживается непосредственно типом `Mutex` из
пакета `sync`. Его метод `Lock` захватывает токен (вызывает `блокировку`), а метод `Unlock` его освобождает (см.
bank3.go):

``` go
var (
	mu sync.Mutex
	banalce int
)

func Deposit(amount int) {
	mu.Lock()
	banalce = banalce + amount
	mu.Unlock()
}

func Balance() int {
	mu.Lock()
	b := banalce
	mu.Unlock()
	return b
}
```

Каждый раз, когда горутина обращается к переменным банка (здесь только `balance`), она должна вызвать метод `Lock`
мьютекса, чтобы получить монопольную блокировку. Если блокировка выполнена некоторой другой горутиной, текущая
операция будет заблокирована до тех пор, пока другая горутина не вызовет `Unlock` и не разрешит тем самым
блокировку другим горутинам. **Мьютекс охраняет совместно используемые переменные**. _По соглашению охраняемые
мьютексом переменные объявляются сразу же после объявления самого мьютекса_. Если вы поступаете иначе, обязательно
документируйте это отступление от правил.

Область кода между `Lock` и `Unlock`, в которой горутина может свободно читать и модифицировать совместно
используемые переменные, называется `критическим разделом`. Вызов `Unlock` владельцем блокировки `предшествует`
блокировке любой другой горутиной. Важно, чтобы горутина **обязательно освобождала блокировку** на всех путях выполнения
функции, включая пути ошибок.

Приведенная выше программа банка иллюстрирует распространенный шаблон параллелизма. Набор экспортируемых функций
`инкапсулирует` одну или несколько переменных, так что единственный способ доступа к переменным — через эти функции (или
методы для переменных объекта). Каждая функция выполняет блокировку в начале и освобождение от нее в конце, обеспечивая
тем самым недоступность совместно используемых переменных одновременно нескольким горутинам. Этот механизм работы
с блокировками, функциями и переменными называется `монитором`. (Это более старое использование термина "монитор"
породило термин "мониторная горутина". Оба употребления имеют общее значение посредника, который обеспечивает
последовательный доступ к переменным).

Поскольку критические разделы функций `Deposit` и `Balance` очень коротки — в одну строку, без ветвлений, —
вызов `Unlock` в конце прост. В более сложных критических разделах, в особенности в тех, в которых ошибки приводят к
более раннему возвращению из программы, может быть трудно гарантировать, что вызовы `Lock` и `Unlock` строго
соответствуют один другому на всех путях выполнения. На помощь приходит инструкция `defer`: откладывание вызова `Unlock`
неявно расширяет критический раздел до конца текущей функции, что избавляет нас от необходимости помнить о вставке
вызова `Unlock` в одном или нескольких местах вдали от вызова блокировки.

``` go
func Balance() int {
	mu.Lock()
	defer mu.Unlock()
	return balance
}
```

В приведенном выше примере `Unlock` выполняется после того, как инструкция `return` считывает значение
переменной `balance`,
так что функция `Balance` безопасна с точки зрения параллельности. В качестве бонуса мы больше не нуждаемся в локальной
переменной `b`.

Кроме того, отсроченный вызов `Unlock` будет выполняться даже при панике в критическом разделе, что может
иметь важное значение в программах, которые используют `recover` (раздел 5.10). Применение `defer` немного дороже, чем
явный вызов `Unlock`, но недостаточно дороже, чтобы оправдать менее ясный код. В параллельных программах всегда следует
предпочитать ясность и сопротивляться преждевременной оптимизации. Там, где это возможно, используйте `defer` и
позвольте критическому разделу продлиться до конца функции.

Рассмотрим приведенную ниже функцию `Withdraw`. При успешном завершении она уменьшает баланс на указанную величину и
возвращает `true`. Но если на счету недостаточно средств для транзакции, `Withdraw` восстанавливает старое значение
баланса и возвращает значение `false`.

``` go
// Примечание: функция не атомарная!(Атомарная операция - это операция, которая либо выполняется целиком, либо не выполняется вовсе)
func Withdraw(amount int) bool {
	Deposit(-amount)
	if Balance() < 0 {
		Deposit(amount)
		return false // Недостаточно средств
	}
	return true
}
```

Функция в конечном итоге дает правильный результат, но имеет неприятный побочный эффект. При попытке снятия со счета
**чрезмерной суммы** баланс **временно** опускается ниже нуля. Это может привести к тому, что **параллельное** снятие
скромной суммы окажется **ложно отвергнутым**. Так что, если Боб попытается купить спортивный автомобиль, Алиса не
сможет оплатить свой утренний кофе. Проблема заключается в том, что `функция Withdraw не атомарная`: она состоит из
последовательности трех отдельных операций, каждая из которых **захватывает**, а затем **освобождает** мьютекс, но ничто
не блокирует всю последовательность.

В идеале функция `Withdraw` должна выполнить блокировку **один раз** для всех операций. Однако такая попытка не
работает.

``` go
// Примечание: неверно!
func Withdraw(amount int) bool {
	mu.Lock()
	defer mu.Unlock()
	Deposit(-amount)
	if Balance() < 0 {
		Deposit(amount)
		return false // Недостаточно средств
	}
	return true
}
```

Функция `Deposit` пытается захватить мьютекс второй раз путем вызова `mu.Lock()`, но так как блокировка мьютекса
`не реентерабелъна (не позволяет блокировать уже заблокированный мьютекс)`, это приводит к `взаимоблокировке`, когда
программа не выполняет никаких действий, поскольку функция `Withdraw` заблокирована навечно.

`Не реентерабельность мьютексов` вполне понятна и обоснована. Мьютексы призваны обеспечить сохранение определенных
инвариантов совместно используемых переменных в критических точках во время выполнения программы. Один из этих
инвариантов — `"никакая горутина не имеет доступа к совместно используемой переменной"`, но могут быть и
дополнительные инварианты, специфичные для структуры данных, которую охраняет мьютекс. Когда горутина выполняет
блокировку, она может предполагать выполнение инвариантов. `Во время блокировки` она может обновлять совместно
используемые переменные, так что инварианты временно нарушаются. Однако при `снятии блокировки` горутина должна
гарантировать, что порядок восстановлен и инварианты вновь выполняются. Хотя реентерабельный мьютекс мог бы
гарантировать, что никакие другие горутины не получают доступ к совместно используемым переменным, никакие другие
дополнительные инварианты этих переменных он бы защитить не мог.

Распространенное решение заключается в разделении функций, таких как `Deposit`, на две: неэкспортируемую
функцию `deposit`,
которая предполагает, что блокировка уже выполнена и выполняет реальную работу, и экспортируемую функцию `Deposit`,
которая выполняет блокировку до вызова `deposit`. Тогда мы можем выразить функцию Withdraw с помощью функции `deposit`
следующим образом:

``` go
func Withdraw(amount int) bool {
	mu.Lock()
	defer mu.Unlock()
	deposit(-amount)
	if balance < 0 {
		deposit(amount)
		return false // Недостаточно средств
	}
	return true
}

func Deposit(amount int) {
	mu.Lock()
	defer mu.Unlock()
	deposit(amount)
}

func Balance() int {
	mu.Lock()
	defer mu.Unlock()
	return balance
}

// Эта функция требует, чтобы была выполнена блокировка.
func deposit(amount int) { balance += amount }

```

Конечно, приведенная здесь функция `deposit` настолько тривиальна, что функции `Withdraw` нет смысла ее вызывать; тем не
менее она иллюстрирует описанный выше принцип.

Инкапсуляция (раздел 6.6), уменьшая неожиданные взаимодействия в программе, помогает нам поддерживать инварианты
структур данных. По той же причине инкапсуляция помогает также поддерживать инварианты параллелизма. **При использовании
мьютекса убедитесь, что и он, и переменные, которые он защищает, не экспортируются, независимо от того, являются ли они
переменными уровня пакета или полями структуры**.

## Выводы:

* `Бинарный семафор` (канал емкостью 1) используется для гарантии одновременного доступа к совместно используемой
  переменной только одной горутиной;
* Для более удобного механизма взаимного исключения можно использовать тип `Mutex` из пакета `sync` с методами `Lock`
  и `Unlock` для захвата и освобождения токена блокировки соответственно;
* `Мьютекс` **охраняет совместно используемые переменные**, и важно соблюдать соглашение об объявлении этих переменных
  сразу после объявления самого мьютекса;
* `Критический раздел` - область кода между `Lock` и `Unlock`, в которой горутина может безопасно читать и
  модифицировать совместно используемые переменные;
* `Монитор` - механизм блокировок, функций и переменных, который позволяет одной или нескольким функциям инкапсулировать
  переменные и обеспечивать последовательный доступ к ним для нескольких горутин;
* Использование инструкции `defer` позволяет отложить вызов `Unlock` и автоматически продлить критический раздел до
  конца функции, облегчая обработку освобождения блокировки на всех путях выполнения, включая пути ошибок;
* Отложенный вызов `Unlock` будет выполняться даже при `панике` во время выполнения критического раздела, что может быть
  важным в программах, использующих `recover`;
* Важно обеспечить `атомарность` операций (либо операция выполняется полностью, либо вообще не выполняется), чтобы
  избежать побочных эффектов, вызванных неправильной обработкой конкурентных операций, таких как временное опускание
  значения переменной ниже нуля или ложное отклонение транзакции;
* В Golang следует предпочитать ясность и последовательность кода, избегая преждевременной оптимизации и активно
  использовать `defer` и `мьютексы` для обеспечения безопасности при параллельном программировании;
* Функция `Deposit` может вызвать `взаимоблокировку (deadlock)` из-за попытки **захватить мьютекс дважды**; это
  происходит из-за `нереентерабельности мьютексов`, то есть **они не позволяют блокировать уже заблокированный
  мьютекс**;
* `Мьютексы` используются для обеспечения сохранения инвариантов совместно используемых переменных в критических точках
  **во время выполнения программы**, что позволяет избежать ошибок и несогласованности данных;
* Распространенное `решение` проблемы `реентерабельности мьютексов` - разделение функций на две: **неэкспортируемую
  функцию**, которая делает реальную работу, и **экспортируемую функцию**, которая выполняет блокировку до вызова
  первой;
* Инкапсуляция помогает поддерживать инварианты структур данных и параллелизма, а также уменьшает неожиданные
  взаимодействия в программе, что приводит к более стабильному и безопасному коду;
* Важно **не экспортировать мьютексы и переменные, которые они защищают**, независимо от того, являются ли они
  переменными уровня пакета или полями структуры, для соблюдения инкапсуляции и поддержания порядка в коде;
* Использование мьютексов и принципов инкапсуляции в коде на языке Golang способствует созданию надежных и
  производительных приложений, так как минимизирует возможность ошибок из-за совместного доступа к переменным и
  параллельного выполнения.
