# 9.5. Отложенная инициализация: `sync.Once`

Отложить этап дорогостоящей инициализации до того момента, когда она необходима, — хорошая практика. Инициализация
переменных в начале работы увеличивает задержку запуска программы и не является необходимой, если выполнение программы
не всегда достигает той части, которая использует эту переменную. Давайте вернемся к переменной `icons`, которую мы уже
видели в этой главе:

``` go
var icons map[string]image.Image
```

Следующая версия Icon использует `отложенную инициализацию`:

``` go
func loadIcons() {
	icons = map[string]image.Image{
		"spades.png":   loadIcon("spades.png"),
		"hearts.png":   loadIcon("hearts.png"),
		"diamonds.png": loadIcon("diamonds.png"),
		"clubs.png":    loadlcon("clubs.png"),
	}
}

// Примечание: небезопасно с точки зрения параллельности!
func Icon(name string) image.Image {
	if icons == nil {
		loadIcons() // Однократная инициализация
	}
	return icons[name]
}
```

Для переменной, доступ к которой осуществляется только одной горутиной, можно использовать приведенный выше
шаблон, но эта модель **не является безопасной**, если `Icon` вызывается **параллельно**. Как и исходная функция
`Deposit`, `Icon` выполняется в несколько этапов: проверяет, не равно ли `nil` значение `icons`, загружает пиктограммы и
обновляет значение `icons`. Интуитивно можно предположить, что наихудший возможный результат состояния гонки — то, что
функция `loadlcons` вызывается несколько раз. Пока первая горутина занята загрузкой пиктограмм, вторая
горутина входит в функцию Icon, обнаруживает, что значение переменной равно `nil`, и также вызывает `loadlcons`.

Но и здесь интуиция подводит. (Мы надеемся, что теперь вы выработаете новое интуитивное представление о параллелизме —
что доверять интуиции относительно параллелизма нельзя!) Вспомните обсуждение памяти в разделе 9.4. **В отсутствие явной
синхронизации компилятор и процессор могут свободно переупорядочивать доступы к памяти** любыми способами при условии,
что поведение каждой горутины остается `последовательно согласованным`. Ниже приведено одно из возможных
переупорядочений инструкций `loadlcons`. Оно сохраняет пустую карту в переменной `icons` до его заполнения:

``` go
func loadIcons() {
	icons = make(map[string]image.Image) 
	icons["spades.png"] =   loadlcon("spades.png") 
	icons["hearts.png"] =   loadlcon("hearts.png") 
	icons["diamonds.png"] = loadIcon("diamonds.png") 
	icons["clubs.png"] =    loadlcon("clubs.png")
}
```

Следовательно, горутина, обнаружившая, что значение `icons` не равно `nil`, не может считать, что инициализация этой
переменной выполнена полностью.

Простейший корректный способ гарантировать, что все горутины увидят результат `loadlcons`, — **синхронизировать их с
применением мьютекса**:

``` go
var mu sync.Mutex // Защищает icons
var icons map[string]image.Image {
	mu.Lock()
	defer mu.Unlock()
	if icons == nil {
		loadIcons()	
	}
	return icons[name]
}
```

Однако ценой реализации **взаимно исключающего доступа** к `icons` является то, что две горутины не смогут получить
доступ к переменной одновременно даже после того, как переменная будет безопасно инициализирована и никогда не будет
изменена снова. Это предполагает применение **блокировки для нескольких читателей** (`RWMutex`):

``` go
var mu sync.RWMutex // Защищает icons
var icons map[string]image.Image

// Безопасно с точки зрения параллелизма
func Icon(name string) image.Image {
	mu.RLock()
	if icons == nil {
		icon := icons[name]
		mu.RUnlock()
		return icon
	}
	mu.RUnlock()
	
	// Исключительная блокировки
	mu.Lock()
	if icons == nil { // Примечание: нужна повторная проверка на nil
		loadIcons()
	}
	icon := icons[name]
	mu.Unlock()
	return icon
}
```

Теперь в наличии `два` критических раздела. Горутина сначала выполняет блокировку для `чтения`, проверяет
карту, а затем `снимает блокировку`. Если запись найдена (основной случай), она возвращается функцией. Если запись
не найдена, горутина осуществляет `блокировку для записи`. Нет способа обновить неисключительную блокировку (`RWMutex`)
до исключительной (`Mutex`) без предварительного снятия блокировки, а потому мы должны перепроверить переменную `icons`
на тот случай, если другая горутина уже инициализировала ее в промежутке между блокировками.

Такой шаблон обеспечивает более высокую степень параллелизма, но является сложным и, таким образом, подверженным
ошибкам. К счастью, пакет `sync` предоставляет специализированное средство решения проблемы `однократной инициализации:
sync.Once`. Концептуально `Once` состоит из `мьютекса и логической переменной`, записывающей, имела ли инициализация
место; мьютекс защищает как логическое значение, так и структуры данных клиента. Единственный метод `Do` принимает в
качестве своего аргумента функцию инициализации. Давайте используем `Once` для упрощения функции `Icon`:

``` go
var loadIconsOnce sync.Once
var icons map[string]image.Image

// Безопасно с точки зрения параллельности.
func Icon(name string) image.Image {
	loadIconsOnce.Do(loadIcons)
	return icons[name]
}
```

Каждый вызов `Do(loadlcons)` **блокирует мьютекс и выполняет проверку булевой переменной**. В первом вызове, когда
переменная имеет значение `false`, `Do` вызывает функцию `loadlcons`, а значение булевой переменной становится равным
`true`. Последующие вызовы ничего не делают, но синхронизация с помощью мьютекса гарантирует, что влияние `loadlcons` на
память (конкретно на `icons`) становится **видимым для всех горутин**. Используя `sync.Once` таким образом, мы можем
избежать совместного использования переменных другими горутинами до их корректного конструирования.

## Выводы:

* `Отложенная инициализация` - хорошая практика для уменьшения времени запуска программы и экономии ресурсов, поскольку
  она происходит **только тогда, когда это действительно необходимо**;
* Использование отложенной инициализации с одиночной переменной доступной **только одной горутине** может быть
  достигнуто с помощью простого условия проверки на `nil`, но такой подход **не является безопасным для параллельного
  доступа**;
* Для корректной синхронизации между горутинами необходимо использовать мьютексы, такие, как `sync.Mutex`
  или `sync.RWMutex`, которые предотвращают одновременный доступ к общим данным, исключая возможность состояний гонки;
* Использование `sync.RWMutex` позволяет обеспечить более высокую степень параллелизма, но требует более сложной
  реализации;
* Для упрощения синхронизации и решения задачи однократной инициализации можно использовать специализированный
  инструмент - `sync.Once`, который гарантирует, что функция инициализации **вызывается только один раз**;
* Метод `sync.Once.Do()` **принимает функцию инициализации в качестве аргумента**, а выполнение инициализации
  осуществляется **только при первом вызове**, одновременно гарантируя видимость изменений в памяти для всех горутин;
* Использование `sync.Once` позволяет избежать **преждевременного доступа** к переменным и **обеспечивает корректную
  синхронизацию и инициализацию данных в параллельных средах**.