# 9.6. Детектор гонки

Даже при максимальной аккуратности все равно слишком легко допустить ошибки параллелизма. К счастью, среда выполнения Go
и ее инструментарий оснащены интеллектуальным, но простым в использовании инструментом динамического анализа —
`детектором гонки`.

Просто добавьте флаг `-race` к команде `go build`, `go run` или `go test`. Это заставит **компилятор создать
модифицированную версию вашего приложения или теста с дополнительным инструментарием**, который эффективно записывает
все обращения к **совместно используемым переменным**, произошедшим **во время выполнения**, наряду с информацией о
горутине, которая читает или записывает переменную. Кроме того, **измененная программа записывает все события
синхронизации**, такие как инструкции `go`, `операции над каналами`, `вызовы (*sync .Mutex).Lock`,
`(*sync.WaitGroup).Wait` и т.д. (Полный набор событий синхронизации определяется документом `The Go Memory Model` (
Модель памяти Go), который содержится в спецификации языка.)

`Детектор гонки` изучает этот поток событий в поисках случаев, когда одна горутина считывает или записывает
совместно используемую переменную, которая совсем недавно была записана другой горутиной, без промежуточных
операций синхронизации. Это означает **одновременный доступ к такой переменной** и, таким образом, **гонку данных**.

Инструментарий выводит **отчет**, включающий **идентификатор переменной**, и **стеки вызовов активных функций** в
горутинах чтения и записи. Этого обычно достаточно, чтобы точно локализовать проблему. В разделе 9.7 содержится пример
детектора **гонки в действии**.

`Детектор гонки` сообщает обо **всех** гонках данных, которые **фактически были выполнены**. Однако он может обнаружить
только те состояния гонки, **которые происходят во время выполнения**; **он не может доказать, что никакие другие гонки
не
будут когда-либо происходить**. Для достижения наилучших результатов убедитесь, что ваши тесты проверяют ваши пакеты с
использованием параллелизма.

Из-за дополнительных действий по записи информации программа, построенная с обнаружением гонки, требует при работе
**больше памяти и работает дольше**, но накладные расходы вполне приемлемы даже для многих производственных программ.
Для редко встречающегося состояния гонки включение детектора может сэкономить часы или даже дни отладки.

## Выводы:

* Даже при максимальной аккуратности в программировании, существует риск допущения ошибок параллелизма;
* В Go существует инструмент динамического анализа - `детектор гонки`, который помогает обнаруживать эти ошибки;
* Для активации детектора гонки, достаточно добавить флаг `-race` к командам `go build`, `go run` или `go test`;
* Этот флаг приведет к созданию **модифицированной версии приложения или теста** с дополнительным инструментарием для
  анализа обращений к совместно используемым переменным и событиями синхронизации;
* `Детектор гонки` изучает поток событий и определяет случаи возможных гонок данных между горутинами;
* В результате анализа, детектор гонки выдает отчет, содержащий идентификатор переменной и стеки вызовов активных
  функций для лучшего понимания и исправления проблемы;
* Детектор гонки показывает только **фактически выполненные гонки данных во время выполнения**, но не может доказать
  отсутствие других гонок;
* При использовании детектора гонки программа **требует больше памяти и времени на выполнение**, но это оправдано при редко
  встречающихся состояниях гонки, так как помогает сэкономить время на отладку;
* Использование детектора гонки в Golang полезно для обеспечения корректной работы приложений, предотвращения ошибок
  параллелизма и ускорения процесса разработки и отладки программ.