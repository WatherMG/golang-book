# 11. Тестирование

Морис Уилкс (Maurice Wilkes), разработчик EDSAC, первого компьютера с хранимой программой, в 1949 году столкнулся со
случаем поразительного ясновидения, когда поднимался по лестнице в свою лабораторию. В своей книге Memoirs of a Computer
Pioneer он пишет, как его "с необычайной силой охватила уверенность, что большая часть жизни будет потрачена на поиск
ошибок в собственных программах". Наверняка каждый программист, работающий на компьютере с хранимой программой, отлично
понимает Уилкса, хотя, возможно, не без некоторого удивления его наивности в вопросах построения сложного программного
обеспечения.

Конечно, сегодняшние программы гораздо больше и сложнее, чем во времена Уилкса, и было затрачено множество усилий на
разработку методов, которые сделали бы эту сложность сколь-нибудь управляемой. Своей эффективностью выделяются два
метода. Во-первых, это рутинный коллегиальный просмотр программ, а во-вторых — предмет настоящей главы: тестирование.
Тестирование, под которым мы неявно подразумеваем автоматизированное тестирование, представляет собой практику написания
небольших программ, которые проверяют, что тестируемый код (готовый код) ведет себя так, как от него и ожидается, для
некоторых входных данных — либо тщательно отобранных для осуществления определенных возможностей, либо случайных для
обеспечения наиболее широкого охвата всех вариантов.

Область тестирования программного обеспечения огромна. Задача тестирования отнимает у всех программистов некоторое их
время, а у некоторых программистов — все их время. Литература по тестированию включает тысячи печатных книг и миллионы
слов в блогах. Для каждого из основных языков программирования имеются десятки пакетов программного обеспечения,
предназначенных для тестирования, некоторые — с привлечением серьезных теоретических разработок. Всего этого почти
достаточно для того, чтобы убедить программистов, что для написания эффективных тестов они должны приобрести совершенно
новый набор навыков.

По сравнению со всяческими современными технологиями подход Go к тестированию может показаться довольно устаревшим. Он
опирается на единственную команду, `go test`, и ряд соглашений по написанию тестовых функций, которые запускает эта
команда. Сравнительно легковесный механизм является легко расширяемым и достаточно эффективным для чистого тестирования.

На практике написание тестового кода не сильно отличается от написания самой оригинальной программы. Мы пишем короткие
функции, которые сосредоточены на некоторой одной части задачи. Мы должны быть осторожны с граничными условиями, думать
о структурах данных и понимать, какие результаты вычислений должны получаться из тех или иных входных данных. Но это тот
же процесс, что и написание обычного кода Go; он не требует новых обозначений, соглашений и инструментария.

## Выводы:

* Тестирование программного обеспечения - это практика написания небольших программ, которые проверяют, что тестируемый
  код (готовый код) ведет себя так, как от него и ожидается, для определенных входных данных;
* Go использует простой и эффективный подход к тестированию с помощью команды `go test` и ряда
  соглашений по написанию тестовых функций;
* Написание тестового кода в Go аналогично написанию основного кода и не требует новых обозначений, соглашений или
  инструментов;
* Тестирование на Go может помочь обнаружить ошибки и улучшить качество кода, благодаря тщательному отбору тестовых
  данных и проверке граничных условий;
* Тестирование на Go дает возможность программистам сосредоточиться на определенных частях задачи и контролировать
  результаты вычислений с разными входными данными.

<!-- TOC -->

* [11.1. Инструмент gotest](#111-инструмент-gotest)
* [11.2. Тестовые функции](#112-тестовые-функции)
	* [11.2.1 Рандомизированное тестирование](#1121-рандомизированное-тестирование)
	* [11.2.2 Тестирование команд](#1122-тестирование-команд)
	* [11.2.3 Тестирование белого ящика](#1123-тестирование-белого-ящика)
	* [11.2.4 Внешние тестовые пакеты](#1124-внешние-тестовые-пакеты)
	* [11.2.5 Написание эффективных тестов](#1125-написание-эффективных-тестов)
	* [11.2.6 Избегайте хрупких тестов](#1126-избегайте-хрупких-тестов)
* [11.3. Охват](#113-охват)
* [11.4. Функции производительности](#114-функции-производительности)
* [11.5. Профилирование](#115-профилирование)
* [11.6. Функции-примеры](#116-функции-примеры)

<!-- TOC -->

____

# 11.1. Инструмент go test

* Команда `go test` является **тест-драйвером** для пакетов Go, организованных согласно определенным соглашениям;
* `go test` позволяет проверять **программную логику (Test*)**, **производительность(Benchmark*)** и
  **машинно-проверяемую документацию (Example*)**;
* Файлы `*_test.go` представляют собой часть **временного пакета** `main`, который создается и запускается `go test`;
* `go test` сканирует файлы `*_test.go` на предмет наличия тестовых функций, функций производительности и
  функций-примеров.

____

# 11.2. Тестовые функции

* Каждый тестовый файл в Go должен импортировать пакет `testing`; это необходимо для корректной работы инструментов
  тестирования Go;
* Имена тестовых функций должны начинаться с `Test`, и далее следует необязательный суффикс, начинающийся с прописной
  буквы; это соглашение упрощает поиск тестовых функций при использовании команды `go test`;
* Параметр `t` в тестовых функциях предоставляет **методы для сообщения о не пройденных тестах и для протоколирования
  дополнительной информации**; это помогает лучше отслеживать поведение тестов и выявлять проблемы в коде;
* `go test` используют для компиляции и выполнения тестов;
* Сначала нужно написать тест, который воспроизводит проблему, чтобы убедиться в ее наличии; это поможет быстрее
  определить и исправить источник ошибки;
* `Табличное тестирование (table-driven testing)` - хороший подход для написания тестовых примеров в Go, так как он
  позволяет легко добавлять новые записи в таблицу и избегает дублирования проверок и вывода сообщений об ошибках;
* Тесты в Go `не зависят друг от друга`; использование методов `t.Error` или `t.Errorf` не приводит к `панике`
  или `остановке выполнения теста`, что позволяет узнать о **нескольких сбоях при одном запуске теста**;
* В случае, если необходимо остановить тестирование после определенной ошибки, нужно использовать методы `t.Fatal`
  или `t.Fatalf`, но вызывать их нужно **только из той же горутины, что и функция тестирования**;
* Формат сообщений об ошибках в тестах должен быть **понятным и информативным**, включая информацию о выполняемой
  операции, фактический результат и ожидаемый результат; такой подход сэкономит время при диагностике ошибок и поможет
  быстрее исправить проблемы;

____

## 11.2.1 Рандомизированное тестирование

* `Рандомизированное тестирование` используется для проверки функций на более широком спектре входных данных, создавая
  их случайным образом;
* Для проверки результатов рандомизированного тестирования можно использовать две стратегии: **написать альтернативную
  реализацию функции с более простым алгоритмом** или **создавать входные значения по определенному шаблону, для
  которого известен ожидаемый результат**;
* Рандомизированные тесты `недетерминированны`, поэтому нужно записывать достаточно информации для воспроизведения
  сбоев, например, инициализирующее значение генератора псевдослучайных чисел;
* Использование **текущего времени в качестве источника случайности** обеспечивает тестирование с новыми наборами
  входных данных при каждом запуске, что особенно полезно при автоматизированном выполнении тестов;
* Рандомизированное тестирование может осуществляться с помощью функций, генерирующих случайные входные
  данные, и обработки результатов с использованием стандартного пакета "`testing`";
* Использование рандомизированного тестирования позволяет охватить больше потенциальных случаев, на которых
  функция может работать некорректно, улучшая таким образом надежность кода и уменьшая вероятность ошибок в будущем.

____

## 11.2.2 Тестирование команд

* Пакет с именем `main` может быть импортирован как **библиотека**, что позволяет использовать его функции для
  тестирования;
* Разделение программы на две функции, одна из которых выполняет основную работу, а другая обрабатывает входные данные,
  **облегчает тестирование и делает программу более модульной**;
* Добавление параметров в функцию может уменьшить зависимость от глобальных переменных и упростить тестирование;
* Использовать `io.Writer` для записи результата функции позволяет **подставить другую реализацию во время
  тестирования**, упрощая проверку результатов работы функций;
* Тестовый код находится в том же пакете, что и основной рабочий код, что позволяет использовать функции и переменные
  пакета для тестирования;
* Создание таблицы с тестовыми данными упрощает добавление новых тестовых примеров и улучшает структуру тестового кода;
* Ошибка в тесте должна описывать **неудачную операцию, фактическое и ожидаемое поведение**, что облегчает понимание
  причины проблемы;
* Тестируемый код не должен вызывать функции, такие как `log.Fatal` или `os.Exit`, чтобы избежать непредвиденного
  завершения тестирования; сообщать об ожидаемых ошибках можно, возвращая ненулевое значение ошибки;
* В случае **паники** тест-драйвер выполнит **восстановление**, и тест будет считаться **не пройденным**.

____

## 11.2.3 Тестирование белого ящика

____

## 11.2.4 Внешние тестовые пакеты

____

## 11.2.5 Написание эффективных тестов

____

## 11.2.6 Избегайте хрупких тестов

____

# 11.3. Охват

____

# 11.4. Функции производительности

____

# 11.5. Профилирование

____

# 11.6. Функции-примеры

____