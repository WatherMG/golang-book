# 11. Тестирование

Морис Уилкс (Maurice Wilkes), разработчик EDSAC, первого компьютера с хранимой программой, в 1949 году столкнулся со
случаем поразительного ясновидения, когда поднимался по лестнице в свою лабораторию. В своей книге Memoirs of a Computer
Pioneer он пишет, как его "с необычайной силой охватила уверенность, что большая часть жизни будет потрачена на поиск
ошибок в собственных программах". Наверняка каждый программист, работающий на компьютере с хранимой программой, отлично
понимает Уилкса, хотя, возможно, не без некоторого удивления его наивности в вопросах построения сложного программного
обеспечения.

Конечно, сегодняшние программы гораздо больше и сложнее, чем во времена Уилкса, и было затрачено множество усилий на
разработку методов, которые сделали бы эту сложность сколь-нибудь управляемой. Своей эффективностью выделяются два
метода. Во-первых, это рутинный коллегиальный просмотр программ, а во-вторых — предмет настоящей главы: тестирование.
Тестирование, под которым мы неявно подразумеваем автоматизированное тестирование, представляет собой практику написания
небольших программ, которые проверяют, что тестируемый код (готовый код) ведет себя так, как от него и ожидается, для
некоторых входных данных — либо тщательно отобранных для осуществления определенных возможностей, либо случайных для
обеспечения наиболее широкого охвата всех вариантов.

Область тестирования программного обеспечения огромна. Задача тестирования отнимает у всех программистов некоторое их
время, а у некоторых программистов — все их время. Литература по тестированию включает тысячи печатных книг и миллионы
слов в блогах. Для каждого из основных языков программирования имеются десятки пакетов программного обеспечения,
предназначенных для тестирования, некоторые — с привлечением серьезных теоретических разработок. Всего этого почти
достаточно для того, чтобы убедить программистов, что для написания эффективных тестов они должны приобрести совершенно
новый набор навыков.

По сравнению со всяческими современными технологиями подход Go к тестированию может показаться довольно устаревшим. Он
опирается на единственную команду, `go test`, и ряд соглашений по написанию тестовых функций, которые запускает эта
команда. Сравнительно легковесный механизм является легко расширяемым и достаточно эффективным для чистого тестирования.

На практике написание тестового кода не сильно отличается от написания самой оригинальной программы. Мы пишем короткие
функции, которые сосредоточены на некоторой одной части задачи. Мы должны быть осторожны с граничными условиями, думать
о структурах данных и понимать, какие результаты вычислений должны получаться из тех или иных входных данных. Но это тот
же процесс, что и написание обычного кода Go; он не требует новых обозначений, соглашений и инструментария.

## Выводы:

* Тестирование программного обеспечения - это практика написания небольших программ, которые проверяют, что тестируемый
  код (готовый код) ведет себя так, как от него и ожидается, для определенных входных данных;
* Go использует простой и эффективный подход к тестированию с помощью команды `go test` и ряда
  соглашений по написанию тестовых функций;
* Написание тестового кода в Go аналогично написанию основного кода и не требует новых обозначений, соглашений или
  инструментов;
* Тестирование на Go может помочь обнаружить ошибки и улучшить качество кода, благодаря тщательному отбору тестовых
  данных и проверке граничных условий;
* Тестирование на Go дает возможность программистам сосредоточиться на определенных частях задачи и контролировать
  результаты вычислений с разными входными данными.

<!-- TOC -->

* [11.1. Инструмент gotest](#111-инструмент-gotest)
* [11.2. Тестовые функции](#112-тестовые-функции)
	* [11.2.1 Рандомизированное тестирование](#1121-рандомизированное-тестирование)
	* [11.2.2 Тестирование команд](#1122-тестирование-команд)
	* [11.2.3 Тестирование белого ящика](#1123-тестирование-белого-ящика)
	* [11.2.4 Внешние тестовые пакеты](#1124-внешние-тестовые-пакеты)
	* [11.2.5 Написание эффективных тестов](#1125-написание-эффективных-тестов)
	* [11.2.6 Избегайте хрупких тестов](#1126-избегайте-хрупких-тестов)
* [11.3. Охват](#113-охват)
* [11.4. Функции производительности](#114-функции-производительности)
* [11.5. Профилирование](#115-профилирование)
* [11.6. Функции-примеры](#116-функции-примеры)

<!-- TOC -->

____

# 11.1. Инструмент go test

* Команда `go test` является **тест-драйвером** для пакетов Go, организованных согласно определенным соглашениям;
* `go test` позволяет проверять **программную логику (Test*)**, **производительность(Benchmark*)** и
  **машинно-проверяемую документацию (Example*)**;
* Файлы `*_test.go` представляют собой часть **временного пакета** `main`, который создается и запускается `go test`;
* `go test` сканирует файлы `*_test.go` на предмет наличия тестовых функций, функций производительности и
  функций-примеров.

____

# 11.2. Тестовые функции

____

## 11.2.1 Рандомизированное тестирование

____

## 11.2.2 Тестирование команд

____

## 11.2.3 Тестирование белого ящика

____

## 11.2.4 Внешние тестовые пакеты

____

## 11.2.5 Написание эффективных тестов

____

## 11.2.6 Избегайте хрупких тестов

____

# 11.3. Охват

____

# 11.4. Функции производительности

____

# 11.5. Профилирование

____

# 11.6. Функции-примеры

____