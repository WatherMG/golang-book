# 11.2. Тестовые функции

Каждый тестовый файл должен импортировать пакет `testing`. Тестовые функции имеют следующую сигнатуру:

``` go
func TestName(t *testing.T) {
	//...
}
```

Имена тестовых функций должны начинаться с `Test`; необязательный суффикс должен начинаться с прописной буквы:

``` go
func TestSin(t *testing.T) { /*...*/ }
func TestCos(t *testing.T) { /*...*/ }
func TestLog(t *testing.T) { /*...*/ }
```

Параметр `t` предоставляет **методы для отчета о не пройденных тестах и для протоколирования дополнительной
информации**. Давайте определим пакет примера ch11/word1, содержащий одну функцию `IsPalindrome`, которая сообщает,
является ли строка палиндромом, т.е. дает ли чтение ее в обратном направлении ту же строку. (Приведенная реализация
проверяет каждый байт дважды, если строка является палиндромом; мы вернемся к этому вопросу в ближайшее время.)

``` go
package word

// IsPalindrome сообщает, является ли s палиндромом.
func IsPalindrome(s string) bool {
	for i := range s {
		if s[i] != s[len(s)-1-i] {
			return false
		}
	}
	return true
}
```

Находящийся в том же каталоге файл `word_test.go` содержит две тестовые функции с именами `TestPalindrome` и
`TestNonPalindrome`. Каждая из них проверяет, дает ли `IsPalindrome` правильный ответ для одного ввода, и сообщает о
сбоях с помощью `t.Error`:

``` go
package word

import "testing"

func TestPalindrome(t *testing.T) {
	if !IsPalindrome("detartrated") {
		t.Error(`IsPalindrome("detartrated") = false`)
	}
	if !IsPalindrome("kayak") {
		t.Error(`IsPalindrome("kayak") = false`)
	}
}

func TestNotPalindrome(t *testing.T) {
	if IsPalindrome("palindrome") {
		t.Error(`IsPalindrome("palindrome") = true`)
	}
}
```

Команда `go test` (или `go build`) без аргумента, указывающего пакет, работает с пакетом в текущем каталоге. Мы можем
строить и выполнять тесты с помощью следующей команды:

```shell
cd $env:GOPATH\src\GolangBook\chapter11\lesson2\word1\
go test 
# ok      GolangBook/chapter11/lesson2/word1      0.198s
```

Довольные, мы отправляем программу заказчику, но не успеваем отметить это событие банкетом, как начинают прибывать
сообщения об ошибках. Французский пользователь по имени Noelle Eve Elleon жалуется на то, что `IsPalindrome` не
распознает слово "`été`". Другой, из Центральной Америки, разочарован тем, что программа отвергает
фразу "`A man, a plan, a canal: Panama`". Эти конкретные сообщения естественным образом подходят для новых тестовых
примеров:

``` go
func TestFrenchPalindrome(t *testing.T) {
	if !IsPalindrome("été") {
		t.Error(`IsPalindrome("été") = false`)
	}
}

func TestCanalPalindrome(t *testing.T) {
	input := "A man, a plan, a canal: Panama"
	if !IsPalindrome(input) {
		t.Errorf(`IsPalindrome(%q) = false`, input)
	}
}
```

Чтобы избежать написания длинной входной строки дважды, мы используем функцию `Errorf`, которая обеспечивает такое же
форматирование, как и функция `Printf`.

После добавления двух новых тестов команда `go test` выдает информативные сообщения об ошибках:

``` shell
go test
--- FAIL: TestFrenchPalindrome (0.00s)                    
    word_test.go:22: IsPalindrome("été") = false
--- FAIL: TestCanalPalindrome (0.00s)
    word_test.go:29: IsPalindrome("A man, a plan, a canal: Panama") = false
FAIL    GolangBook/chapter11/lesson2/word1      0.205s
```

Всегда следует **сначала написать тест и убедиться, что он вызывает те же проблемы, что и в сообщении пользователя об
ошибке**. Только тогда мы можем быть уверены в том, что проблема действительно имеется и что она именно в нашей функции,
и
начать работать над ее исправлением.

Кроме того, запуск `go test` обычно выполняется быстрее, чем ручной проход по всем шагам, указанным в сообщении
пользователя. Если набор тестов содержит много медленных проверок, мы можем ускорить тестирование, отбирая интересующие
нас тестовые примеры.

Флаг `-v` приводит к выводу имени и времени выполнения каждого теста пакета:

``` go
go test -v
=== RUN   TestPalindrome
--- PASS: TestPalindrome (0.00s)
=== RUN   TestNotPalindrome
--- PASS: TestNotPalindrome (0.00s)
=== RUN   TestFrenchPalindrome
    word_test.go:22: IsPalindrome("été") = false
--- FAIL: TestFrenchPalindrome (0.00s)
=== RUN   TestCanalPalindrome
    word_test.go:29: IsPalindrome("A man, a plan, a canal: Panama") = false
--- FAIL: TestCanalPalindrome (0.00s)
FAIL
exit status 1
FAIL    GolangBook/chapter11/lesson2/word1      0.193s
```

А флаг `-run`, аргументом которого является регулярное выражение, приводит к тому, что команда `go test` выполняет
только те тесты, имена функций которых соответствуют шаблону:

``` shell
go test -v -run="French|Canal"
=== RUN   TestFrenchPalindrome
    word_test.go:22: IsPalindrome("été") = false
--- FAIL: TestFrenchPalindrome (0.00s)
=== RUN   TestCanalPalindrome
    word_test.go:29: IsPalindrome("A man, a plan, a canal: Panama") = false
--- FAIL: TestCanalPalindrome (0.00s)
FAIL
exit status 1
FAIL    GolangBook/chapter11/lesson2/word1      0.198s
```

Конечно, как только мы добьемся успешного прохождения выбранных тестов, мы должны пройти полный тест `go test` без
флагов, чтобы убедиться, что, исправляя одну ошибку, мы не внесли другую.

Итак, мы убедились в наличии ошибок, и теперь наша задача состоит в том, чтобы их исправить. Быстрое исследование
раскрывает причины первой ошибки: `IsPalindrome` использует последовательности байтов, а не рун, так что наличие `не-
ASCII` символов (таких, как `é` в "`été`") полностью дезориентирует эту функцию. Вторая ошибка возникает из-за того, что
мы не игнорируем пробелы, знаки пунктуации и регистр букв.

Теперь мы перепишем функцию повнимательнее (см. word2):

``` go
// Пакет word предоставляет утилиты для игр со словами
package word

import "unicode"

// IsPalindrome сообщает, является ли s палиндромом.
// Игнорируем регистр букв и символы, не являющимися буквами
func IsPalindrome(s string) bool {
	var letters []rune
	for _, r := range s {
		if unicode.IsLetter(r) {
			letters = append(letters, unicode.ToLower(r))
		}
	}
	for i := range letters {
		if letters[i] != letters[len(letters)-1-i] {
			return false
		}
	}
	return true
}
```

Мы также напишем более всеобъемлющий набор тестовых примеров, который собирает все предыдущие тестовые примеры и ряд
новых в одну таблицу:

``` go
func TestIsPalindrome(t *testing.T) {
	var tests = []struct {
		input string
		want  bool
	}{
		{"", true},
		{"a", true},
		{"aa", true},
		{"ab", false},
		{"kayak", true},
		{"detartrated", true},
		{"A man, a plan, a canal: Panama", true},
		{"Evil I did dwell; lewd did I live.", true},
		{"Able was I ere I saw Elba", true},
		{"été", true},
		{"Et se resservir, ivresse reste.", true},
		{"palindrome", false}, // Не палиндром
		{"desserts", false},   // Полупалиндром
	}

	for _, test := range tests {
		if got := IsPalindrome(test.input); got != test.want {
			t.Errorf("IsPalindrome(%q) = %v", test.input, got)
		}
	}
}
```

Новый тест функция проходит успешно:

``` shell
go test
PASS
ok      GolangBook/chapter11/lesson2/word2      0.200s
```

Этот стиль `табличного тестирования (table-driven testing)` очень распространен в Go. Он обеспечивает простой способ
добавления новых записей в таблицу при необходимости, а поскольку логика проверки и вывода сообщений не дублируется, мы
можем приложить больше усилий для получения хорошего сообщения об ошибке.

Вывод при неудачном тесте **не включает в себя весь стек в момент вызова** `t.Errorf`. Функция `t.Errorf` **не приводит
** к панике или остановке выполнения теста, в отличие от сбоев у многих средств тестирования для других языков.
**Тесты не зависят один от другого**. Если ранние записи в таблице приводят к сбою теста, более поздние записи таблицы
все равно будут проверены, так что мы можем узнать о нескольких сбоях при выполнении одного запуска теста.

Если нам действительно нужно остановить функцию тестирования, например, из-за сбоя некоторого кода инициализации или для
предотвращения сообщения об ошибках, которые вызываются другими ошибками, мы используем функции `t.Fatal` и `t.Fatalf`.
Они должны вызываться **из той же горутины, что и функция** `Test`, но не из другой горутины, созданной во время
выполнения теста.

Сообщение об ошибке в тесте, как правило, имеет вид "`f(х)=у, требуется z`", где `f(х)` объясняет, **какая операция
выполнялась и с какими входными данными**, `у` — ее **фактический результат**, a `z` — **ожидаемый**. Там, где это
удобно (как в нашем примере с палиндромом), в части `f(х)` используется синтаксис Go. Вывод `х` особенно важен в
табличных тестах, так как данная проверка выполняется несколько раз с разными значениями. Избегайте избитых выражений и
избыточной информации. Например, при проверке булевой функции, такой как `IsPalindrome`, часть "`требуется z`" можно
опустить, поскольку она не добавляет никакой информации. Если `х`, `у` или `z` **слишком длинное**, выводите краткое
резюме для соответствующих частей. Автору теста следует стремиться помочь программисту, которому придется
диагностировать ошибки.

## Выводы:

* Каждый тестовый файл в Go должен импортировать пакет `testing`; это необходимо для корректной работы инструментов
  тестирования Go;
* Имена тестовых функций должны начинаться с `Test`, и далее следует необязательный суффикс, начинающийся с прописной
  буквы; это соглашение упрощает поиск тестовых функций при использовании команды `go test`;
* Параметр `t` в тестовых функциях предоставляет **методы для сообщения о не пройденных тестах и для протоколирования
  дополнительной информации**; это помогает лучше отслеживать поведение тестов и выявлять проблемы в коде;
* `go test` используют для компиляции и выполнения тестов;
* Сначала нужно написать тест, который воспроизводит проблему, чтобы убедиться в ее наличии; это поможет быстрее
  определить и исправить источник ошибки;
* `Табличное тестирование (table-driven testing)` - хороший подход для написания тестовых примеров в Go, так как он
  позволяет легко добавлять новые записи в таблицу и избегает дублирования проверок и вывода сообщений об ошибках;
* Тесты в Go `не зависят друг от друга`; использование методов `t.Error` или `t.Errorf` не приводит к `панике`
  или `остановке выполнения теста`, что позволяет узнать о **нескольких сбоях при одном запуске теста**;
* В случае, если необходимо остановить тестирование после определенной ошибки, нужно использовать методы `t.Fatal`
  или `t.Fatalf`, но вызывать их нужно **только из той же горутины, что и функция тестирования**;
* Формат сообщений об ошибках в тестах должен быть **понятным и информативным**, включая информацию о выполняемой
  операции, фактический результат и ожидаемый результат; такой подход сэкономит время при диагностике ошибок и поможет
  быстрее исправить проблемы; 