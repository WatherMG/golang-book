# 11.2.2 Тестирование команд

Инструмент `go test` полезен для тестирования пакетов библиотек, но если приложить немного усилий, его можно
использовать и для проверки команд. Пакет с именем `main` обычно создает выполнимую программу, однако он может также
быть импортирован и как библиотека.

Давайте напишем тест для программы `echo` из раздела 2.3.2. Мы разделим программу на две функции: `echo` делает реальную
работу, в то время как функция `main` выполняет чтение и анализ значений флагов и сообщает обо всех ошибках,
возвращаемых функцией `echo`.

``` go
var (
	n = flag.Bool("n", false, "опустить символы новой строки")
	s = flag.String("s", " ", "разделитель")
)

var out io.Writer = os.Stdout // Изменяется на время тестирования

func main() {
	flag.Parse()
	if err := echo(!*n, *s, flag.Args()); err != nil {
		fmt.Fprintf(os.Stderr, "echo: %v\n", err)
		os.Exit(1)
	}
}

func echo(newline bool, sep string, args []string) error {
	fmt.Fprint(out, strings.Join(args, sep))
	if newline {
		fmt.Println(out)
	}
	return nil

}
```

Из тестовой функции мы будем вызывать `echo` с разнообразными аргументами и установками флагов и проверять, выдает ли
функция в каждом конкретном случае верный вывод. Поэтому мы добавили в функцию `echo` параметры, позволяющие уменьшить
зависимость от глобальных переменных. С учетом сказанного мы ввели также дополнительную глобальную переменную, `out`,
типа `io.Writer`, в которую **будет записываться результат**. Если функция `echo` выполняет запись через эту переменную,
а не непосредственно в `os.Stdout`, тесты могут подставить другую реализацию `Writer`, которая запоминает вывод для
последующей проверки. Вот как выглядит тест в файле `echo_test.go`:

``` go
package main

import (
	"bytes"
	"fmt"
	"testing"
)

func TestEcho(t *testing.T) {
	var tests = []struct {
		newline bool
		sep     string
		args    []string
		want    string
	}{
		{true, "", []string{}, "\n"},
		{false, "", []string{}, ""},
		{true, "\t", []string{"one", "two", "three"}, "one\ttwo\tthree\n"},
		{true, ",", []string{"a", "b", "c"}, "a,b,c\n"},
		{false, ":", []string{"1", "2", "3"}, "1:2:3"},
	}

	for _, test := range tests {
		descr := fmt.Sprintf("echo(%v, %q, %q)", test.newline, test.sep, test.args)
		out = new(bytes.Buffer) // Перехваченный вывод
		if err := echo(test.newline, test.sep, test.args); err != nil {
			t.Errorf("%s failed: %v", descr, err)
			continue
		}
		got := out.(*bytes.Buffer).String()
		if got != test.want {
			t.Errorf("%s = %q, want %q", descr, got, test.want)
		}
	}
}
```

Обратите внимание, что тестовый код находится **в том же пакете**, что и основной рабочий код. Хотя имя пакета — `main`,
и в нем определена функция `main`, при тестировании этот пакет действует, как **библиотека**, которая предоставляет
функцию `TestEcho` для тест-драйвера; его функция `main` **игнорируется**.

Организуя тест в виде таблицы, мы можем легко добавлять новые тестовые примеры. Давайте посмотрим, что произойдет, если
тест не будет пройден, просто добавив в таблицу следующую строку:

``` go
// Примечание: неверно указанное ожидание!
{true, ",", []string{"a", "b", "c"}, "a b c\n"},
```

При этом go test выводит следующее:

``` shell
=== RUN   TestEcho
    echo_test.go:34: echo(true, ",", ["a" "b" "c"]) = "a,b,c\n", want "a b c\n"
--- FAIL: TestEcho (0.00s)

FAIL
```

Сообщение об ошибке описывает **неудачную операцию** (с использованием Go-подобного синтаксиса), фактическое и ожидаемое
поведения, в указанном порядке. Такое информативное сообщение об ошибке, как приведенное выше, обеспечивает довольно
хорошее представление об основной причине проблемы даже до обращения к исходному коду теста.

Важно, что тестируемый код не вызывал `log.Fatal` или `os.Exit`, так как эти вызовы **остановят работу тестирующего
кода**; вызов этих функций следует рассматривать как исключительное право функции `main`. Если произойдет что-то
совершенно неожиданное и возникнет **аварийная ситуация**, тест-драйвер выполнит **восстановление**, хотя, конечно же,
тест **будет считаться не пройденным**. Об ожидаемых ошибках, таких как получаемые в результате неверного
пользовательского ввода, отсутствии файлов или неправильной конфигурации, следует сообщать, возвращая ненулевое значение
ошибки. К счастью (хотя и к сожалению в качестве иллюстрации), наш пример `echo` настолько прост, что он никогда не
будет возвращать ненулевую ошибку.

## Выводы:

* Пакет с именем `main` может быть импортирован как **библиотека**, что позволяет использовать его функции для
  тестирования;
* Разделение программы на две функции, одна из которых выполняет основную работу, а другая обрабатывает входные данные,
  **облегчает тестирование и делает программу более модульной**;
* Добавление параметров в функцию может уменьшить зависимость от глобальных переменных и упростить тестирование;
* Использовать `io.Writer` для записи результата функции позволяет **подставить другую реализацию во время
  тестирования**, упрощая проверку результатов работы функций;
* Тестовый код находится в том же пакете, что и основной рабочий код, что позволяет использовать функции и переменные
  пакета для тестирования;
* Создание таблицы с тестовыми данными упрощает добавление новых тестовых примеров и улучшает структуру тестового кода;
* Ошибка в тесте должна описывать **неудачную операцию, фактическое и ожидаемое поведение**, что облегчает понимание
  причины проблемы;
* Тестируемый код не должен вызывать функции, такие как `log.Fatal` или `os.Exit`, чтобы избежать непредвиденного
  завершения тестирования; сообщать об ожидаемых ошибках можно, возвращая ненулевое значение ошибки;
* В случае **паники** тест-драйвер выполнит **восстановление**, и тест будет считаться **не пройденным**.