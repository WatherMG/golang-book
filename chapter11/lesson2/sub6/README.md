# 11.2.6. Избегайте хрупких тестов

Приложение, которое часто сбоит, встречаясь с **новыми**, хотя и **допустимыми** входными данными,
называется `глючным (buggy)`; тест, который дает **ложные сбои** при внесении **корректных изменений** в программу,
называется `хрупким (brittle)`. Так же, как `глючная` программа расстраивает своих пользователей, `хрупкий тест`
раздражает программиста, сопровождающего код. Наиболее `хрупкие тесты`, которые сбоят при **почти любом изменении (
верном или неверном)** рабочего кода, иногда называют `детекторами изменений` или `тестами статус-кво`, и время, которое
приходится затрачивать на работу с ними, очень быстро сводит на нет всю выгоду, которую они, казалось бы, должны
предоставлять.

Когда тестируемая функция дает **сложный вывод**, такой как **длинная строка**, **сложная структура данных** или
**файл**, так и хочется убедиться, что результат в точности равен некоторому “золотому” значению, которое ожидалось во
время написания теста. Но по мере развития программы части выходных данных, скорее всего, будут изменяться. И это
касается не только выходных данных; функции со сложными входными данными часто дают сбои из-за того, что **используемые
в тесте входные данные больше не являются корректными**.

Самый простой способ избежать хрупких тестов — **проверять только те свойства, которые вас интересуют**. Тестируйте
более простые и стабильные интерфейсы программы вместо внутренних функций. Будьте избирательны в ваших проверках.
Например, не стоит проверять точное совпадение строк, но следует следить за важными подстроками, которые остаются
неизменными по мере развития программы. Часто имеет смысл написать большую функцию для того, чтобы извлечь из сложного
вывода саму его суть, чтобы получить возможность надежной проверки. Хотя эта работа может показаться требующей больших
усилий, она может быстро окупиться за счет экономии времени, которое в противном случае было бы затрачено на работу с
ложно срабатывающими тестами.

## Выводы:

* `Хрупкие тесты` — это тесты, которые дают **ложные сбои при внесении корректных изменений в программу**.
* Эти тесты часто называют `детекторами изменений` или `тестами статус-кво`, которые сбоят при почти любом изменении
  рабочего кода.
* Время, затраченное на работу с такими тестами, может нивелировать все преимущества, которые они предоставляют.
* `Хрупкие тесты` возникают из-за **сложных входных или выходных данных** тестируемой функции.
* По мере развития программы части выходных данных, скорее всего, будут изменяться, что может вызвать ложные
  срабатывания тестов. Это касается и сложных входных данных, которые могут перестать быть корректными.
* Чтобы избежать `хрупких тестов`, следует проверять **только нужные свойства и быть избирательным в проверках**.
* Нужно тестировать более простые и стабильные интерфейсы программы, а не внутренние функции.
* Большие функции могут быть полезными для извлечения из сложных выводов тестируемой функции самой сути вывода и более
  точной проверки. 
``` go
// TestCurrentTime проверяет точное совпадение времени, что не является
// практичным, так как время изменяется каждую секунду. Этот тест будет давать
// ложные сбои при каждом запуске.
func TestCurrentTime(t *testing.T) {
	// Хрупкий тест: проверяет точное совпадение времени
	expected := "2022-01-01 15:04:05"
	result := currentTime()

	if result != expected {
		t.Fatalf("Expected %s but got %s", expected, result)
	}
}
// TestCurrentTimeGood проверяет только формат времени, не требуя точного
// совпадения. Это делает его менее хрупким и надежным при внесении изменений
// или при повторных запусках.
func TestCurrentTimeGood(t *testing.T) {
	// Нормальный тест: проверяет только формат времени
	result := currentTime()
	_, err := time.Parse("2006-01-02 15:04:05", result)

	if err != nil {
		t.Fatalf("Time format is incorrect: %s", err)
	}
}

// currentTime() возвращает текущее время в формате строки.
func currentTime() string {
	return fmt.Sprintf(time.Now().Format("2006-01-02 15:04:05"))
} 
```