# 11.2.5. Написание эффективных тестов

Многие новички удивляются минимализму каркаса тестирования Go. Каркасы других языков обеспечивают механизмы для
идентификации тестовых функций (часто с помощью рефлексии или метаданных), перехваты для выполнения различных операций
до и после запуска тестов, библиотеки вспомогательных функций для проверки распространенных предикатов, сравнения
значений, форматирование сообщений об ошибках и прерывания не пройденных тестов (зачастую с помощью исключения). Хотя
эти механизмы могут сделать тесты очень краткими, в результате создается впечатление, что эти тесты написаны на
совершенно ином языке. Кроме того, хотя они могут корректно сообщать о том, пройден ли тест, их сообщения могут быть
весьма загадочными, с сообщениями вида "`assert: 0 == 1`" или многостраничными трассировками стека.

Отношение Go к тестированию представляет разительный контраст. Он ожидает от авторов тестов, что они сами сделают
большую часть работы, так же как и при разработке обычных программ. Процесс тестирования не является сугубо
механическим действом; тест также имеет пользовательский интерфейс, хотя и предназначенный только для тех, кто
занимается сопровождением программы. Хороший тест выводит **четкое и сжатое описание симптомов проблемы** и, возможно
**некоторую другую информацию о контексте**, в котором произошел сбой. В идеале программисту не требуется читать
исходный текст, чтобы расшифровать сообщения теста. Хороший тест **не должен завершаться после первого же сбоя**; он
должен попытаться представить за один проход **несколько ошибок**, поскольку общая картина сбоев может помочь выявлению
проблемы.

Приведенная ниже функция сравнивает два значения, создает обобщенное сообщение об ошибке и останавливает программу. Это
просто в использовании и корректно, но сообщение об ошибке при сбое практически бесполезно. Данная функция не решает
сложную проблему предоставления хорошего пользовательского интерфейса:

``` go
import (
	"fmt"
	"strings"
	"testing"
)

// Плохая функция
func assertEqual(x, y int) {
	if x != y {
		panic(fmt.Sprintf("%d != %d", x, y))
	}
}

func TestSplit(t *testing.T) {
	words := strings.Split("a:b:c", ":")
	assertEqual(len(words), 3)
	// ...
}
```

В определенном смысле приведенная функция страдает от `преждевременной абстракции`: рассматривая отказ этого конкретного
теста как простое различие двух целых чисел, мы теряем возможность получения значащего контекста. Можно предоставить
сообщение и получше, с конкретной информацией, как показано в примере ниже. Время для ввода абстракций наступает только
после того, как в данном тесте наблюдается один и тот же повторяющийся шаблон ошибки:

``` go
func TestSplitv2(t *testing.T) {
	s, sep := "a:b:c", ":"
	words := strings.Split(s, sep)
	if got, want := len(words), 3; got != want {
		t.Errorf("Split(%q, %q) возвращает %d слов, а требуется %d", s, sep, got, want)
	}
}
```

Теперь тест сообщает о том, какая функция вызывалась, ее входные данные и результаты — тест явно указывает фактическое и
ожидаемое значения результата. Тест продолжает выполняться, даже если проверка указывает на наличие сбоя. После того как
мы написали тест наподобие рассматриваемого, естественный следующий шаг зачастую состоит не в том, чтобы определить
функцию, заменяющую всю конструкцию `if`, а в том, чтобы выполнить тест в цикле, в котором варьируются
значения `s`, `sep` и `want`, как в табличном тесте функции `IsPalindrome`.

Предыдущий пример не нуждается в каких-либо служебных функциях, но, конечно, это не должно удерживать нас от добавления
функций, если они помогают упростить код. (Мы рассмотрим одну такую вспомогательную функцию, `reflect.DeepEqual`, в
разделе 13.3.) Ключ к хорошему тесту — начать с реализации конкретного необходимого вам поведения и лишь затем
использовать функции для упрощения кода и устранения повторений. Если начинать с библиотеки абстрактных, обобщенных
тестовых функций, наилучшие результаты получаются редко.

## Выводы:

* Хороший тест должен предоставлять четкое и сжатое описание симптомов проблемы и, возможно, информацию о контексте, в
  котором произошел сбой; это помогает разработчикам быстрее идентифицировать и исправить ошибки;
* Вместо использования абстрактных вспомогательных функций в тестах, стоит начать с реализации конкретного требуемого
  поведения и добавлять функции для упрощения кода и избавления от повторений только после этого;
* Хороший тест должен продолжать выполняться, даже если проверка указывает на наличие сбоя, чтобы предоставить
  разработчикам общую картину сбоев и помочь выявлению проблемы;
* Табличный подход к тестированию, при котором тест выполняется в цикле с разными входными данными, может быть полезен
  для проверки функций с множеством вариантов;
* При написании тестов на языке Go нужно уделять особое внимание предоставлению информативных сообщений об ошибках,
  которые помогут разработчикам быстрее и точнее идентифицировать и исправить проблемы.