# 11.2.3. Тестирование белого ящика

Одним из способов классификации тестов является **уровень требующихся им знаний о внутренней работе тестируемого
пакета**. **Тестирование черного ящика** предполагает, что о пакете **неизвестно ничего, кроме предоставляемого им API и
указанной в документации информации**; внутренние компоненты пакета являются полностью непрозрачными. Напротив,
**тестирование белого ящика** имеет привилегированный доступ к внутреннему устройству функций и структур данных пакета и
может делать наблюдения и изменения, на которые не способен обычный клиент. Например, тест белого ящика **может
проверить, сохраняются ли инварианты типов данных пакета после каждой операции**. (Название белый ящик используется по
традиции, но куда точнее было бы название `прозрачный ящик`.)

Эти два подхода являются `взаимодополняющими`. **Тесты черного ящика** обычно **более надежны** и требуют **меньшего
количества обновлений** по мере развития тестируемого программного обеспечения. Они также помогают автору теста
проникнуться ощущениями клиента пакета, что облегчает выявление недостатков в дизайне API. Тестирование же **белого
ящика** может обеспечить **более детальный охват сложных частей реализации**.

Мы уже видели примеры обоих типов. `TestlsPalindrome` вызывает только экспортируемую функцию `IsPalindrome` и, таким
образом, является **тестированием черного ящика**. `TestEcho` вызывает функцию `echo` и обновляет глобальную
переменную `out`, причем они обе **не являются экспортируемыми**, что делает данный тест **тестом белого ящика**.

При разработке `TestEcho` мы изменили функцию `echo` так, чтобы она использовала для вывода **переменную уровня пакета
** `out` и тест мог заменить стандартный вывод альтернативной реализацией, которая записывает выводимые данные для
последующего изучения. Используя ту же методику, мы можем заменить и другие части рабочего кода легко тестируемыми
“поддельными” реализациями. Преимуществом таких поддельных реализаций является то, **что они проще настраиваются, более
предсказуемы, более надежны и проще в изучении**. Они также могут избежать нежелательных побочных эффектов, таких как
обновления рабочей базы данных или операций с кредитной картой.
В приведенном ниже коде показана логика проверки квот в веб-службе, которая обеспечивает сетевое хранилище
пользовательских файлов. Когда пользователи превышают 90% от их квоты, система отправляет им предупреждение по
электронной почте (см. storage1).

``` go
package storage

import (
	"fmt"
	"log"
	"net/smtp"
)

func bytesInUse(username string) int64 { return 0 /* ... */}


// Настройка отправителя электронных писем.
// Примечание: никогда не помещайте пароль в исходный текст!

const (
	sender = "notifications@example.com"
	password = "correcthorsebatterystaple"
	hostname = "smtp.example.com"
	template = `Внимание, вы использовани %d байт хранилища, %d%% вашей квоты.`
)

func CheckQuota(username string) {
	used := bytesInUse(username)
	const quota = 1000000000 // 1GB
	percent := 100 * used / quota
	if percent < 90 {
		return // OK
	}
	msg := fmt.Sprintf(template, used, percent)
	auth := smtp.PlainAuth("", sender, password, hostname)
	err := smtp.SendMail(hostname+":587", auth, sender, []string{username}, []byte(msg))
	if err != nil {
		log.Printf("Сбой smtp.SendMail(%s): %s", username, err)
	}
}
```

Мы хотели бы протестировать этот код, но мы не хотим тестировать отправку электронной почты. Поэтому мы перемещаем
логику отправления электронной почты в отдельную функцию и храним ее в неэкспортируемой переменной уровня пакета,
`notifyUser` (см. storage2):

``` go
var notifyUser = func(username string, msg string) {
	auth := smtp.PlainAuth("", sender, password, hostname)
	err := smtp.SendMail(hostname+":587", auth, sender, []string{username}, []byte(msg))
	if err != nil {
		log.Printf("Сбой smtp.SendMail(%s): %s", username, err)
	}
}

func CheckQuota(username string) {
	used := bytesInUse(username)
	const quota = 1000000000 // 1GB
	percent := 100 * used / quota
	if percent < 90 {
		return // OK
	}
	msg := fmt.Sprintf(template, used, percent)
	notifyUser(username, msg)
}
```

Теперь мы можем написать тест, который заменяет отправление электронной почты функцией простого уведомления, которая
просто регистрирует уведомляемого пользователя и содержимое сообщения (см. storage_test):

``` go
package storage

import (
	"strings"
	"testing"
)

func TestCheckQuotaNotifiesUser(t *testing.T) {
	var notifiedUser, notifiedMsg string
	notifyUser = func(username string, msg string) {
		notifiedUser, notifiedMsg = username, msg
	}
	// ... имитация условия 980-Мбайтной занятости ...
	const user = "joe@example.org"
	CheckQuota(user)
	if notifiedUser == "" && notifiedMsg == "" {
		t.Fatalf("notifyUser not called")
	}
	if notifiedUser != user {
		t.Errorf("Уведомлен (%s) вместо %s", notifiedUser, user)
	}
	const wantSubString = "98% of your quota"
	if strings.Contains(notifiedMsg, wantSubString) {
		t.Errorf("Неожиданное уведомление <<%s>>, ожидаемое: %q", notifiedMsg, wantSubString)
	}
}
```

Имеется одна проблема: после возврата из тестовой функции `CheckQuota` больше не работает так, как надо, потому что все
еще использует поддельную тестовую реализацию `notifyUsers`. (При обновлении глобальных переменных всегда имеется риск
такого рода.) Мы должны изменить тест, чтобы он восстанавливал предыдущее значение так, **чтобы последующие тесты не
наблюдали никакой замены**, и должны сделать это на всех путях выполнения, включая сбои и аварийные ситуации в тестах.
Это естественным образом приводит к применению `defer`.

``` go
func TestCheckQuotaNotifiesUser(t *testing.T) {
	// Сохранение и восстановление исходного значения notifiesUser.
	saved := notifyUser
	defer func() { notifyUser = saved }()

	// Установка поддельной функции для notifyUser.
	var notifiedUser, notifiedMsg string
	// ... Остальная часть кода
}
```

Этот шаблон может использоваться для **временного сохранения** и **восстановления** глобальных переменных всех видов,
включая флаги командной строки, параметры отладки и параметры производительности; для установки и удаления
перехватчиков, которые заставляют рабочий код вызывать некоторый тестовый код, когда происходит что-то интересное; а
также при таких редких, но важных ситуациях, как тайм-ауты, ошибки и даже конкретные чередования параллельных действий.
Использование глобальных переменных таким образом является безопасным только потому, что `go test` обычно **не запускает
несколько тестов одновременно**.

## Выводы:

* **Тестирование черного ящика** подразумевает, что доступна **только** информация о предоставляемом API и документации,
  а внутренние компоненты пакета закрыты от взгляда (непрозрачны). Этот подход позволяет тестировать пакеты без знания
  их внутренней структуры, что делает его более универсальным и применимым к различным пакетам;
* **Тестирование белого ящика** - подход к тестированию, при котором тест **имеет привилегированный доступ к внутренним
  компонентам и структурам данных пакета**;
* Тестирование белого ящика **дополняет** тестирование черного ящика, обеспечивая **более детальное покрытие сложных
  частей реализации**;
* В Go тесты **белого ящика** могут проверять **инварианты типов данных пакета** и иметь доступ к **неэкспортируемым
  функциям** и **переменным**;
* Можно заменять части рабочего кода на легко тестируемые "поддельные"
  реализации (`var notifyUser = func(username string, msg string) {/*...*/}`), которые проще настраивать, более
  предсказуемы, надежны и изучаемы;
* В Go для **временного сохранения** и **восстановления глобальных переменных** можно использовать `defer`;
* Использование глобальных переменных безопасно при тестировании, так как `go test` обычно **не запускает несколько тестов
  одновременно**;
* Тестирование белого ящика в Go позволяет лучше понять и контролировать поведение внутренних компонентов программы и
  улучшить степень покрытия тестами различных случаев использования.