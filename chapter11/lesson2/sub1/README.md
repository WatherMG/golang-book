# 11.2.1. Рандомизированное тестирование

Табличные тесты удобны для проверки, корректно ли функция работает с тщательно отобранными для проверки интересных
случаев в логике функции входными данными. Другой подход, `рандомизированное тестирование`, исследует более широкий
спектр входных данных **путем их создания случайным образом**.

Но как нам узнать, какой выход следует ожидать от нашей функции, учитывая случайность входа? Имеются две стратегии.
Первая заключается в том, чтобы написать альтернативную реализацию функции, которая **использует менее эффективный, но
более простой и ясный алгоритм, и проверить, дают ли обе реализации один и тот же результат**. Второй заключается в
**создании входных значений согласно некоторому шаблону, такому, для которого мы знаем, какой выход следует ожидать**.

В приведенном ниже примере используется **второй подход**: функция `randomPalindrome` генерирует слова, которые являются
палиндромами исходя из самого принципа их построения:

``` go
// randomPalindrome возвращает палиндром, длина и содержимое
// которого задаются генератором псевдослучайных чисел rng.
func randomPalindrome(rng *rand.Rand) string {
	n := rng.Intn(25) // Случайная длина до 24
	runes := make([]rune, n)
	for i := 0; i < (n+1)/2; i++ {
		r := rune(rng.Intn(0x1000)) // Случайная руна до `\u0999`
		runes[i] = r
		runes[n-1-i] = r
	}
	return string(runes)
}

func TestRandomPalindrome(t *testing.T) {
	// Инициализация генератора псевдослучайных чисел.
	seed := time.Now().UTC().UnixNano()
	t.Logf("ГПСЧ инициализирован: %d", seed)
	rng := rand.New(rand.NewSource(seed))
	for i := 0; i < 1000; i++ {
		p := randomPalindrome(rng)
		if !IsPalindrome(p) {
			t.Errorf("IsPalindrome(%q) = false", p)
		}
	}
}
```

Поскольку рандомизированные тесты являются `недетерминированными`, важно, чтобы при записи о сбоях в журнал выводилось
достаточно информации, чтобы можно было воспроизвести этот сбой. В нашем примере входной параметр `р` для функции
`IsPalindrome` дает нам всю необходимую информацию, но для функций, которые принимают более сложные входные данные,
может быть проще записывать инициализирующее значение генератора псевдослучайных чисел (как сделано выше), чем дамп всех
входных данных. Вооружившись этим инициализирующим значением, можно легко изменить тест так, чтобы `детерминированно`
воспроизвести сбои.

Используя в качестве источника случайности текущее время, мы обеспечиваем тест новым набором входных данных при каждом
очередном запуске в течение всего его жизненного цикла. Это особенно ценно, если ваш проект использует
автоматизированную систему для периодического запуска всех тестов.