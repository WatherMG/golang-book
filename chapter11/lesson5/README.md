# 11.5. Профилирование

Контрольные показатели полезны для измерения производительности конкретных операций, но когда мы пытаемся сделать
медленную программу более быстрой, у нас зачастую нет никаких идей, с чего начать. Каждый программист знает афоризм
Дональда Кнута (Donald Knuth) о преждевременной оптимизации, который появился в его
работе “`Структурное программирование с инструкцией goto`” в 1974 году. Хотя его часто неверно воспринимают как
указание, что производительность не имеет значения, в его исходном контексте мы можем разглядеть другой смысл.

Не существует никаких сомнений в том, что Грааль эффективности приводит к злоупотреблениям. Программисты тратят огромное
количество времени, размышляя или беспокоясь о скорости некритических частей их программ, и эти попытки достичь
эффективности на самом деле оказывают сильное отрицательное воздействие на отладку и обслуживание. Мы **должны** забыть
о малой эффективности, скажем, примерно на 97% времени: **преждевременная оптимизация является корнем всех зол**.

Однако мы не должны пренебрегать нашими возможностями в рамках критических 3%. Хороший программист не будет самоуспокоен
такими рассуждениями. Он будет достаточно мудрым, чтобы внимательно рассмотреть критический код, но только **после**
того, как этот код будет обнаружен. Серьезная ошибка программистов заключается в априорных суждениях о том, какие части
программы действительно критические, поскольку опыт применения инструментов измерения производительности слишком часто
противоречит интуитивным догадкам.

Если мы хотим внимательно рассмотреть скорость своих программ, наилучший метод для определения критического кода —
`профилирование`. `Профилирование` представляет собой **автоматизированный подход к измерению производительности на
основе выборки ряда событий во время выполнения с последующей их экстраполяцией во время последующей обработки**.
Получаемая в результате статистическая сводка называется `профилем`.

Go поддерживает многие виды профилирования, касающиеся различных аспектов производительности, но все они включают запись
последовательности интересующих событий, каждое из которых сопровождается трассировкой стека — списком функций, вызовы
которых активны в момент события. Инструмент `go test` имеет встроенную поддержку нескольких видов профилирования.

`Профиль процессора` идентифицирует функции, выполнение которых требует больше всего `процессорного времени`. Текущий
выполняющийся на каждом процессоре поток **периодически прерывается операционной системой каждые несколько
миллисекунд**, и при каждом прерывании **перед** возобновлением нормальной работы **выполняется запись одного события
профилирования**.

`Профиль памяти` определяет инструкции, ответственные за **выделение наибольшего количества памяти**. Выборки библиотеки
профилирования вызывают внутренние процедуры выделения памяти так, что в среднем одно событие профиля записывается для
каждых `512 Кбайт` выделенной памяти.

`Профиль блокировок` выявляет операции, ответственные за н`айдлиннейшее блокирование горутин`, такие, как **системные
вызовы**, **операции отправления и получения канала** и **захват блокировок**. Библиотека профилирования записывает
событие **каждый раз**, когда горутина блокируется одной из этих операций.

Выполнить сбор информации профилей для тестируемого кода очень легко, включив один из перечисленных ниже флагов. Однако
будьте осторожны при использовании **более чем одного флага одновременно**: _сбор информации для одной разновидности
профиля может исказить результаты для других_.

``` shell
$ go test -cpuprofile='cpu.out' 
$ go test -blockprofile='block.out'
$ go test -memprofile='mem.out'
```

Легко добавить поддержку профилирования и в не тестируемые программы, хотя детальная информации о том, как это делается,
выглядит по-разному в зависимости от того, чем является приложение — коротким инструментом командной строки или
длительно работающим серверным приложением. Профилирование особенно полезно **в длительно работающих приложения**х,
поэтому возможности профилирования **времени выполнения** Go можно включать под контролем программиста с
помощью `API runtime`.

Собрав нужную информацию, необходимо проанализировать ее с помощью инструмента `pprof`. Это стандартная часть
дистрибутива Go, но поскольку это инструмент не повседневного использования, доступ к нему осуществляется косвенно с
помощью команды `go tool pprof`. Он имеет множество возможностей и ключей, но в основном требуются только два
аргумента — **выполнимый файл**, который создал профиль, и **журнал профиля**.

Чтобы сделать профилирование эффективным и сэкономить память, в журнал не включаются имена функций. Вместо этого функции
идентифицируются по их адресам. Это значит, что для того, чтобы записи в журнале стали осмысленными, инструменту `pprof`
необходим **выполнимый файл**. Хотя `go test` обычно уничтожает выполнимый файл после завершения теста, в случае
профилирования выполнимый файл сохраняется как `fоо.test`, где `fоо` — это **имя тестируемого пакета**.

Приведенные ниже команды показывают, как выполнить сбор и отображение для простого профиля процессора. Мы выбрали одну
из функций производительности пакета `net/http`. Обычно лучше профилировать конкретные функции, которые были специально
созданы таким образом, чтобы быть репрезентативными для нагрузки, с которой придется иметь дело рабочей программе.
Сравнительный анализ тестовых случаев почти никогда не является репрезентативным, и именно поэтому мы отключаем их с
помощью фильтра `-run=NONE` (Пример из книги. Для версии Go 1.20.3 не удалось его запустить по причине отсутствия в
библиотеке Go).

``` shell
$ go test -run=N0NE -bench=ClientServerParallelTLS64 \
-cpuprofile=cpu.log net/http
PASS
BenchmarkClientServerParallelTLS64-8 1000
3141325 ns/op 143010 B/op 1747 allocs/op ok net/http 3.395s
$ go tool pprof -text -nodecount=10 ./http.test cpu.log 2570ms of 3590ms total (71.59%)
Dropped 129 nodes (cum <= 17.95ms)
Showing top 10 nodes out of 166 (cum >= 60ms) 
	flat  flat%   sum%    cum   cum%
  1730ms 48.19% 48.19% 1750ms 48.75% crypto/elliptic.p256ReduceDegree 
   230ms  6.41% 54.60%  250ms  6.96% crypto/elliptic.p256Diff 
   120ms  3.34% 57.94%  120ms  3.34% math/big.addMulWW 
   110ms  3.06% 61.00%  110ms  3.06% syscall.Syscall 
    90ms  2.51% 63.51% 1130ms 31.48% crypto/elliptic.p256Square 
    70ms  1.95% 65.46%  120ms  3.34% runtime.scanobject 
    60ms  1.67% 67.13%  830ms 23.12% crypto/elliptic.p256Mul 
    60ms  1.67% 68.80%  190ms  5.29% math/big.nat.montgomery 
    50ms  1.39% 70.19%   50ms  1.39% crypto/elliptic.p256ReduceCarry 
    50ms  1.39% 71.59%   60ms  1.67% crypto/elliptic.p256Sum
```

Флаг `-text` указывает формат вывода, в данном случае — в виде текстовой таблицы с одной строкой на каждую функцию,
отсортированную в порядке “`горячести`” функций, — те, которые потребляют больше процессорного времени, идут первыми.
Флаг `-nodecount=10` ограничивает результат десятью строками. Для выяснения причин больших проблем производительности
этого текстового формата должно быть достаточно.

Этот профиль говорит нам о том, что криптография на основе эллиптических кривых имеет важное значение для выполнения
этой конкретной проверки производительности HTTPS. Напротив, если в профиле доминируют функции выделения памяти из
пакета `runtime`, наилучшей оптимизацией может оказаться сокращение потребления памяти.

Для более тонких проблем, может быть, лучше воспользоваться одним из графических выводов `pprof`. Они требуют
пакета `GraphViz`, который может быть загружен с сайта по адресу www.graphviz.org. Флаг `-web` выводит ориентированный
граф функций программы, аннотированный их используемым процессорным временем и цветом для указания “горячих” функций.

Здесь мы только бегло ознакомились с инструментами профилирования. Чтобы получить больше информации, обратитесь к статье
Profiling Go Programs в блоге Go Blog.

## Выводы:

* Преждевременная оптимизация является **корнем всех зол**: программисты тратят слишком много времени на оптимизацию
  некритических частей кода, что вредит отладке и поддержке программ.
* Критический код следует оптимизировать **только после его обнаружения**, а не априорно, поскольку интуитивные оценки
  часто оказываются неверными;
* `Профилирование` - наилучший способ определения критического кода: это **автоматизированный подход к измерению
  производительности, основанный на сборе статистики событий во время выполнения программы и анализе полученных
  данных**;
* Go поддерживает множество видов профилирования, включая `профиль процессора`, `профиль памяти` и
  `профиль блокировок`, позволяя определять различные аспекты производительности кода;
* `Профиль процессора` **идентифицирует функции, запрашивающие наибольшее процессорное время**, записывая события при
  `прерываниях`, вызванных операционной системой;
* `Профиль памяти` определяет операции, **ответственные за выделение наибольшего количества памяти**, и опирается на
  события, записываемые для каждых `512 Кбайт` выделенной памяти;
* `Профиль блокировок` позволяет выявлять операции, **вызывающие самые длительные блокировки горутин**, такие, как
  `системные вызовы`, `операции с каналами` и `захват блокировок`;
* Для сбора информации профилей в Go используется инструмент `go test` с соответствующими флагами, однако **следует
  избегать использования нескольких типов профилирования одновременно**, так как это может исказить результаты;
* Использование профилирования в Go позволяет оптимизировать критические части кода, улучшая производительность и
  качество разработанных программ;
* Профилирование полезно для длительно работающих приложений и может быть включено в программе с помощью `API runtime`;
* Инструмент `pprof` используется для анализа собранной информации о профилировании, он является стандартной частью
  дистрибутива Go и вызывается с помощью команды `go tool pprof`;
* Для анализа данных с помощью `pprof` требуются два аргумента: `выполняемый файл`, который создал профиль, и `журнал
  профиля`;
* Имена функций **не включены в журнал профилирования для экономии памяти**, вместо этого функции идентифицируются по
  адресам, поэтому **выполнимый файл требуется для корректного анализа данных**;
* Во время профилирования, `go test` сохраняет выполняемый файл как `fоо.test`, где `fоо` — имя тестируемого пакета;
* Рекомендуется профилировать конкретные функции, которые репрезентативны для нагрузки рабочей программы, используя флаг
  `-run=NONE` для отключения сравнительного анализа тестовых случаев;
* Флаг `-text` отображает текстовую таблицу профилирования с отсортированными функциями в порядке их "горячести", таким
  образом, упрощая выявление проблем производительности;
* Флаг `-nodecount=10` ограничивает вывод результатов профилирования до 10 строк для упрощения анализа;
* Для более тонкого анализа проблем могут использоваться графические выводы `pprof`, требующие установки
  пакета `GraphViz` и использования флага `-web`, который создает аннотированный граф функций программы.