# 10.5 Пустой импорт

Нельзя импортировать пакет в файл, но при этом нигде в этом файле не сослаться на имя, которое он определяет. Это
рассматривается **как ошибка**. Однако иногда необходимо импортировать пакет просто для побочных эффектов — вычисления
инициализирующих выражений его переменных уровня пакета и выполнения функций `init` (раздел 2.6.2). Чтобы подавить
ошибку "неиспользуемый импорт", с которой мы в противном случае столкнемся, следует использовать переименование импорта
с
альтернативным названием `_ (пустой идентификатор)`. Как обычно, на пустой идентификатор можно **никогда не ссылаться**.

``` go
import _ "image/png" // Регистрация декодировщика PNG
```

Это действие известно как `пустой импорт`. Наиболее часто пустой импорт используется для реализации механизма времени
компиляции, согласно которому основная программа может включать необязательные возможности с помощью пустого импорта
дополнительных пакетов. Сначала мы посмотрим, как его использовать, а затем — как он работает.

Пакет стандартной библиотеки `image` экспортирует функцию `Decode`, которая считывает байты из `io.Reader`, определяет,
какой формат изображения использован для кодирования данных, вызывает соответствующий декодер и возвращает
результирующее значение `image.Image`. Используя `image.Decode`, легко создать простой преобразователь изображений,
который считывает изображение в одном формате и записывает в другом (см. `jpeg`):

``` go
import (
	"fmt"
	"image"
	"image/jpeg"
	_ "image/png"
	"io"
	"os"
)

// Команда jpeg считывает изображение PNG со стандартного ввода
// и записывает его как изображение JPEG на стандартный вывод.
func main() {
	if err := toJPEG(os.Stdin, os.Stdout); err != nil {
		fmt.Fprintf(os.Stderr, "jpeg: %v\n", err)
		os.Exit(1)
	}
}

func toJPEG(in io.Reader, out io.Writer) error {
	img, kind, err := image.Decode(in)
	if err != nil {
		return err
	}
	fmt.Fprintln(os.Stderr, "Входной формат =", kind)
	return jpeg.Encode(out, img, &jpeg.Options{Quality: 95})
}
```

Если мы передадим выход программы `/ch3/mandelbrot` (раздел 3.3) программе преобразования, она обнаружит входной
формат `PNG` и запишет `JPEG-версию` рис.3.3.

``` shell
$ go build gopl.io/ch3/mandelbrot 
$ go build gopl.io/chl0/jpeg 
$ ./mandelbrot | ./jpeg > mandelbrot.jpg 
Входной формат = png
```

Обратите внимание на пустой импорт `image/png`. Без этой строки программа будет компилироваться и компоноваться, как
обычно, но может **не распознавать или декодировать ввод в формате PNG**:

``` shell
$ go build gopl.io/chl0/jpeg 
$ ./mandelbrot | ./jpeg >mandelbrot.jpg 
jpeg: image: неизвестный формат
```

Вот как это работает. Стандартная библиотека предоставляет декодеры для `GIF`, `PNG` и `JPEG`, а пользователи могут
предоставлять и другие. Но чтобы выполнимые файлы были небольшими, **декодеры не включаются в приложение**, если это
явно не потребовать. Функция `image.Decode` консультируется с таблицей поддерживаемых форматов. Каждая запись в таблице
указывает четыре вещи: `имя формата`; `строку`, которая представляет собой `префикс всех изображений`, закодированных
таким образом, и `используется для определения кодировки`; функцию `Decode`, которая **декодирует изображения**; и еще
одну функцию `DecodeConfig`, которая декодирует только метаданные изображения, например его размер и цветовое
пространство. Запись добавляется в таблицу путем вызова `image.RegisterFormat`, обычно из инициализатора пакета
поддержки каждого формата, как в пакете `image/png`:

``` go
package png // image/png
func Decode(r io.Reader) (image.Image, error) 
func DecodeConfig(r io.Reader) (image.Config, error)

func init() {
const pngHeader = "\x89PNG\r\n\x1a\nM
image.RegisterFormat("png", pngHeader, Decode, DecodeConfig)
}
```

Чтобы функция `image.Decode` была в состоянии декодировать данный формат, приложению требуется **только пустой импорт
пакета для регистрации формата**.

Пакет `database/sql` использует аналогичный механизм для того, чтобы позволить пользователям установить только те
драйверы баз данных, в которых они нуждаются, например:

``` go
import (
	"database/sql"
	__ "github.com/lib/pq" // enable support for Postgres
	_ "github.com/gosqldriver/mysql" // enable support for MySQL
)

db, err = sql.Open("postgres", dbname) // OK 
db, err = sql.Open("mysql", dbname) // OK 
db, err = sql.0pen("sqlite3", dbname) // Возврат ошибки: неизвестный драйвер "sqlite3"
```

## Выводы:

* Пустой импорт используется только для запуска кода, который **не возвращает какие-либо значения**, например, для
  инициализации переменных и функций (`init()`).
* Для подавления ошибки "неиспользуемый импорт" используется переименование импорта с альтернативным
  названием `_ (пустой идентификатор)`;
* `Пустой импорт` применяется при реализации механизма **времени компиляции**, позволяющем основной программе включать
  необязательные возможности с помощью пустого импорта дополнительных пакетов (например, декодеры изображений);
* Пример использования пустого импорта - подключение декодировщика PNG: `import _ "image/png"`, после чего функция
  `image.Decode` сможет распознавать и обрабатывать изображения в данном формате;
* Работа со стандартной библиотекой `image` и пустыми импортами позволяет легко создавать преобразователи изображений,
  которые считывают изображение в одном формате и записывают его в другом;
* Без пустого импорта необходимого формата выполнимый файл будет компилироваться и компоноваться, однако функция
  `image.Decode` **не сможет распознать данный формат и выдаст ошибку**;
* Аналогичный механизм с пустыми импортами используется в пакете `database/sql` для установки только тех драйверов баз
  данных, в которых пользователь нуждается, например, для поддержки `PostgreSQL` или `MySQL`;
* Преимущества использования пустых импортов включают **меньший размер выполняемого файла** (за счет исключения
  неиспользуемых функций), **гибкость** и **возможность расширения функционала приложения** при необходимости.