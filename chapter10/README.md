# 10. Пакеты и инструменты Go

Сегодня программа скромного размера может содержать десятки тысяч функций. Тем не менее ее автору нужно думать лишь о
некоторых из них, а разрабатывать — и того меньше, потому что подавляющее большинство функций написано другими
программистами и доступно для повторного использования в виде пакетов.

Go поставляется более чем с сотней стандартных пакетов, которые обеспечивают основу для большинства приложений. Куда
больше пакетов, разработанных всем сообществом программистов Go, можно найти по адресу http://godoc.org. В этой главе мы
покажем, как использовать существующие пакеты и создавать новые.

Go также поставляется с инструментом `go`, сложным, но простым в использовании, который представляет собой команду, в
том числе для управления пакетами Go. В начале книги мы показали, как использовать `go` для того, чтобы скачать,
построить и запустить примеры программ. В этой главе рассмотрены основные концепции, лежащие в основе этого инструмента,
и подробно изложены его возможности, которые включают вывод документации и запрос метаданных о пакетах в рабочей
области. В следующей главе мы будем изучать его возможности тестирования.

<!-- TOC -->

* [10.1. Введение](#101-введение)
* [10.2. Пути импорта](#102-пути-импорта)
* [10.3. Объявление пакета](#103-объявление-пакета)
* [10.4. Объявления импорта](#104-объявления-импорта)
* [10.5. Пустой импорт](#105-пустой-импорт)
* [10.6. Пакеты и именование](#106-пакеты-и-именование)
* [10.7. Инструментарий Go](#107-инструментарий-go)
	* [10.7.1 Организация рабочего пространства](#1071-организация-рабочего-пространства)
	* [10.7.2 Загрузка пакетов](#1072-загрузка-пакетов)
	* [10.7.3 Построение пакетов](#1073-построение-пакетов)
	* [10.7.4 Документирование пакетов](#1074-документирование-пакетов)
	* [10.7.5 Внутренние пакеты](#1075-внутренние-пакеты)
	* [10.7.6 Запрашиваемые пакеты](#1076-запрашиваемые-пакеты)

<!-- TOC -->

____

# 10.1. Введение

* `Системы пакетов` облегчают разработку и поддержку больших программ путем **группировки связанных функций в модули**,
  что делает их легче понимать и изменять независимо друг от друга;
* `Модульность` позволяет **использовать пакеты совместно в разных проектах**, они могут быть **распространены внутри
  организации или доступны всему миру**;
* `Пакеты` **определяют уникальное пространство имен для всех своих идентификаторов**, что избегает конфликтов имен в
  разных частях программы;
* `Инкапсуляция пакетов` управляет **видимостью имен и позволяет скрыть вспомогательные функции и типы за API пакета**,
  облегчая его разработку и поддержку;
* `Ограничение видимости переменных пакета` заставляет пользователей обращаться к ним **только через экспортированные
  функции**, что обеспечивает сохранение внутренних инвариантов и взаимоисключение в параллельных программах;
* При изменении файла в пакете, **необходимо перекомпилировать его и все зависимые пакеты**;
* Компиляция Go быстрая благодаря трём основным причинам: `явное указание импортируемых пакетов`, `отсутствие циклов в
  зависимостях` и `использование объектных файлов с экспортируемой информацией для всех зависимостей`.

____

# 10.2. Пути импорта

* Пути импорта в Go идентифицируют пакеты и используются в объявлениях `import`;
* Спецификация языка Go **не определяет смысл** и правила нахождения путей импорта, поэтому разные инструменты могут
  иметь свои соглашения; наиболее распространенным инструментом является `go`, который определяет стандартные правила
  для большинства программистов Go;
* Для пакетов, предназначенных для совместного использования или публикации, **пути импорта должны быть глобально
  уникальными**; это предотвращает конфликты и способствует легкому нахождению и использованию пакетов;
* Пути импорта пакетов, не входящих в стандартную библиотеку, должны начинаться с **доменного имени
  организации-владельца**; это делает пути импорта более понятными и способствует их уникальности;
* В объявлениях `import` можно использовать пути импорта как стандартных библиотек (например, `"fmt"`, `"math/rand"`),
  так и сторонних пакетов (например, `"golang.org/x/net/html"`, `"github.com/gosqldriver/mysql"`);
* Использование путей импорта соответствующим образом упрощает подключение и использование различных пакетов, что
  способствует ускорению разработки и улучшению качества кода на языке Golang.

____

# 10.3. Объявление пакета

* Объявление `package` определяет **идентификатор по умолчанию** для пакета при его импорте в другой пакет; это
  позволяет упростить обращение к членам пакета через идентификатор, например, `rand.Int` для пакета `math/rand`;
* Имя пакета по соглашению `является последней частью пути импорта`, что позволяет иметь разные пакеты с одинаковыми
  именами, но разными путями импорта, упрощая их использование;
* Пакет с именем `main` определяет команду `(выполнимую программу Go)`, что сигнализирует инструментам Go о
  необходимости создания исполняемого файла;
* Файлы с суффиксом `_test` в имени пакета определяют **пакеты для внешнего тестирования**, что позволяет избежать
  циклов в графе импорта и облегчает тестирование кода;
* `Инструменты управления зависимостями` могут добавить `суффикс с номером версии в путь импорта пакета`, и этот суффикс
  **следует исключать из имени пакета** для упрощения использования.

____

# 10.4. Объявления импорта

* Исходный файл Go может содержать **нуль или более объявлений импорта** после объявления `package`; это позволяет
  загружать код из других пакетов и использовать его в текущем файле;
* Объявления импорта могут быть **сгруппированы** с помощью добавления пустых строк для указания различных предметных
  областей; это облегчает чтение кода;
* Импортированные пакеты могут использовать `альтернативные имена`, чтобы избегать конфликтов с именами других пакетов
  или локальных переменных;
* Альтернативное имя влияет **только на импортирующий файл**, что обеспечивает гибкость при импорте пакетов;
* Пример импорта с использованием альтернативного имени:
  ``` go
  import (
      "crypto/rand"
      mrand "math/rand" // Альтернативное имя mrand устраняет конфликт
  )
  ```
* При наличии громоздких имен пакетов, использование альтернативных имен может облегчить чтение кода;
* Инструмент `go build` проверяет зависимости и выдает сообщение об ошибке, **если они образуют цикл**, что
  предотвращает возникновение проблем с зависимостями;
* Использование последовательных и однозначных импортированных имен облегчает понимание и поддержку кода.

____

# 10.5. Пустой импорт

* Пустой импорт используется только для запуска кода, который **не возвращает какие-либо значения**, например, для
  инициализации переменных и функций (`init()`).
* Для подавления ошибки "неиспользуемый импорт" используется переименование импорта с альтернативным
  названием `_ (пустой идентификатор)`;
* `Пустой импорт` применяется при реализации механизма **времени компиляции**, позволяющем основной программе включать
  необязательные возможности с помощью пустого импорта дополнительных пакетов (например, декодеры изображений);
* Пример использования пустого импорта - подключение декодировщика PNG: `import _ "image/png"`, после чего функция
  `image.Decode` сможет распознавать и обрабатывать изображения в данном формате;
* Работа со стандартной библиотекой `image` и пустыми импортами позволяет легко создавать преобразователи изображений,
  которые считывают изображение в одном формате и записывают его в другом;
* Без пустого импорта необходимого формата выполнимый файл будет компилироваться и компоноваться, однако функция
  `image.Decode` **не сможет распознать данный формат и выдаст ошибку**;
* Аналогичный механизм с пустыми импортами используется в пакете `database/sql` для установки только тех драйверов баз
  данных, в которых пользователь нуждается, например, для поддержки `PostgreSQL` или `MySQL`;
* Преимущества использования пустых импортов включают **меньший размер выполняемого файла** (за счет исключения
  неиспользуемых функций), **гибкость** и **возможность расширения функционала приложения** при необходимости.

____

# 10.6. Пакеты и именование

* Имена пакетов должны быть **короткими и понятными**; например, стандартные библиотеки Go используют
  имена `bufio`, `bytes`,
  `flag`, `fmt`, `http`, `io`, `json`, `os`, `sort`, `sync` и `time`;
* Лучше использовать описательные и недвусмысленные имена для пакетов, чтобы облегчить понимание их функций,
  например `imageutil` или `ioutil` вместо просто `util`;
* Обычно имена пакетов являются словами в **единственном числе**, хотя есть исключения, например, `bytes`, `errors`
  и `strings`;
* Нужно избегать **дублирования или конфликта имен пакетов** с другими смыслами, чтобы не возникло путаницы;
* При именовании членов пакета нужно учитывать, что **их имена будут использоваться совместно с именами пакетов**,
  поэтому они должны быть гармоничными и логичными;
* Для функций и структур внутри пакетов лучше использовать краткие и лаконичные имена, которые отражают их назначение,
  например: `bytes.Equal`, `flag.Int`, `http.Get`, `json.Marshal`;
* В некоторых пакетах, таких как `strings`, имена функций и структур не содержат слово `"string"`, поскольку оно
  подразумевается в названии пакета;
* Пакеты, предоставляющие основной тип данных и его методы, иногда имеют короткие имена, чтобы избежать стилистического
  повторения, например: `template.Template` или `rand.Rand`;
* Для сложных пакетов, таких как `net/http`, можно использовать простые и основные имена для наиболее важных членов
  пакета, например: `Get`, `Post`, `Handle`, `Error`, `Client`, `Server`.

____

# 10.7. Инструментарий Go

* Инструмент `go` является универсальным инструментом для работы с кодом на языке Go, объединяющим в себе функции
  менеджера пакетов, системы сборки и тестировщика; это упрощает процесс разработки и управления зависимостями;
* Инструмент go использует стиль "складного ножа" с множеством подкоманд, таких как get, run, build и fmt, для
  выполнения разных действий с кодом и пакетами;
* Инструмент go опирается на соглашения для упрощения конфигурации, такие как один пакет на каталог, и путь импорта
  пакета соответствует иерархии каталогов в рабочей области, что позволяет инструменту легко находить нужные файлы,
  объектные файлы и URL-серверы;
* Использование инструмента go позволяет разработчикам сосредоточиться на написании кода, облегчает управление проектом
  и его зависимостями, автоматизирует ряд рутинных задач и улучшает качество кода благодаря встроенным командам
  форматирования и тестирования.

____

## 10.7.1 Организация рабочего пространства

* Переменная `GOPATH` - это **корневой каталог рабочей области**, который определяет места расположения
  **исходного кода**, **скомпилированных пакетов** и **выполнимых программ**;
* `GOPATH` имеет три подкаталога - `src`, `pkg` и `bin`, каждый из которых хранит определенный тип файлов;
* В `GOPATH`, каталог `src` содержит **исходный код всех пакетов**, каждый из которых импортируется по отношению к этому
  каталогу;
* В `GOPATH/src` могут быть несколько репозиториев управления версиями (для каждого пакета);
* В подкаталоге `bin` хранятся выполнимые программы, такие как `helloworld`;
* Вторая переменная среды - `GOROOT` - указывает **корневой каталог дистрибутива Go**;
* Команда `go env` выводит действующие значения переменных среды, имеющих отношение к инструментарию, включая значения
  по умолчанию для отсутствующих;
* `GOOS` и `GOARCH` - **переменные**, которые определяют **целевую операционную систему** и **архитектуру целевого
  процессора** соответственно.

____

## 10.7.2 Загрузка пакетов

* Команда `go get` позволяет загрузить и обновить пакеты из Интернета, а также их зависимости; это упрощает управление
  кодом и синхронизацию с другими разработчиками;
* `go get` может загружать как одиночные пакеты, так и всё поддерево репозитория, что делает его универсальным
  инструментом;
* После загрузки пакетов команда `go get` автоматически выполняет сборку и установку библиотек и команд, что облегчает
  работу с новыми пакетами;
* Команда `go get` поддерживает популярные системы управления версиями, такие как Git или Mercurial, и популярные сайты
  хостинга кода, такие как GitHub, Bitbucket и Launchpad;
* Путь импорта указывает не только, где найти пакет в локальной рабочей области, но и где его найти в Интернете, что
  позволяет `go get` обрабатывать различные доменные имена и пути импорта;
* Если указан флаг `-u`, `go get` будет обновлять все посещенные пакеты и их зависимости до последней версии, что
  гарантирует их актуальность;
* Начиная с версии Go 1.6, поддерживается `"вендоризация"` – использование локальных копий внешних зависимостей, которые
  хранятся в каталоге `"vendor"` внутри проекта для легкого доступа и управления;
* `Вендоризация` упрощает управление зависимостями, т.к. зависимости разных проектов могут иметь разные версии и будут
  храниться локально, что позволяет легко переключать версии и избегать конфликтов.

____

## 10.7.3 Построение пакетов

* Команда `go build` используется для компиляции пакетов, указанных в качестве аргументов командной строки; это
  позволяет
  проверить наличие ошибок компиляции и обеспечивает корректную работу кода;
* Если пакет имеет имя `main`, `go build` вызывает компоновщик для создания выполнимого файла (строит запрошенный пакет
  и его зависимости, после этого **отбрасывает скомпилируемый код**, оставляя только бинарник), что позволяет запускать
  программы и обеспечивает удобство работы;
* Команда `go install` **сохраняет скомпилированный код каждого пакета и команды**, что делает последующие построения
  гораздо более быстрыми;
* Возможность `кросс-компиляции` в Go позволяет легко создавать выполнимые файлы для работы с разными операционными
  системами или процессорами, что обеспечивает универсальность кода;
* Go поддерживает использование специальных комментариев, таких
  как `дескрипторы построения` ( `// +build linux darwin`), что позволяет тонко управлять компиляцией файлов для разных
  платформ или процессоров, что облегчает работу с низкоуровневой переносимостью
  или оптимизацией версий важных процедур.

____

## 10.7.4 Документирование пакетов

* Стиль Go настоятельно рекомендует тщательно документировать API пакетов; она помогает пользователям легче разобраться
  в предназначении и использовании пакетов;
* Каждое объявление **экспортируемого члена пакета** и **самого объявления пакета** должны сопровождаться комментарием,
  объясняющим их цель и использование;
* Документирующие комментарии Go являются **полными предложениями**, начинающимися с имени объявления, объясняющим его
  назначение;
* Пакетное объявление должно иметь только один документирующий комментарий, который может находиться в любом файле или в
  отдельном файле под названием `doc.go`;
* Важно стремиться к краткости и простоте в документации, поскольку как и код, она также **требует обслуживания**;
* Инструмент `go doc` выводит документирующие комментарии для указанных объектов, пакетов или членов пакета, что
  облегчает работу с документацией;
* Инструмент `godoc` предоставляет HTML-страницы с документацией, которые можно просматривать через браузер или
  запустить на локальном сервере для просмотра собственных пакетов;
* Польза от использования тщательной документации заключается в упрощении процесса обучения для новичков, быстром
  разборе в коде для опытных разработчиков и улучшении общего качества кода.

____

## 10.7.5 Внутренние пакеты

* Пакеты являются важным механизмом `инкапсуляции` в Golang.
* `Неэкспортируемые идентификаторы` **видимы только в пределах одного пакета**, а `экспортируемые` - **видимы всем**.
* Для определения идентификаторов, которые являются видимыми только для небольшого набора доверенных пакетов, можно
  использовать `внутренние пакеты`.
* `Внутренний пакет` (`internal`) может быть импортирован только другим пакетом, находящимся в дереве с корнем в
  родительском по отношению к `internal` каталоге.
* Разбивая большой пакет на более управляемые меньшие части, можно не захотеть раскрывать интерфейсы между этими частями
  для других пакетов, для этой задачи подойдет применение внутреннего пакета.
* Совместное использование вспомогательных функций несколькими пакетами проекта без их общедоступности может быть
  достигнуто через `внутренние пакеты`.
* `Внутренние пакеты` могут использоваться для экспериментирования с новым пакетом без преждевременной фиксации его API,
  предоставив его "на испытательный срок" узкому кругу клиентов.
* Использование `внутренних пакетов` позволяет более гибко и безопасно управлять доступом к коду проекта.
* `Внутренние пакеты` помогают избежать конфликтов имен и запутанности в коде проекта.
* `Внутренние пакеты` - это один из способов обеспечения безопасности и структурирования кода в больших проектах.

____

## 10.7.6 Запрашиваемые пакеты

____