# 10. Пакеты и инструменты Go

Сегодня программа скромного размера может содержать десятки тысяч функций. Тем не менее ее автору нужно думать лишь о
некоторых из них, а разрабатывать — и того меньше, потому что подавляющее большинство функций написано другими
программистами и доступно для повторного использования в виде пакетов.

Go поставляется более чем с сотней стандартных пакетов, которые обеспечивают основу для большинства приложений. Куда
больше пакетов, разработанных всем сообществом программистов Go, можно найти по адресу http://godoc.org. В этой главе мы
покажем, как использовать существующие пакеты и создавать новые.

Go также поставляется с инструментом `go`, сложным, но простым в использовании, который представляет собой команду, в
том числе для управления пакетами Go. В начале книги мы показали, как использовать `go` для того, чтобы скачать,
построить и запустить примеры программ. В этой главе рассмотрены основные концепции, лежащие в основе этого инструмента,
и подробно изложены его возможности, которые включают вывод документации и запрос метаданных о пакетах в рабочей
области. В следующей главе мы будем изучать его возможности тестирования.

<!-- TOC -->

* [10.1. Введение](#101-введение)
* [10.2. Пути импорта](#102-пути-импорта)
* [10.3. Объявление пакета](#103-объявление-пакета)
* [10.4. Объявления импорта](#104-объявления-импорта)
* [10.5. Пустой импорт](#105-пустой-импорт)
* [10.6. Пакеты и именование](#106-пакеты-и-именование)
* [10.7. Инструментарий Go](#107-инструментарий-go)
	* [10.7.1 Организация рабочего пространства](#1071-организация-рабочего-пространства)
	* [10.7.2 Загрузка пакетов](#1072-загрузка-пакетов)
	* [10.7.3 Построение пакетов](#1073-построение-пакетов)
	* [10.7.4 Документирование пакетов](#1074-документирование-пакетов)
	* [10.7.5 Внутренние пакеты](#1075-внутренние-пакеты)
	* [10.7.6 Запрашиваемые пакеты](#1076-запрашиваемые-пакеты)

<!-- TOC -->

____

# 10.1. Введение

* `Системы пакетов` облегчают разработку и поддержку больших программ путем **группировки связанных функций в модули**,
  что делает их легче понимать и изменять независимо друг от друга;
* `Модульность` позволяет **использовать пакеты совместно в разных проектах**, они могут быть **распространены внутри
  организации или доступны всему миру**;
* `Пакеты` **определяют уникальное пространство имен для всех своих идентификаторов**, что избегает конфликтов имен в
  разных частях программы;
* `Инкапсуляция пакетов` управляет **видимостью имен и позволяет скрыть вспомогательные функции и типы за API пакета**,
  облегчая его разработку и поддержку;
* `Ограничение видимости переменных пакета` заставляет пользователей обращаться к ним **только через экспортированные
  функции**, что обеспечивает сохранение внутренних инвариантов и взаимоисключение в параллельных программах;
* При изменении файла в пакете, **необходимо перекомпилировать его и все зависимые пакеты**;
* Компиляция Go быстрая благодаря трём основным причинам: `явное указание импортируемых пакетов`, `отсутствие циклов в
  зависимостях` и `использование объектных файлов с экспортируемой информацией для всех зависимостей`.

____

# 10.2. Пути импорта

* Пути импорта в Go идентифицируют пакеты и используются в объявлениях `import`;
* Спецификация языка Go **не определяет смысл** и правила нахождения путей импорта, поэтому разные инструменты могут
  иметь свои соглашения; наиболее распространенным инструментом является `go`, который определяет стандартные правила
  для большинства программистов Go;
* Для пакетов, предназначенных для совместного использования или публикации, **пути импорта должны быть глобально
  уникальными**; это предотвращает конфликты и способствует легкому нахождению и использованию пакетов;
* Пути импорта пакетов, не входящих в стандартную библиотеку, должны начинаться с **доменного имени
  организации-владельца**; это делает пути импорта более понятными и способствует их уникальности;
* В объявлениях `import` можно использовать пути импорта как стандартных библиотек (например, `"fmt"`, `"math/rand"`),
  так и сторонних пакетов (например, `"golang.org/x/net/html"`, `"github.com/gosqldriver/mysql"`);
* Использование путей импорта соответствующим образом упрощает подключение и использование различных пакетов, что
  способствует ускорению разработки и улучшению качества кода на языке Golang.

____

# 10.3. Объявление пакета

* Объявление `package` определяет **идентификатор по умолчанию** для пакета при его импорте в другой пакет; это
  позволяет упростить обращение к членам пакета через идентификатор, например, `rand.Int` для пакета `math/rand`;
* Имя пакета по соглашению `является последней частью пути импорта`, что позволяет иметь разные пакеты с одинаковыми
  именами, но разными путями импорта, упрощая их использование;
* Пакет с именем `main` определяет команду `(выполнимую программу Go)`, что сигнализирует инструментам Go о
  необходимости создания исполняемого файла;
* Файлы с суффиксом `_test` в имени пакета определяют **пакеты для внешнего тестирования**, что позволяет избежать
  циклов в графе импорта и облегчает тестирование кода;
* `Инструменты управления зависимостями` могут добавить `суффикс с номером версии в путь импорта пакета`, и этот суффикс
  **следует исключать из имени пакета** для упрощения использования.

____

# 10.4. Объявления импорта

* Исходный файл Go может содержать **нуль или более объявлений импорта** после объявления `package`; это позволяет
  загружать код из других пакетов и использовать его в текущем файле;
* Объявления импорта могут быть **сгруппированы** с помощью добавления пустых строк для указания различных предметных
  областей; это облегчает чтение кода;
* Импортированные пакеты могут использовать `альтернативные имена`, чтобы избегать конфликтов с именами других пакетов
  или локальных переменных;
* Альтернативное имя влияет **только на импортирующий файл**, что обеспечивает гибкость при импорте пакетов;
* Пример импорта с использованием альтернативного имени:
  ``` go
  import (
      "crypto/rand"
      mrand "math/rand" // Альтернативное имя mrand устраняет конфликт
  )
  ```
* При наличии громоздких имен пакетов, использование альтернативных имен может облегчить чтение кода;
* Инструмент `go build` проверяет зависимости и выдает сообщение об ошибке, **если они образуют цикл**, что
  предотвращает возникновение проблем с зависимостями;
* Использование последовательных и однозначных импортированных имен облегчает понимание и поддержку кода.

____

# 10.5. Пустой импорт

* Пустой импорт используется только для запуска кода, который **не возвращает какие-либо значения**, например, для
  инициализации переменных и функций (`init()`).
* Для подавления ошибки "неиспользуемый импорт" используется переименование импорта с альтернативным
  названием `_ (пустой идентификатор)`;
* `Пустой импорт` применяется при реализации механизма **времени компиляции**, позволяющем основной программе включать
  необязательные возможности с помощью пустого импорта дополнительных пакетов (например, декодеры изображений);
* Пример использования пустого импорта - подключение декодировщика PNG: `import _ "image/png"`, после чего функция
  `image.Decode` сможет распознавать и обрабатывать изображения в данном формате;
* Работа со стандартной библиотекой `image` и пустыми импортами позволяет легко создавать преобразователи изображений,
  которые считывают изображение в одном формате и записывают его в другом;
* Без пустого импорта необходимого формата выполнимый файл будет компилироваться и компоноваться, однако функция
  `image.Decode` **не сможет распознать данный формат и выдаст ошибку**;
* Аналогичный механизм с пустыми импортами используется в пакете `database/sql` для установки только тех драйверов баз
  данных, в которых пользователь нуждается, например, для поддержки `PostgreSQL` или `MySQL`;
* Преимущества использования пустых импортов включают **меньший размер выполняемого файла** (за счет исключения
  неиспользуемых функций), **гибкость** и **возможность расширения функционала приложения** при необходимости.

____

# 10.6. Пакеты и именование

* Имена пакетов должны быть **короткими и понятными**; например, стандартные библиотеки Go используют
  имена `bufio`, `bytes`,
  `flag`, `fmt`, `http`, `io`, `json`, `os`, `sort`, `sync` и `time`;
* Лучше использовать описательные и недвусмысленные имена для пакетов, чтобы облегчить понимание их функций,
  например `imageutil` или `ioutil` вместо просто `util`;
* Обычно имена пакетов являются словами в **единственном числе**, хотя есть исключения, например, `bytes`, `errors`
  и `strings`;
* Нужно избегать **дублирования или конфликта имен пакетов** с другими смыслами, чтобы не возникло путаницы;
* При именовании членов пакета нужно учитывать, что **их имена будут использоваться совместно с именами пакетов**,
  поэтому они должны быть гармоничными и логичными;
* Для функций и структур внутри пакетов лучше использовать краткие и лаконичные имена, которые отражают их назначение,
  например: `bytes.Equal`, `flag.Int`, `http.Get`, `json.Marshal`;
* В некоторых пакетах, таких как `strings`, имена функций и структур не содержат слово `"string"`, поскольку оно
  подразумевается в названии пакета;
* Пакеты, предоставляющие основной тип данных и его методы, иногда имеют короткие имена, чтобы избежать стилистического
  повторения, например: `template.Template` или `rand.Rand`;
* Для сложных пакетов, таких как `net/http`, можно использовать простые и основные имена для наиболее важных членов
  пакета, например: `Get`, `Post`, `Handle`, `Error`, `Client`, `Server`.

____

# 10.7. Инструментарий Go

____

## 10.7.1 Организация рабочего пространства

____

## 10.7.2 Загрузка пакетов

____

## 10.7.3 Построение пакетов

____

## 10.7.4 Документирование пакетов

____

## 10.7.5 Внутренние пакеты

____

## 10.7.6 Запрашиваемые пакеты

____