# 10.1. Введение

Цель любой системы пакетов — сделать дизайн и поддержку больших программ практичными **путем группирования связанных
функций в модули**, которые легко понимать и изменять независимо от других пакетов программы. Такая **модульность
позволяет совместно использовать пакеты** разными проектами, **распространять их** в пределах организации или **делать
доступными всему миру**.

Каждый пакет `определяет уникальное пространство имен`, охватывающее все его идентификаторы. Каждое имя связано с
конкретным пакетом, что позволяет нам выбирать короткие, ясные имена для наиболее часто используемых типов, функций и
так далее, не создавая при этом конфликтов с другими частями программы.

Пакеты также обеспечивают `инкапсуляцию`, управляя тем, **какие имена видны, или экспортируемы, вне пакета**.
Ограничение видимости членов пакета **скрывает вспомогательные функции и типы** за API пакета, позволяя сопровождению
пакета **менять внутреннюю реализацию,** не затрагивая код вне пакета. Ограничение видимости также **скрывает \
переменные**, так что клиенты могут получать к ним доступ и обновлять их значения только через экспортированные функции,
которые обеспечивают сохранение **внутренних инвариантов или взаимоисключение в параллельной программе**.

При изменении файла **необходимо перекомпилировать пакет, в который входит этот файл, и потенциально — все пакеты,
которые зависят от него**. Компиляция Go выполняется **гораздо быстрее**, чем большинства других компилируемых языков,
даже когда построение выполняется "с нуля". Есть **три** основные причины такой скорости компиляции:

* Во-первых, все импортируемые пакеты **должны быть явно указаны в начале каждого исходного файла**, поэтому компилятору
  не приходится читать и анализировать весь файл, чтобы определить его зависимости;
* Во-вторых, зависимости пакета образуют **ориентированный ациклический граф**, и в силу отсутствия циклов пакеты могут
  компилироваться отдельно и, возможно, параллельно;
* В-третьих, **объектный файл скомпилированного пакета Go записывает экспортируемую информацию не только для самого
  пакета, но и для его зависимостей**. При компиляции пакета компилятор должен прочитать **один объектный файл для
  каждого импортируемого пакета**, но не должен выходить за пределы этих файлов.

## Выводы:

* `Системы пакетов` облегчают разработку и поддержку больших программ путем **группировки связанных функций в модули**,
  что делает их легче понимать и изменять независимо друг от друга;
* `Модульность` позволяет **использовать пакеты совместно в разных проектах**, они могут быть **распространены внутри
  организации или доступны всему миру**;
* `Пакеты` **определяют уникальное пространство имен для всех своих идентификаторов**, что избегает конфликтов имен в
  разных частях программы;
* `Инкапсуляция пакетов` управляет **видимостью имен и позволяет скрыть вспомогательные функции и типы за API пакета**,
  облегчая его разработку и поддержку;
* `Ограничение видимости переменных пакета` заставляет пользователей обращаться к ним **только через экспортированные
  функции**, что обеспечивает сохранение внутренних инвариантов и взаимоисключение в параллельных программах;
* При изменении файла в пакете, **необходимо перекомпилировать его и все зависимые пакеты**;
* Компиляция Go быстрая благодаря трём основным причинам: `явное указание импортируемых пакетов`, `отсутствие циклов в
  зависимостях` и `использование объектных файлов с экспортируемой информацией для всех зависимостей`.