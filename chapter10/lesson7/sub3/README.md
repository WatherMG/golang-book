# 10.7.3. Построение пакетов

Команда `go build` компилирует каждый пакет, указанный в качестве аргумента командной строки. Если пакет представляет
собой библиотеку, результат игнорируется; проверяется только, чтобы при компиляции пакета не было ошибок компиляции.

Если пакет имеет имя `main`, `go build` вызывает компоновщик для создания выполнимого файла в текущем каталоге; имя
выполнимого файла берется из **последней части пути импорта пакета**.

Поскольку каждый каталог содержит один пакет, каждая выполнимая программа (или `команда` в терминологии Unix) требует
собственный каталог. Эти каталоги иногда являются дочерними по отношению к каталогу с именем `cmd`, как, например,
`golang.org/x/tools/cmd/godoc` в случае команды, которая служит документацией пакетов Go через веб-интерфейс (раздел
10.7.4).

**Пакеты могут быть указаны с помощью путей импорта**, как мы видели выше, или с помощью **относительного имени
каталога**, которое должно начинаться с `.` или `..`, даже если обычно это не требуется. Если никакие аргументы не
предоставлены, предполагается текущий каталог. Таким образом, следующие команды строят один и тот же пакет, хотя каждая
записывает выполнимый файл в каталог, в котором запускается `go build`:

``` shell
$ cd $GOPATH/src/gopl.io/ch1/helloworld 
$ go build

И

$ cd anywhere
$ go build gopl.io/ch1/helloworld

И

$ cd $GOPATH
$ go build ./src/gopl.io/ch1/helloworld

Но не

$ cd $GOPATH
$ go build src/gopl.io/ch1/helloworld
Ошибка: не найден пакет "src/gopl.io/ch1/helloworld".
```

Пакеты могут быть указаны и как список имен файлов, хотя это, как правило, используется только для небольших программ и
разовых экспериментов. Если имя пакета — `main`, имя выполнимого файла берется из **имени первого .go-файла**:

``` shell
$ cat quoteargs.go
package main
import (
	"fmt"
	"os"
)
func main() {
	fmt.Printf("%q\n", os.Args[1:])
}

$ go build quoteargs.go
$ ./quoteargs one "two three" four\ five 
["one" "two three" "four five"]
```

Часто для разовых программ, таких как эта, мы хотим выполнить и сразу по построении запустить выполнимый файл. Команда
`go run` сочетает в себе эти два шага:

``` shell
$ go run quoteargs.go one "two three" four\ five 
["one" "two three" "four five"]
```

Предполагается, что первый аргумент, который **не оканчивается** на `.go`, является **началом списка аргументов для
выполнимого файла**.

По умолчанию команда `go build` строит запрошенный пакет и все его зависимости, а затем отбрасывает весь
скомпилированный код за исключением окончательного выполнимого файла, если таковой имеется. Анализ зависимостей и
компиляции выполняется на удивление быстро, но с ростом проектов до десятков пакетов и сотен тысяч строк кода время
перекомпиляции зависимостей может стать заметным — потенциально достичь нескольких секунд, даже если эти зависимости не
изменились.

Команда `go install` очень похожа на `go build`, с тем отличием, что **она сохраняет скомпилированный код каждого пакета
и команды** вместо того, чтобы его отбросить. Скомпилированные пакеты сохраняются в подкаталогах каталога `$GOPATH/pkg`,
соответствующего каталогу `src`, в котором хранятся исходные тексты, а выполнимые файлы хранятся в
каталоге `$GOPATH/bin`. (Многие пользователи добавляют `$GOPATH/bin` в пути поиска выполнимых файлов.) После этого
команды `go build` и `go install` не запускают компилятор для этих пакетов и команд, если они не изменились, что делает
последующие построения гораздо более быстрыми. Для удобства `go build -i` устанавливает пакеты, от которых зависит
целевой объект.

Поскольку скомпилированные пакеты зависят от платформы и архитектуры, `go install` сохраняет их в подкаталоге, имя
которого включает значения переменных среды `GOOS` и `GOARCH`. Например, на компьютерах `Мас`
пакет `golang.org/x/net/html` компилируется и устанавливается в файле `golang.org/x/net/html.а` в
подкаталоге `$G0PATH/pkg/darwin_amd64`.

Очень просто выполняется в Go кросс-компиляция, т.е. построение выполнимого файла, предназначенного для работы с другой
операционной системой или процессором. Просто установите переменные среды `GOOS` и `GOARCH` на время построения.
Программа
`cross` выводит операционную систему и архитектуру, для которой она была построена (см. cross):

``` go
func main() {
	fmt.Println(runtime.GOOS, runtime.GOARCH)
}
```

Следующие команды создают `64-` и `32-`разрядное приложения соответственно:

``` shell
go build .\cross.go
./cross
windows amd64

GOARCH=386 go build .\cross.go || $env:GOARCH='386'; go build .\cross.go
windows 386
```

Для некоторых пакетов может потребоваться компиляция различных версий кода для определенных платформ или процессоров,
например для **низкоуровневой переносимости** или **оптимизации версий важных процедур**. Если имя файла содержит
название операционной системы или имя архитектуры процессора наподобие `net_linux.go` или `asm_amd64.s`, то `go` будет
компилировать файл только при построении для этой целевой системы или процессора. Специальные комментарии под названием
`дескрипторы построения` обеспечивают более тонкое управление. Например, если файл содержит комментарий

``` go
// +build linux darwin
```

перед объявлением пакета (и его документирующим комментарием), `go build` будет компилировать его только при построении
для `Linux` или `Mac OS X`, а следующий комментарий указывает, что данный файл никогда не должен компилироваться:

``` go
// +build ignore
```

Более подробную информацию можно найти в разделе `Build Constraints` документации пакета go/build:

``` shell
$ go doc go/build
```

## Выводы:

* Команда `go build` используется для компиляции пакетов, указанных в качестве аргументов командной строки; это
  позволяет
  проверить наличие ошибок компиляции и обеспечивает корректную работу кода;
* Если пакет имеет имя `main`, `go build` вызывает компоновщик для создания выполнимого файла (строит запрошенный пакет
  и его зависимости, после этого **отбрасывает скомпилируемый код**, оставляя только бинарник), что позволяет запускать
  программы и обеспечивает удобство работы;
* Команда `go install` **сохраняет скомпилированный код каждого пакета и команды**, что делает последующие построения
  гораздо более быстрыми;
* Возможность `кросс-компиляции` в Go позволяет легко создавать выполнимые файлы для работы с разными операционными
  системами или процессорами, что обеспечивает универсальность кода;
* Go поддерживает использование специальных комментариев, таких
  как `дескрипторы построения` ( `// +build linux darwin`), что позволяет тонко управлять компиляцией файлов для разных
  платформ или процессоров, что облегчает работу с низкоуровневой переносимостью
  или оптимизацией версий важных процедур.