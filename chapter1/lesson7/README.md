# 1.7. Веб-сервер

Функция `main` связывает функцию-обработчик с входящим `URL`, который начинается с `/`, и запускает сервер,
прослушивающий порт `8000` в ожидании входящих запросов.
Запрос представлен структурой типа `http.Request` - содержит ряд связанных полей, одно из которых представляет
собой `URL` входящего запроса. Полученный запрос передается функции-обработчику, которая извлекает компонент
пути `(\hello)` из `URL` запроса и отправляет его обратно в качестве ответа с помощью `fmt.Fprintf()`

Чтобы запустить сервер в фоновом режиме в ОС `Linux` и `Mac` нужно ввести символ `&`
> go run server1.go &
>
> Чтобы завершить процесс, нужно найти его с помощью команды `ps -ef | grep server1.go` и выполнить команду `kill PID`"

В ОС `Windows` символ амперсанда не нужен.

Обратиться к серверу можно из cli или веб-браузера `localhost:8000/`

Во второй версии сервера (server2.go) добавлен функционал подсчета количества запросов. Запрос к `URL` `/count`
возвращает это количество, за исключением самого запроса (В Google chrome 109 считает очень странно, подсчет идет и по
url `/count`, при этом в других браузерах - норм, как и в генераторе запросов в Goland).

У сервера имеется два обработчика, и запрашиваемый `URL` определяет, какой из них будет вызван: запрос `/count`
вызывает `counter`, а все прочие - `handler2`. Сервер запускает обработчик для каждого входящего запроса в отдельной
горутине, так что несколько запросов могут обрабатываться одновременно. Однако, если два параллельных запроса попытаются
обновить счетчик `count` в один и тот же момент времени, он может быть увеличен не согласованно. В такой программе может
возникнуть серьезная ошибка под названием **_состояние гонки (race condition)_**.
Чтобы избежать этой проблемы, нужно гарантировать, что доступ к переменной получает не более одной горутины
одновременно.
Для этого каждый доступ к переменной должен быть окружен вызовами `mu.Lock()` и `mu.Unlock().

Go разрешает простым инструкциям, таким как объявление локальной переменной, предшествовать условию if, что особенно
полезно при обработке ошибок (L28-L30). Это делает код короче и уменьшает область видимости переменной `err`, что
является хорошей практикой.

Вторым аргументом функции `HandleFunc` является **_литерал функции_**, т.е. анонимная функция, определенная в точке
использования.
