# 8.4 Каналы

Если горутины представляют собой **процессы** в рамках параллельной программы Go, то `каналы` являются `соединениями`
между ними. `Канал` представляет собой механизм связи, который позволяет одной горутине отправлять некоторые
значения другой горутине. Каждый `канал` является средством передачи значений определенного типа, который
называется `типом элементов канала`. Тип канала, элементы которого имеют тип `int`, записывается как `chan int`.
Для создания канала мы используем встроенную функцию `make`:

``` go
ch := make(chan int) // ch имеет тип `chan int`
```

Как и в случае с картами (map), `канал` является `ссылкой на структуру данных`, создаваемую с помощью функции `make`.
Копируя канал или передавая его функции в качестве аргумента, мы `копируем ссылку`, поэтому вызывающая и вызываемая
функции ссылаются на `одну и ту же` структуру данных. Как и в случае с
другими `ссылочными типами`, `нулевым значением канала является nil`.
Два канала одного типа можно сравнивать с помощью оператора `==`. Сравнение имеет значение `true`, если оба канала
являются
`ссылками` на **одну и ту же структуру данных канала**. `Канал` также можно сравнить со значением `nil`.
`Канал` имеет две основные операции, `отправление` и `получение`, вместе известные как `коммуникации (communications)`.
Инструкция `отправления` передает через `канал` значение из одной горутины другой, выполняющей соответствующее
выражение получения. Обе операции записываются с использованием оператора `<-`. В инструкции `отправления` `<-`
разделяет `канал` и `значение`. В выражении получения `<-` предшествует операнду канала. Выражение `получения`,
результат которого не используется, является корректной инструкцией.

``` go
ch <- х // Инструкция отправления
х = <-ch // Выражение получения в инструкции присваивания 
<-ch // Инструкция получения; результат не используется
```

Каналы поддерживают третью операцию, `закрытие`, которая `устанавливает флаг`, указывающий, что по этому каналу больше
не
будут передаваться значения; после этого любые попытки отправления завершаются `паникой`. Операции получения,
примененные к закрытому каналу, приводят к получению значений, которые были отправлены ранее, до тех пор, пока
неполученных значений не останется; любые дальнейшие попытки получить значения приводят к немедленному завершению
операции и возврату `нулевого значения типа элемента канала`.
Чтобы закрыть канал, используется встроенная функция `close`:

```
close(ch)
```

Канал, созданный с помощью простого вызова `make`, называется `небуферизованным каналом`, но `make` принимает
необязательный `второй аргумент`, целое значение, которое называется `емкостью канала`. Если емкость канала
ненулевая, `make` создает буферизованный канал.

``` go
ch = make(chan int)    // Небуфиризованный канал
ch = make(chan int, 0) // Небуфиризованный канал
ch = make(chan int, 3) // Буферизованный канал с емкостью 3
```

Пока что мы будем рассматривать `небуферизованные` каналы, а к `буферизованным` каналам обратимся в разделе 8.4.4.

## Выводы:

* Горутины представляют собой `процессы` в рамках параллельной программы Go, а каналы
  являются `соединениями между ними`;
* `Канал` представляет собой механизм связи, который позволяет **одной горутине отправлять значения другой горутине**;
* Каждый канал имеет `тип элементов канала`, записывается как `chan <тип_элементов>`, например `chan int`;
* Канал создается с использованием встроенной функции `make`. Пример: `ch := make(chan int)`;
* Копируя канал или передавая его функции в качестве аргумента, копируется `ссылка` на структуру данных;
* Каналы поддерживают три операции: `отправление`, `получение` и `закрытие` канала;
* Отправление значения через канал: `ch <- value`; пример:` ch <- 3`;
* Получение значения из канала: `value = <-ch`; пример: `x := <-ch`;
* Закрытие канала с помощью встроенной функции `close`: `close(ch)`;
* Каналы могут быть `небуферизованными` (не иметь емкости) или `буферизованными` (иметь емкость). Создание
  буферизованного канала: `ch = make(chan int, 3)`;
* Небуферизованные каналы `блокируют отправляющую горутину` до тех пор, пока получающая горутина не заберет значение.
  Буферизованные каналы `имеют очередь для хранения значений` до получения их другими горутинами.