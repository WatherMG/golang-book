# 8.7 Мультиплексирование с помощью `select`

Приведенная ниже программа осуществляет обратный отсчет для запуска ракеты. Функция `time.Ticк` возвращает канал, по
которому она периодически отправляет события, действуя как метроном. Каждое событие представляет собой значение момента
времени, но оно не так интересно, как сам факт его доставки (см. countdown1.go)

``` go
func main() {
	fmt.Println("Начинаю отсчет.")
	tick := time.Tick(1 * time.Second)
	for countdown := 10; countdown > 0; countdown-- {
		fmt.Println(countdown)
		<-tick
	}
	launch()
}

func launch() {
	fmt.Println("Запуск!")
}
```

Давайте теперь добавим возможность прервать последовательность запуска, нажав клавишу `<Enter>` во время обратного
отсчета. Сначала мы запустим горутину, которая пытается прочитать один байт из стандартного ввода и, если это
удастся, отправляет значение в канал, который называется `abort`.

``` go
// ...создаем канал abort...
	abort := make(chan struct{})
	go func() {
		os.Stdin.Read(make([]byte, 1)) // Читаем 1 байт
		abort <- struct{}{}
	}()
```

Теперь каждая итерация цикла обратного отсчета должна ожидать события от одного из двух каналов: канала `tick`, если все
в порядке, или канала `abort`, если следует отменить запуск. Мы не можем просто получать значения от каждого канала,
потому что первая же операция будет блокирована до ее завершения. Мы должны `мультиплексировать` эти операции, а чтобы
это сделать, нужна инструкция `select`:

``` go
select { 
case <-chi:
	// ... 
case x := <-ch2:
	// ...используем x... 
case ch3 <-y:
	// ... 
default:
	// ...
}
```

Общий вид инструкции `select` показан выше. Как и инструкция `switch`, она имеет ряд вариантов `case` и дополнительный
вариант по умолчанию `default`. Каждый вариант определяет связь (операции отправления или получения на некоторых
каналах) и блок инструкций. Выражение получения может быть как само по себе, как показано в первом случае, так и в
коротком объявлении переменной, как показано во втором случае. Вторая форма позволяет ссылаться на полученное значение.

Инструкция `select` ожидает, когда связь для некоторого варианта будет готова к обработке. Затем она выполняет операцию
связи и выполняет инструкции из блока для данного варианта. Операции прочих связей не происходят. Инструкция `select`
без вариантов, `select{}`, ожидает вечно.

Вернемся к нашей программе запуска ракеты. Функция `time.After` немедленно возвращает канал и запускает новую
горутину, которая отправляет одно значение в канал по истечении указанного времени. Инструкция `select` ниже
ожидает до тех пор, пока не произойдет первое из двух событий, либо событие прерывания запуска, либо событие,
указывающее, что прошло 10 секунд. Если прошло 10 секунд без события прерывания, программа выполняет запуск.

Пример ниже — более тонкий. Канал `ch` с буфером размером `1` поочередно становится то полным, то пустым, так что
обрабатывается только один из вариантов: либо отправление при четном `i`, либо получение при `i` нечетном. На экран
всегда выводится `0 2 4 6 8`:

``` go
ch := make(chan int, 1)
for i := 0; i < 10; i++ {
	select {
	case x := <-ch:
		fmt.Println(x) // 0, 2, 4, 6, 8
	case ch <- i:
	}
}
```

Если готовы несколько вариантов, `select` выбирает один из них случайным образом; это гарантирует, что каждый канал
имеет равные шансы быть выбранным. Увеличение размера буфера в предыдущем примере делает его
вывод `недетерминированным`, потому что, когда буфер ни полный, ни пустой, инструкция `select`, образно говоря,
**бросает монетку**.

Давайте сделаем нашу программу запуска выводящей обратный отсчет. Инструкция `select` ниже приводит к тому, что на
каждой
итерации цикла выполняется ожидание сигнала прерывания в течение секунды, но не дольше.

``` go
func main() {
	abort := make(chan struct{})
	go func() {
		os.Stdin.Read(make([]byte, 1))
		abort <- struct{}{}
	}()

	fmt.Println("Начинаю отсчет. Нажмите <ENTER> для отмены.")
	tick := time.Tick(1 * time.Second)
	for countdown := 10; countdown > 0; countdown-- {
		fmt.Println(countdown)
		select {
		case <-tick:
			// ничего не делаем
		case <-abort:
			fmt.Println("Запуск отменен!")
			return
		}
	}
	launch()
}

func launch() {
	fmt.Println("Запуск!")
}
```

Функция `time.Tick` ведет себя так, как будто создает горутину, которая вызывает `time.Sleep` в цикле, отправляя
событие всякий раз, когда она "просыпается". Когда функция отсчета завершается, она перестает получать события
от `tick`,
но соответствующая горутина остается работать и пытается отправлять события в канал, из которого их не получает
никакая горутина, т.е. происходит утечка горутины (раздел 8.4.4).

Функция `Tick` удобна, но она подходит только тогда, когда отсчеты времени необходимы на протяжении всего жизненного
цикла приложения. В противном случае необходимо использовать следующий шаблон:

``` go
ticker := time.NewTicker(1 * time.Second)

<-ticker.C // Получение из канала ticker

ticker.Stop() // Остановка горутины ticker
```

Иногда мы хотим попытаться отправить данные в канал или получить их из него, но избежать блокировки, если канал не
готов, т.е. обеспечить неблокирующую связь. Инструкция `select` может сделать и это. Она может иметь вариант по
умолчанию `default`, который указывает, что делать, когда ни одно из других сообщений не может быть обработано
немедленно.

Инструкция `select` ниже получает значение из канала `abort`, если таковое доступно для получения; в противном случае
она ничего не делает. Это высокопроизводительная неблокирующая операция получения; ее многократное повторение называют
`опросом канала`.

``` go
select {
case <-abort:
	fmt.Printf("Запуск отменен!\n")
	return
default:
	// Ничего не делать
```

Нулевым значением для канала является `nil`. Возможно, это удивительно, но иногда нулевые каналы полезны. Поскольку
**операции отправления и получения с нулевым каналом блокируются навсегда**, варианты с нулевыми каналами в инструкции
`select` **никогда не выбираются**. Это позволяет нам использовать `nil` для включения или отключения вариантов, которые
соответствуют таким возможностям, как обработка тайм-аутов или отмена, отвечая на другие входные события или генерируя
вывод. Мы рассмотрим соответствующий пример в следующем разделе.

## Выводы:

* Мультиплексирование с `select` позволяет ожидать событий от нескольких каналов одновременно;
* Можно использовать инструкцию `select` для выполнения операций отправления или получения на каналах без блокировки;
* Если готовы (отправка\получение) несколько вариантов, `select` выбирает один из них случайным образом;
* Инструкция `select` может иметь вариант по умолчанию (`default`) для обозначения операции, которую необходимо
  выполнять, когда другие связи не готовы к обработке, и для обеспечения неблокирующей связи;
* Возможно использовать `time.Tick` для запуска периодических действий, однако это может привести к утечке горутин, если
  отсчеты времени не нужны на протяжении всего жизненного цикла приложения. В таких случаях нужно
  использовать `time.NewTicker` и `ticker.Stop()`;
* Нулевое значение для канала (`nil`) может быть полезно, поскольку операции отправления и получения с нулевым каналом
  блокируются навсегда. В таких случаях варианты с нулевыми каналами в инструкции `select` никогда не выбираются, что
  позволяет включить или отключить варианты в зависимости от других входных событий или генерации вывода.