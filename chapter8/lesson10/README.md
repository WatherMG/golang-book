# 8.10 Пример: чат-сервер

Мы завершим эту главу разработкой чат-сервера, который позволяет нескольким пользователям обмениваться текстовыми
сообщениями друг с другом. В этой программе есть четыре вида горутин. Имеется по экземпляру горутин `main` и
`broadcaster`, а для каждого подключенного клиента имеется по одной горутине `handleConn` и `clientWriter`.
Горутина `broadcaster` является хорошей иллюстрацией использования инструкции `select`, так как она должна
реагировать на три различных вида сообщений.
Работа главной горутины, показанной ниже, состоит в прослушивании и приеме входящих сетевых подключений от
клиентов. Для каждого из них она создает новую горутину `handleConn`, так же как это делал параллельный эхо-сервер
в начале этой главы (см. chat.go).

``` go
func main() {
	listener, err := net.Listen("tcp", "localhost:8000")
	if err != nil {
		log.Fatal(err)
	}
	
	go broadcaster()
	for {
		conn, err := listener.Accept()
		if err != nil {
			log.Print(err)
			continue
		}
		go handleConn(conn)
	}
}
```

Теперь перейдем к горутине `broadcaster`. Ее локальная переменная `clients` записывает текущее множество подключенных
клиентов. Единственная информация, записываемая о каждом клиенте, — это его канал для исходящих сообщений, о котором
будет сказано чуть позже.

``` go
func broadcaster() {
	clients := make(map[client]bool) // Все подключенные клиенты
	for {
		select {
		case msg := <-messages:
			// Широковещательное входящее сообщение во все
			// каналы исходящих сообщений для клиентов.
			for cli := range clients {
				cli <- msg
			}
		case cli := <-entering:
			clients[cli] = true
		case cli:= <-leaving:
			delete(clients, cli)
			close(cli)
		}
	}
}
```

Горутина широковещателя прослушивает глобальные каналы `entering` и `leaving` в поисках объявлений о поступающих и
убывающих клиентах. Получив информацию об одном из этих событий, она обновляет множество `clients` и, если событие —
убытие клиента, закрывает канал исходящих сообщений клиента. Широковещатель также следит за событиями в глобальном
канале `messages`, в который каждый клиент отправляет все входящие сообщения. Широковещатель, получив одно из этих
событий, передает сообщение каждому подключенному клиенту.

Теперь давайте рассмотрим горутину каждого клиента. Функция `handleConn` создает новый канал исходящих сообщений
для своего клиента и объявляет широковещателю о поступлении этого клиента по каналу `entering`. Затем она считывает
каждую строку текста от клиента, отправляя каждую строку широковещателю по глобальному каналу входящих сообщений и
предваряя каждое сообщение указанием отправителя. Когда от клиента получена вся информация, `handleConn` объявляет об
убытии клиента по каналу `leaving` и закрывает подключение.

``` go
func handleConn(conn net.Conn)  {
	ch := make(chan string) // Исходящие сообщения клиентов
	go clientWriter(conn, ch)
	
	who := conn.RemoteAddr().String()
	ch <- "Вы " + who
	messages <- who + " подключился"
	entering <- ch
	
	input := bufio.NewScanner(conn)

	for input.Scan() {
		messages <- who + ": " + input.Text()
	}
	// Примечание: игнорируем потенциальные ошибки input.Err()
	
	leaving <- ch
	messages <- who + " отключился"
	conn.Close()
}

func clientWriter(conn net.Conn, ch <-chan string) {
	for msg := range ch {
		fmt.Fprintf(conn, msg) // Примечание: игнорируем ошибки сети
	}
}
```

Кроме того, `handleConn` создает горутину `clientWriter` для каждого клиента, которая получает широковещательные
сообщения по исходящему каналу клиента и записывает их в сетевое подключение клиента. Цикл завершается, когда
широковещатель закрывает канал после получения уведомления `leaving`.
Приведенный ниже вывод показывает сервер в действии с двумя клиентами в отдельных окнах на одном и том же компьютере с
использованием `netcat` для чата:

``` shell
$ go build gopl.io/ch8/chat 
$ go build gopl.io/ch8/netcat3 
$ ./chat &

$ ./netcat3 
Вы 127.0.0.1:64208
127.0.0.1:64211 подключился Привет!
127.0.0.1:64208: Привет!
127.0.0.1:64211: И вам привет.
^C

$ ./netcat3 
Вы 127.0.0.1:64216
127.0.0.1:64211: Здравствуйте.
127.0.0.1:64211 отключился

./netcat3 
Вы 127.0.0.1:64211
127.0.0.1:64208: Привет!
И вам привет.
127.0.0.1:64211: И вам привет.
127.0.0.1:64208 отключился
127.0.0.1:64216 подключился Здравствуйте.
127.0.0.1:64211: Здравствуйте. 
^C
```

Во время сеанса чата для `n` клиентов эта программа запускает `2n + 2` параллельных сообщающихся между собой горутин,
но она не нуждается в явных операциях блокировки (раздел 9.2). Отображение `clients` ограничено одной широковещательной
горутиной, поэтому к нему **не может выполняться параллельный доступ**. Единственными переменными, которые
разделяются несколькими горутинами, являются **каналы** и **экземпляры**` net.Conn`, но и те, и другие являются
**безопасными с точки зрения параллелизма**. Более подробно о вопросах безопасности, ограничения и следствий из
совместного использования переменных горутинами мы поговорим в следующей главе.

## Выводы:

* В примере чат-сервера используются четыре вида горутин:  `main`, `broadcaster`, `handleConn` и `clientWriter`. Это
  позволяет организовать общение между несколькими пользователями и обрабатывать подключение и отключение клиентов;
* Главная горутина `main` отвечает за прослушивание входящих сетевых подключений от клиентов, а для каждого из них
  создается новая горутина `handleConn`, которая обрабатывает подключение клиента;
* Использование `select` в горутине `broadcaster` помогает организовать обработку различных видов сообщений от клиентов
  и событий подключения/отключения клиентов;
* Горутина `broadcaster` отвечает за широковещание сообщений от одного клиента ко всем остальным и обработку событий
  подключения/отключения клиентов;
* Горутина `handleConn` отвечает за создание нового канала исходящих сообщений для клиента, считывание текста от клиента
  и отправку сообщений широковещателю;
* Горутина `clientWriter` отвечает за отправку широковещательных сообщений клиентам;
* Использование переменных, **безопасных с точки зрения параллелизма**, таких как каналы и экземпляры `net.Conn`,
  исключает необходимость явных операций блокировки.