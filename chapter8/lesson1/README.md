# 8.1 Горутины

В Go каждая одновременно выполняющаяся задача называется `go-подпрограммой (goroutine)`. Рассмотрим программу, в которой
есть две функции, одна из которых выполняет некоторые вычисления, а вторая записывает некоторые выходные данные, и
предположим, что ни одна из них не вызывает другую. Последовательная программа может вызвать одну функцию, а затем
вторую, но в параллельной программе с двумя или более `горутинами` вызовы обеих функций могут быть активны в одно и
то же время. Мы вскоре увидим такую программу.

Если вы использовали потоки операционной системы или потоки в других языках, то пока можете считать, что горутина
схожа с потоком, и сразу же писать корректные параллельные программы. Различия между `потоками` и `горутинами` по
существу `количественные`, а `не качественные`, и описаны в разделе 9.8.

При запуске программы ее единственной `горутиной` является та, которая вызывает функцию `main`, поэтому мы называем
ее главной `горутиной`. Новые `горутины` создаются с помощью инструкции `go`. Синтаксически инструкция `go`
является вызовом обычной функции или метода, которому предшествует ключевое слово `go`. Инструкция `go` заставляет
функцию быть вызванной во вновь созданной `горутине`. Сама по себе инструкция `go` немедленно завершается:

``` go
f()    // Вызов f(); ожиданеи возврата из нее
go f() // Создание новой горутины, вызывающей f(); ожидания нет
```

В приведенном ниже примере главная `горутина` вычисляет **45-е число Фибоначчи**. Поскольку она использует **ужасно
неэффективный рекурсивный алгоритм**, время ее работы весьма значительно, и мы хотели бы предоставить пользователю
визуальное подтверждение того, что программа все еще работает, отображая анимированный текстовый элемент, представляющий
собой вращающийся отрезок (см. spinner.go).

``` go
func main() {
	go spinner(100 * time.Millisecond)
	const n = 45
	fibN := fib(n) // Медленное вычисление
	fmt.Printf("\rFibonacci(%d) - %d\n", n, fibN)
}

func spinner(delay time.Duration) {
	for {
		for _, r := range `-\|/` {
			fmt.Printf("\r%c", r)
			time.Sleep(delay)
		}
	}
}

func fib(x int) int {
	if x < 2 {
		return x
	}
	return fib(x-1) + fib(x-2)
}
```

После нескольких секунд анимации вызов `fib(45)` завершается, и функция main выводит свой результат:

`Fibonacci(45) = 1134903170`

После этого функция `main` завершается. Когда это происходит, все горутины `тут же прекращают выполнение`, и
программа завершает свою работу. Помимо возврата из функции `main` или выхода из программы, нет никакого программного
способа остановить `из одной горутины другую`, но, как мы увидим позже, есть `способы обмена` информацией с
`горутиной`, с помощью которых можно попросить `горутину` остановиться самостоятельно.

Обратите внимание, как программа выражена в виде `композиции двух автономных процессов`, анимации “пиктограммы” и
вычисления числа Фибоначчи. Каждый из них записан как отдельная функция, но обе они работают `одновременно`.

## Выводы:

* `Горутины` - это способ выполнения нескольких задач `одновременно` в Go, сходные с `потоками` в других языках, но
  более легковесные и эффективные;
* `Главная горутина` создается и выполняется автоматически при запуске программы, она вызывает функцию `main`;
* Для создания `новых горутин` используется инструкция `go`, за которой следует `вызов функции или метода`, который
  будет выполняться параллельно;
* `Горутины` прекращают выполнение, когда `главная горутина завершается` или когда **программа явно завершает свою
  работу**;
* **Нет прямых способов остановить одну** `горутину` **из другой**, но имеются **способы обмена информацией** между
  `горутинами`, с помощью которых можно попросить `горутину` **остановиться самостоятельно**;
* `Горутины` способствуют написанию **чистых, композитных программ**, состоящих из `автономных процессов`, **работающих
  одновременно**.
* `Композитная программа` - это программа, состоящая из `нескольких отдельных модулей или компонентов`, которые
  **взаимодействуют друг с другом для выполнения задачи целиком**. Каждый `компонент` может быть
  **автономным процессом**, который работает **одновременно с другими**. Это позволяет **более эффективно** использовать
  **ресурсы компьютера и ускоряет выполнение задачи**. Такой подход также **упрощает разработку и
  тестирование программы**, поскольку каждый `компонент` может быть разработан, проверен и оптимизирован **отдельно от
  других**. Использование `композитных программ` способствует написанию более **гибких и модульных приложений**, которые
  могут быть **проще поддерживать и расширять** в будущем.