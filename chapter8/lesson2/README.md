# 8.2 Пример: параллельный сервер часов

`Сети` — естественная область применения `параллелизма`, поскольку **серверы обычно обрабатывают много клиентских
подключений одновременно**, при этом **каждый клиент**, по существу, **независим от других**. В этом разделе мы
познакомимся с пакетом `net`, который предоставляет **компоненты для построения программ сетевых клиентов и серверов**,
сообщающихся посредством `TCP`, `UDP` или `сокетов Unix`. Пакет `net/http`, который мы уже использовали в книге,
является **надстройкой над функциями пакета** `net`.

Наш первый пример — `последовательный сервер часов`, который выводит текущее время клиенту один раз в секунду (см.
clock1.go):

``` go
func main() {
	listener, err := net.Listen("tcp", "localhost:8000")
	if err != nil {
		log.Fatal(err)
	}
	for {
		conn, err := listener.Accept()
		if err != nil {
			log.Print(err) // Например, обрыв соединения
			continue
		}
		handleConn(conn) // Обработка единственного подключения
	}
}

func handleConn(c net.Conn) {
	defer c.Close()
	for {
		_, err := io.WriteString(c, time.Now().Format("15:04:05\n"))
		if err != nil {
			return // Например, отключение клиента
		}
		time.Sleep(1 * time.Second)
	}
}
```

Функция `Listen` создает объект `net.Listener`, который **прослушивает входящие соединения на сетевом порту**, в данном
случае это `TCP-порт localhost:8000`. Метод `Accept` прослушивателя **блокируется до тех пор**, пока не будет сделан
**входящий запрос на подключение**, после чего `возвращает` объект `net.Conn`, представляющий соединение.

Функция `handleConn` обрабатывает одно полное клиентское соединение (больше одного не может в таком виде). Она в цикле
выводит клиенту текущее время, `time.Now()`. Поскольку `net.Conn` **соответствует интерфейсу** `io.Writer`, мы можем
осуществлять вывод непосредственно в него. Цикл завершается, когда выполнение записи не удается, например потому, что
клиент был отключен, и при этом `handleConn` закрывает свою сторону соединения с помощью `отложенного вызова Close` и
переходит в состояние ожидания очередного запроса на подключение.

Метод `time.Time.Format` предоставляет **способ форматирования значений даты и времени на основе примера**. Его
аргументом является **шаблон, указывающий способ форматирования времени**, в
частности — `Mon Jan 2 03:04:05РМ 2006 UTC0700`. Момент времени имеет **восемь компонентов (день недели, месяц, день
месяца и т.д.)**. В строке `Format` может появиться **любое их подмножество, в любом порядке и в различных форматах**;
выбранные компоненты даты и времени будут отображаться в выбранном формате. Здесь мы просто используем часы, минуты и
секунды времени. Пакет `time` определяет шаблоны для многих стандартных форматов времени, таких
как `time.RFC1123` (`RFC1123= "Mon, 02 Jan 2006 15:04:05 MST"`).
Такой же механизм используется и в **обратном направлении в ходе анализа строки времени** с помощью `time.Parse`.

Для подключения к серверу нам понадобится клиентская программа, такая как `nc (netcat)`, стандартная вспомогательная
программа для работы с сетевыми подключениями (в Unix):

``` shell
$ go build clock1 
$ ./clock1 &
$ nc localhost 8000 
13:58:54
13:58:55
13:58:56
^C
```

Клиент отображает время, отправляемое сервером каждую секунду до тех пор, пока мы не прервем работу клиента с помощью
комбинации клавиш `<Ctrl+C>`, которая в `Unix-системах` выводится оболочкой как `^С`. Если `nc` или `netcat` в вашей
системе не установлен, можно использовать `telnet` или простую Go-версию `netcat`, которая использует `net.Dial` для
подключения к ТСР-серверу (см. netcat1.go):

``` go
func main() {
	conn, err := net.Dial("tcp", "localhost:8000")
	if err != nil {
		log.Fatal(err)
	}
	defer conn.Close()
	mustCopy(os.Stdout, conn)
}

func mustCopy(dst io.Writer, src io.Reader) {
	if _, err := io.Copy(dst, src); err != nil {
		log.Fatal(err)
	}

}
```

Эта программа считывает данные из `подключения` и записывает их в с`тандартный поток вывода` до тех пор, пока не будет
достигнут **конец файла** или не произойдет **ошибка**. Функция `mustCopy` является **вспомогательной функцией**,
используемой в нескольких примерах данного раздела. Давайте теперь запустим два клиента одновременно на разных
терминалах, которые показаны столбцами слева и справа:

``` shell
$ go build /netcat1                              
$ ./netcat1                        $ ./netcat1
13:58:54 
13:58:55
13:58:56
^C
                                   13:58:54 
                                   13:58:55
                                   13:58:56
                                   ^C
$ killall clock1
```

Команда `killall` в `Unix` прекращает работу всех процессов с данным именем.

Второй клиент **вынужден ждать** завершения работы первого клиента, поскольку сервер является **последовательным**; он
занимается только **одним клиентом одновременно**. Внесем одно небольшое изменение для того, чтобы сделать сервер
параллельным: добавление ключевого слова `go` к вызову `handleConn` приводит к тому, что **каждый вызов осуществляется в
собственной** горутине (см. clock2.go):

``` go
for {
		conn, err := listener.Accept()
		if err != nil {
			log.Print(err) // Например, обрыв соединения
			continue
		}
		go handleConn(conn) // Параллельная обработка соединений
	}
```

Теперь получать значение времени могут несколько клиентов одновременно:

``` shell
$ go build /clock2 
$ ./clock2 &
$ go build /netcatl 
$ ./netcat1
14:02:54                            $ ./netcat1
14:02:55                            14:02:55
14:02:56                            14:02:56
14:02:57                            ^С
14:02:58
14:02:59                            $ ./netcat1		
14:03:00                            14:03:00
14:03:01                            14:03:01
^С                                  14:03:02
                                    ^С
$ killall clock2
```

## Выводы:

* Сети являются естественной областью применения параллелизма, так как серверы обычно **обрабатывают много** клиентских
  подключений **одновременно**;
* Пакет `net` предоставляет компоненты для **построения сетевых клиентов и серверов**, работающих
  посредством `TCP`, `UDP` или сокетов `Unix`. Пакет `net/http` является надстройкой над функциями пакета `net`;
* В качестве примера рассмотрен последовательный сервер часов, который выводит текущее время клиенту один раз в секунду;
* При создании сервера используются функция `net.Listen` для прослушивания входящих соединений и метод `Accept` для
  обработки входящих запросов на подключение (возвращает значение только в тот момент, когда устанавливается
  подключение);
* Функция `handleConn` обрабатывает одно клиентское соединение, в цикле выводит текущее время клиенту с использованием
  метода `time.Now().Format`;
* Для подключения к серверу можно использовать стандартную вспомогательную программу `nc (netcat)` или аналогичную
  Go-версию (`netcat1.go`);
* При использовании `последовательного сервера`, второй клиент **вынужден ждать завершения работы первого**, поскольку
  сервер обрабатывает только одно соединение за раз;
* Для создания `параллельного сервера`, можно добавить ключевое слово `go` перед вызовом функции `handleConn`, что
  позволит каждому вызову **осуществляться в собственной горутине и обрабатывать несколько клиентов одновременно**. 