# 8. Горутины и каналы

`Параллельное программирование`, выражение программы как композиции ряда автономных действий, никогда не было столь
важным, как сегодня. Веб-серверы одновременно обрабатывают запросы тысяч клиентов. Приложения на планшетах и в телефонах
визуализируют анимацию интерфейса пользователя и одновременно в фоновом режиме выполняют вычисления и сетевые запросы.
Даже традиционные пакетные задачи — чтение некоторых входных данных, выполнение вычислений и запись некоторых выходных
данных — используют параллелизм для того, чтобы скрыть задержки операций ввода-вывода и использовать множество
процессоров современного компьютера, количество которых с каждым годом растет все больше, в отличие от их скорости.

Go обеспечивает `два стиля` параллельного программирования. В этой главе представлены `go-подпрограммы (goroutines)` и
`каналы`, которые поддерживают `взаимодействующие последовательные процессы (communicating sequential processes — CSP)`,
`модель параллелизма`, в которой между `независимыми процессами (горутинами)` передаются значения, но переменные по
большей части ограничиваются `одним процессом`. В главе 9, "Параллельность и совместно используемые переменные"
охвачены некоторые аспекты более традиционной модели многопоточности с общей памятью, которая будет вам знакома, если
вы использовали потоки в других основных языках программирования. Там же описаны важные опасности и ловушки
параллельного программирования, в которые мы не будем углубляться в данной главе.

Несмотря на то, что поддержка параллелизма в Go является одной из его самых сильных сторон, рассмотрение параллельных
программ существенно труднее, чем последовательных, а приобретенная при последовательном программировании интуиция может
время от времени вводить в заблуждение. Если это ваша первая встреча с параллелизмом, мы рекомендуем потратить немного
дополнительного времени на серьезные размышления над приводимыми в этих двух главах примерами.

# Выводы к главе:

<!-- TOC -->

* [8.1. Go-подпрограммы](#81-go-подпрограммы)
* [8.2. Пример: параллельный сервер часов](#82-пример-параллельный-сервер-часов)
* [8.3. Пример: параллельный эхо-сервер](#83-пример-параллельный-эхо-сервер)
* [8.4. Каналы](#84-каналы)
	* [8.4.1 Небуферизованные каналы](#841-небуферизованные-каналы)
	* [8.4.2 Конвейеры](#842-конвейеры)
	* [8.4.3 Однонаправленные каналы](#843-однонаправленные-каналы)
	* [8.4.4 Буферизованные каналы](#844-буферизованные-каналы)
* [8.5. Параллельные циклы](#85-параллельные-циклы)
* [8.6. Пример: параллельный веб-сканер](#86-пример-параллельный-веб-сканер)
* [8.7. Мультиплексирование с помощью select](#87-мультиплексирование-с-помощью-select)
* [8.8. Пример: параллельный обход каталога](#88-пример-параллельный-обход-каталога)
* [8.9. Отмена](#89-отмена)
* [8.10. Пример: чат-сервер](#810-пример-чат-сервер)

<!-- TOC -->
____

# 8.1. Go-подпрограммы

* `Горутины` - это способ выполнения нескольких задач `одновременно` в Go, сходные с `потоками` в других языках, но
  более легковесные и эффективные;
* `Главная горутина` создается и выполняется автоматически при запуске программы, она вызывает функцию `main`;
* Для создания `новых горутин` используется инструкция `go`, за которой следует `вызов функции или метода`, который
  будет выполняться параллельно;
* `Горутины` прекращают выполнение, когда `главная горутина завершается` или когда **программа явно завершает свою
  работу**;
* **Нет прямых способов остановить одну** `горутину` **из другой**, но имеются **способы обмена информацией** между
  `горутинами`, с помощью которых можно попросить `горутину` **остановиться самостоятельно**;
* `Горутины` способствуют написанию **чистых, композитных программ**, состоящих из `автономных процессов`, **работающих
  одновременно**.
* `Композитная программа` - это программа, состоящая из `нескольких отдельных модулей или компонентов`, которые
  **взаимодействуют друг с другом для выполнения задачи целиком**. Каждый `компонент` может быть
  **автономным процессом**, который работает **одновременно с другими**. Это позволяет **более эффективно** использовать
  **ресурсы компьютера и ускоряет выполнение задачи**. Такой подход также **упрощает разработку и
  тестирование программы**, поскольку каждый `компонент` может быть разработан, проверен и оптимизирован **отдельно от
  других**. Использование `композитных программ` способствует написанию более **гибких и модульных приложений**, которые
  могут быть **проще поддерживать и расширять** в будущем.

____

# 8.2. Пример: параллельный сервер часов

* Сети являются естественной областью применения параллелизма, так как серверы обычно **обрабатывают много** клиентских
  подключений **одновременно**;
* Пакет `net` предоставляет компоненты для **построения сетевых клиентов и серверов**, работающих
  посредством `TCP`, `UDP` или сокетов `Unix`. Пакет `net/http` является надстройкой над функциями пакета `net`;
* В качестве примера рассмотрен последовательный сервер часов, который выводит текущее время клиенту один раз в секунду;
* При создании сервера используются функция `net.Listen` для прослушивания входящих соединений и метод `Accept` для
  обработки входящих запросов на подключение (возвращает значение только в тот момент, когда устанавливается
  подключение);
* Функция `handleConn` обрабатывает одно клиентское соединение, в цикле выводит текущее время клиенту с использованием
  метода `time.Now().Format`;
* Для подключения к серверу можно использовать стандартную вспомогательную программу `nc (netcat)` или аналогичную
  Go-версию (`netcat1.go`);
* При использовании `последовательного сервера`, второй клиент **вынужден ждать завершения работы первого**, поскольку
  сервер обрабатывает только одно соединение за раз;
* Для создания `параллельного сервера`, можно добавить ключевое слово `go` перед вызовом функции `handleConn`, что
  позволит каждому вызову **осуществляться в собственной горутине и обрабатывать несколько клиентов одновременно**.

____

# 8.3. Пример: параллельный эхо-сервер

____

# 8.4. Каналы

____

# 8.4.1 Небуферизованные каналы

____

# 8.4.2 Конвейеры

____

# 8.4.3 Однонаправленные каналы

____

# 8.4.4 Буферизованные каналы

____

# 8.5. Параллельные циклы

____

# 8.6. Пример: параллельный веб-сканер

____

# 8.7. Мультиплексирование с помощью select

____

# 8.8. Пример: параллельный обход каталога

____

# 8.9. Отмена

____

# 8.10. Пример: чат-сервер

____