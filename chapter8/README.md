# 8. Горутины и каналы

`Параллельное программирование`, выражение программы как композиции ряда автономных действий, никогда не было столь
важным, как сегодня. Веб-серверы одновременно обрабатывают запросы тысяч клиентов. Приложения на планшетах и в телефонах
визуализируют анимацию интерфейса пользователя и одновременно в фоновом режиме выполняют вычисления и сетевые запросы.
Даже традиционные пакетные задачи — чтение некоторых входных данных, выполнение вычислений и запись некоторых выходных
данных — используют параллелизм для того, чтобы скрыть задержки операций ввода-вывода и использовать множество
процессоров современного компьютера, количество которых с каждым годом растет все больше, в отличие от их скорости.

Go обеспечивает `два стиля` параллельного программирования. В этой главе представлены `go-подпрограммы (goroutines)` и
`каналы`, которые поддерживают `взаимодействующие последовательные процессы (communicating sequential processes — CSP)`,
`модель параллелизма`, в которой между `независимыми процессами (горутинами)` передаются значения, но переменные по
большей части ограничиваются `одним процессом`. В главе 9, "Параллельность и совместно используемые переменные"
охвачены некоторые аспекты более традиционной модели многопоточности с общей памятью, которая будет вам знакома, если
вы использовали потоки в других основных языках программирования. Там же описаны важные опасности и ловушки
параллельного программирования, в которые мы не будем углубляться в данной главе.

Несмотря на то, что поддержка параллелизма в Go является одной из его самых сильных сторон, рассмотрение параллельных
программ существенно труднее, чем последовательных, а приобретенная при последовательном программировании интуиция может
время от времени вводить в заблуждение. Если это ваша первая встреча с параллелизмом, мы рекомендуем потратить немного
дополнительного времени на серьезные размышления над приводимыми в этих двух главах примерами.

# Выводы к главе:

<!-- TOC -->

* [8.1. Go-подпрограммы](#81-go-подпрограммы)
* [8.2. Пример: параллельный сервер часов](#82-пример-параллельный-сервер-часов)
* [8.3. Пример: параллельный эхо-сервер](#83-пример-параллельный-эхо-сервер)
* [8.4. Каналы](#84-каналы)
	* [8.4.1 Небуферизованные каналы](#841-небуферизованные-каналы)
	* [8.4.2 Конвейеры](#842-конвейеры)
	* [8.4.3 Однонаправленные каналы](#843-однонаправленные-каналы)
	* [8.4.4 Буферизованные каналы](#844-буферизованные-каналы)
* [8.5. Параллельные циклы](#85-параллельные-циклы)
* [8.6. Пример: параллельный веб-сканер](#86-пример-параллельный-веб-сканер)
* [8.7. Мультиплексирование с помощью select](#87-мультиплексирование-с-помощью-select)
* [8.8. Пример: параллельный обход каталога](#88-пример-параллельный-обход-каталога)
* [8.9. Отмена](#89-отмена)
* [8.10. Пример: чат-сервер](#810-пример-чат-сервер)

<!-- TOC -->
____

# 8.1. Go-подпрограммы

* `Горутины` - это способ выполнения нескольких задач `одновременно` в Go, сходные с `потоками` в других языках, но
  более легковесные и эффективные;
* `Главная горутина` создается и выполняется автоматически при запуске программы, она вызывает функцию `main`;
* Для создания `новых горутин` используется инструкция `go`, за которой следует `вызов функции или метода`, который
  будет выполняться параллельно;
* `Горутины` прекращают выполнение, когда `главная горутина завершается` или когда **программа явно завершает свою
  работу**;
* **Нет прямых способов остановить одну** `горутину` **из другой**, но имеются **способы обмена информацией** между
  `горутинами`, с помощью которых можно попросить `горутину` **остановиться самостоятельно**;
* `Горутины` способствуют написанию **чистых, композитных программ**, состоящих из `автономных процессов`, **работающих
  одновременно**.
* `Композитная программа` - это программа, состоящая из `нескольких отдельных модулей или компонентов`, которые
  **взаимодействуют друг с другом для выполнения задачи целиком**. Каждый `компонент` может быть
  **автономным процессом**, который работает **одновременно с другими**. Это позволяет **более эффективно** использовать
  **ресурсы компьютера и ускоряет выполнение задачи**. Такой подход также **упрощает разработку и
  тестирование программы**, поскольку каждый `компонент` может быть разработан, проверен и оптимизирован **отдельно от
  других**. Использование `композитных программ` способствует написанию более **гибких и модульных приложений**, которые
  могут быть **проще поддерживать и расширять** в будущем.

____

# 8.2. Пример: параллельный сервер часов

* Сети являются естественной областью применения параллелизма, так как серверы обычно **обрабатывают много** клиентских
  подключений **одновременно**;
* Пакет `net` предоставляет компоненты для **построения сетевых клиентов и серверов**, работающих
  посредством `TCP`, `UDP` или сокетов `Unix`. Пакет `net/http` является надстройкой над функциями пакета `net`;
* В качестве примера рассмотрен последовательный сервер часов, который выводит текущее время клиенту один раз в секунду;
* При создании сервера используются функция `net.Listen` для прослушивания входящих соединений и метод `Accept` для
  обработки входящих запросов на подключение (возвращает значение только в тот момент, когда устанавливается
  подключение);
* Функция `handleConn` обрабатывает одно клиентское соединение, в цикле выводит текущее время клиенту с использованием
  метода `time.Now().Format`;
* Для подключения к серверу можно использовать стандартную вспомогательную программу `nc (netcat)` или аналогичную
  Go-версию (`netcat1.go`);
* При использовании `последовательного сервера`, второй клиент **вынужден ждать завершения работы первого**, поскольку
  сервер обрабатывает только одно соединение за раз;
* Для создания `параллельного сервера`, можно добавить ключевое слово `go` перед вызовом функции `handleConn`, что
  позволит каждому вызову **осуществляться в собственной горутине и обрабатывать несколько клиентов одновременно**.

____

# 8.3. Пример: параллельный эхо-сервер

* Горутины в Golang позволяют выполнять параллельные вычисления в одном соединении;
* Добавление ключевого слова go перед вызовом функции echo позволяет горутинам работать параллельно и обрабатывать
  запросы одновременно;
* Использование горутин позволяет параллельно отправлять сообщения на сервер и выводить ответ сервера на экран;
  ``` go
  go mustCopy(os.Stdout, conn)
  mustCopy(conn, os.Stdin)
  ```
* Важно убедиться, что одновременные вызовы методов объектов языка Golang безопасны, для чего необходимо обеспечить
  безопасность параллелизма.

____

# 8.4. Каналы

* Горутины представляют собой `процессы` в рамках параллельной программы Go, а каналы
  являются `соединениями между ними`;
* `Канал` представляет собой механизм связи, который позволяет **одной горутине отправлять значения другой горутине**;
* Каждый канал имеет `тип элементов канала`, записывается как `chan <тип_элементов>`, например `chan int`;
* Канал создается с использованием встроенной функции `make`. Пример: `ch := make(chan int)`;
* Копируя канал или передавая его функции в качестве аргумента, копируется `ссылка` на структуру данных;
* Каналы поддерживают три операции: `отправление`, `получение` и `закрытие` канала;
* Отправление значения через канал: `ch <- value`; пример:` ch <- 3`;
* Получение значения из канала: `value = <-ch`; пример: `x := <-ch`;
* Закрытие канала с помощью встроенной функции `close`: `close(ch)`;
* Каналы могут быть `небуферизованными` (не иметь емкости) или `буферизованными` (иметь емкость). Создание
  буферизованного канала: `ch = make(chan int, 3)`;
* Небуферизованные каналы `блокируют отправляющую горутину` до тех пор, пока получающая горутина не заберет значение.
  Буферизованные каналы `имеют очередь для хранения значений` до получения их другими горутинами.

____

# 8.4.1 Небуферизованные каналы

* Операция отправления в небуферизованный канал блокирует горутину до тех пор, пока другая горутина не выполнит
  соответствующее получение из того же канала; это обеспечивает синхронизацию отправления и получения данных между
  горутинами. Пример:
  ``` go
  ch := make(chan int)
  go func() {
    ch <- 42 // Отправление значения в канал; горутина блокируется, пока другая горутина не выполнит получение
  }()
  val := <-ch // Получение значения из канала; обе горутины продолжают работу
  ```
* Небуферизованные каналы иногда называют `синхронными`, поскольку они обеспечивают синхронизацию операций отправления и
  получения. Это может быть полезно для упорядочивания выполнения горутин и избегания проблем с параллельным доступом к
  переменным;
* Если нужно передать событие без значения, можно использовать канал с типом элементов `struct{}`; это подчеркивает, что
  важен только факт передачи сообщения. Пример:
  ``` go
  done := make(chan struct{})
  go func() {
      // Работа в фоновой горутине
      done <- struct{}{} // Сигнал главной горутине об окончании работы
  }()
  <-done // Ожидание завершения фоновой горутины
  ```
* Использование каналов для синхронизации горутин обеспечивает явное взаимодействие и гарантирует, что определенные
  действия завершены до продолжения работы других горутин; это помогает избежать ошибок, связанных с параллельным
  доступом к общим данным и состоянию.

* При реализации клиент-серверной связи с использованием горутин и каналов важно использовать синхронизацию для
  корректного завершения работы программы и предотвращения потери данных. Пример кода:
  ``` go
  func main() {
    conn, err := net.Dial("tcp", "localhost:8000")
    if err != nil {
        log.Fatal(err)
    }
    done := make(chan struct{})
    go func() {
        io.Copy(os.Stdout, conn) // Примечание: игнорируем ошибки
        log.Println("done")
        done <- struct{}{} // Сигнал главной горутине
    }()
    mustCopy(conn, os.Stdin)
    conn.Close()
    <-done // Ожидание завершения фоновой горутины
  }
  ```

____

# 8.4.2 Конвейеры

____

# 8.4.3 Однонаправленные каналы

____

# 8.4.4 Буферизованные каналы

____

# 8.5. Параллельные циклы

____

# 8.6. Пример: параллельный веб-сканер

____

# 8.7. Мультиплексирование с помощью select

____

# 8.8. Пример: параллельный обход каталога

____

# 8.9. Отмена

____

# 8.10. Пример: чат-сервер

____