# 8. Горутины и каналы

`Параллельное программирование`, выражение программы как композиции ряда автономных действий, никогда не было столь
важным, как сегодня. Веб-серверы одновременно обрабатывают запросы тысяч клиентов. Приложения на планшетах и в телефонах
визуализируют анимацию интерфейса пользователя и одновременно в фоновом режиме выполняют вычисления и сетевые запросы.
Даже традиционные пакетные задачи — чтение некоторых входных данных, выполнение вычислений и запись некоторых выходных
данных — используют параллелизм для того, чтобы скрыть задержки операций ввода-вывода и использовать множество
процессоров современного компьютера, количество которых с каждым годом растет все больше, в отличие от их скорости.

Go обеспечивает `два стиля` параллельного программирования. В этой главе представлены `go-подпрограммы (goroutines)` и
`каналы`, которые поддерживают `взаимодействующие последовательные процессы (communicating sequential processes — CSP)`,
`модель параллелизма`, в которой между `независимыми процессами (горутинами)` передаются значения, но переменные по
большей части ограничиваются `одним процессом`. В главе 9, "Параллельность и совместно используемые переменные"
охвачены некоторые аспекты более традиционной модели многопоточности с общей памятью, которая будет вам знакома, если
вы использовали потоки в других основных языках программирования. Там же описаны важные опасности и ловушки
параллельного программирования, в которые мы не будем углубляться в данной главе.

Несмотря на то, что поддержка параллелизма в Go является одной из его самых сильных сторон, рассмотрение параллельных
программ существенно труднее, чем последовательных, а приобретенная при последовательном программировании интуиция может
время от времени вводить в заблуждение. Если это ваша первая встреча с параллелизмом, мы рекомендуем потратить немного
дополнительного времени на серьезные размышления над приводимыми в этих двух главах примерами.

# Выводы к главе:

<!-- TOC -->

* [8.1. Go-подпрограммы](#81-go-подпрограммы)
* [8.2. Пример: параллельный сервер часов](#82-пример-параллельный-сервер-часов)
* [8.3. Пример: параллельный эхо-сервер](#83-пример-параллельный-эхо-сервер)
* [8.4. Каналы](#84-каналы)
	* [8.4.1 Небуферизованные каналы](#841-небуферизованные-каналы)
	* [8.4.2 Конвейеры](#842-конвейеры)
	* [8.4.3 Однонаправленные каналы](#843-однонаправленные-каналы)
	* [8.4.4 Буферизованные каналы](#844-буферизованные-каналы)
* [8.5. Параллельные циклы](#85-параллельные-циклы)
* [8.6. Пример: параллельный веб-сканер](#86-пример-параллельный-веб-сканер)
* [8.7. Мультиплексирование с помощью select](#87-мультиплексирование-с-помощью-select)
* [8.8. Пример: параллельный обход каталога](#88-пример-параллельный-обход-каталога)
* [8.9. Отмена](#89-отмена)
* [8.10. Пример: чат-сервер](#810-пример-чат-сервер)

<!-- TOC -->
____

# 8.1. Go-подпрограммы

* `Горутины` - это способ выполнения нескольких задач `одновременно` в Go, сходные с `потоками` в других языках, но
  более легковесные и эффективные;
* `Главная горутина` создается и выполняется автоматически при запуске программы, она вызывает функцию `main`;
* Для создания `новых горутин` используется инструкция `go`, за которой следует `вызов функции или метода`, который
  будет выполняться параллельно;
* `Горутины` прекращают выполнение, когда `главная горутина завершается` или когда **программа явно завершает свою
  работу**;
* **Нет прямых способов остановить одну** `горутину` **из другой**, но имеются **способы обмена информацией** между
  `горутинами`, с помощью которых можно попросить `горутину` **остановиться самостоятельно**;
* `Горутины` способствуют написанию **чистых, композитных программ**, состоящих из `автономных процессов`, **работающих
  одновременно**.
* `Композитная программа` - это программа, состоящая из `нескольких отдельных модулей или компонентов`, которые
  **взаимодействуют друг с другом для выполнения задачи целиком**. Каждый `компонент` может быть
  **автономным процессом**, который работает **одновременно с другими**. Это позволяет **более эффективно** использовать
  **ресурсы компьютера и ускоряет выполнение задачи**. Такой подход также **упрощает разработку и
  тестирование программы**, поскольку каждый `компонент` может быть разработан, проверен и оптимизирован **отдельно от
  других**. Использование `композитных программ` способствует написанию более **гибких и модульных приложений**, которые
  могут быть **проще поддерживать и расширять** в будущем.

____

# 8.2. Пример: параллельный сервер часов

* Сети являются естественной областью применения параллелизма, так как серверы обычно **обрабатывают много** клиентских
  подключений **одновременно**;
* Пакет `net` предоставляет компоненты для **построения сетевых клиентов и серверов**, работающих
  посредством `TCP`, `UDP` или сокетов `Unix`. Пакет `net/http` является надстройкой над функциями пакета `net`;
* В качестве примера рассмотрен последовательный сервер часов, который выводит текущее время клиенту один раз в секунду;
* При создании сервера используются функция `net.Listen` для прослушивания входящих соединений и метод `Accept` для
  обработки входящих запросов на подключение (возвращает значение только в тот момент, когда устанавливается
  подключение);
* Функция `handleConn` обрабатывает одно клиентское соединение, в цикле выводит текущее время клиенту с использованием
  метода `time.Now().Format`;
* Для подключения к серверу можно использовать стандартную вспомогательную программу `nc (netcat)` или аналогичную
  Go-версию (`netcat1.go`);
* При использовании `последовательного сервера`, второй клиент **вынужден ждать завершения работы первого**, поскольку
  сервер обрабатывает только одно соединение за раз;
* Для создания `параллельного сервера`, можно добавить ключевое слово `go` перед вызовом функции `handleConn`, что
  позволит каждому вызову **осуществляться в собственной горутине и обрабатывать несколько клиентов одновременно**.

____

# 8.3. Пример: параллельный эхо-сервер

* Горутины в Golang позволяют выполнять параллельные вычисления в одном соединении;
* Добавление ключевого слова go перед вызовом функции echo позволяет горутинам работать параллельно и обрабатывать
  запросы одновременно;
* Использование горутин позволяет параллельно отправлять сообщения на сервер и выводить ответ сервера на экран;
  ``` go
  go mustCopy(os.Stdout, conn)
  mustCopy(conn, os.Stdin)
  ```
* Важно убедиться, что одновременные вызовы методов объектов языка Golang безопасны, для чего необходимо обеспечить
  безопасность параллелизма.

____

# 8.4. Каналы

* Горутины представляют собой `процессы` в рамках параллельной программы Go, а каналы
  являются `соединениями между ними`;
* `Канал` представляет собой механизм связи, который позволяет **одной горутине отправлять значения другой горутине**;
* Каждый канал имеет `тип элементов канала`, записывается как `chan <тип_элементов>`, например `chan int`;
* Канал создается с использованием встроенной функции `make`. Пример: `ch := make(chan int)`;
* Копируя канал или передавая его функции в качестве аргумента, копируется `ссылка` на структуру данных;
* Каналы поддерживают три операции: `отправление`, `получение` и `закрытие` канала;
* Отправление значения через канал: `ch <- value`; пример:` ch <- 3`;
* Получение значения из канала: `value = <-ch`; пример: `x := <-ch`;
* Закрытие канала с помощью встроенной функции `close`: `close(ch)`;
* Каналы могут быть `небуферизованными` (не иметь емкости) или `буферизованными` (иметь емкость). Создание
  буферизованного канала: `ch = make(chan int, 3)`;
* Небуферизованные каналы `блокируют отправляющую горутину` до тех пор, пока получающая горутина не заберет значение.
  Буферизованные каналы `имеют очередь для хранения значений` до получения их другими горутинами.

____

# 8.4.1 Небуферизованные каналы

* Операция отправления в небуферизованный канал блокирует горутину до тех пор, пока другая горутина не выполнит
  соответствующее получение из того же канала; это обеспечивает синхронизацию отправления и получения данных между
  горутинами. Пример:
  ``` go
  ch := make(chan int)
  go func() {
    ch <- 42 // Отправление значения в канал; горутина блокируется, пока другая горутина не выполнит получение
  }()
  val := <-ch // Получение значения из канала; обе горутины продолжают работу
  ```
* Небуферизованные каналы иногда называют `синхронными`, поскольку они обеспечивают синхронизацию операций отправления и
  получения. Это может быть полезно для упорядочивания выполнения горутин и избегания проблем с параллельным доступом к
  переменным;
* Если нужно передать событие без значения, можно использовать канал с типом элементов `struct{}`; это подчеркивает, что
  важен только факт передачи сообщения. Пример:
  ``` go
  done := make(chan struct{})
  go func() {
      // Работа в фоновой горутине
      done <- struct{}{} // Сигнал главной горутине об окончании работы
  }()
  <-done // Ожидание завершения фоновой горутины
  ```
* Использование каналов для синхронизации горутин обеспечивает явное взаимодействие и гарантирует, что определенные
  действия завершены до продолжения работы других горутин; это помогает избежать ошибок, связанных с параллельным
  доступом к общим данным и состоянию.

* При реализации клиент-серверной связи с использованием горутин и каналов важно использовать синхронизацию для
  корректного завершения работы программы и предотвращения потери данных. Пример кода:
  ``` go
  func main() {
    conn, err := net.Dial("tcp", "localhost:8000")
    if err != nil {
        log.Fatal(err)
    }
    done := make(chan struct{})
    go func() {
        io.Copy(os.Stdout, conn) // Примечание: игнорируем ошибки
        log.Println("done")
        done <- struct{}{} // Сигнал главной горутине
    }()
    mustCopy(conn, os.Stdin)
    conn.Close()
    <-done // Ожидание завершения фоновой горутины
  }
  ```

____

# 8.4.2 Конвейеры

* `Конвейер (pipeline)` в Go - это способ подключения горутин друг к другу с использованием каналов так, чтобы выход
  одной горутины становился входом для другой;
* Закрытие каналов при помощи функции `Close` используется для сообщения получающей горутине о том, что больше не будет
  отправляться значений;
* После закрытия канала, все последующие операции отправления вызовут **панику**, а операции получения будут возвращать
  **нулевые значения** без блокировки;
* Для определения закрытия канала используется вариант операции получения с двумя результатами: **полученный элемент** и
  **логическое значение** `ok` , которое равно `true`, если получено значение, и `false`, если канал закрыт и опустошен:
  ``` go
  x, ok := <-naturals
    if !ok {
      break // Канал закрыт и опустошен
    }
  ```
* Цикл по диапазону используется для получения всех значений из канала и автоматического завершения работы после
  получения последнего значения:
  ``` go
  for x := range naturals {
      squares <- x * x
    }
  ```
* Закрытие каналов не обязательно после завершения работы с ними, но используется при необходимости сообщить принимающей
  горутине о завершении отправки значений;
* Попытка закрыть уже закрытый или нулевой канал вызывает панику;
* Закрытие каналов может использоваться как механизм оповещения о завершении работы.

____

# 8.4.3 Однонаправленные каналы

* Каналы в Go могут быть `двунаправленными` (для отправления и получения данных) или `однонаправленными` (только для
  отправления или только для получения данных);
  ``` go
  chan int   // двунаправленный канал
  chan<- int // канал только для отправления данных
  <-chan int // канал только для получения данных 
  ```
* Однонаправленные каналы используются для документирования намерений разработчика и предотвращения неправильного
  использования каналов в функциях, ограничения доступа к каналам только для чтения или только для записи, что может
  повысить безопасность, уменьшить сложность кода и улучшить производительность в некоторых случаях.
* Положение стрелки `<-` относительно ключевого слова `chan` является мнемоническим. Нарушения использования
  однонаправленных каналов обнаруживаются на этапе компиляции, что позволяет предотвратить ошибки в реализации функций;
* Операция `Close` для каналов должна вызываться только отправляющей горутиной, потому что она утверждает, что больше не
  будет отправления данных в канал. Попытка закрыть канал только для получения приводит к ошибке времени компиляции;
* Двунаправленные каналы могут быть неявно преобразованы в однонаправленные, но обратное преобразование невозможно;

  ``` go
  naturals := make(chan int)
  go counter(naturals) // naturals преобразуется в chan<- int
  go printer(squares) // squares преобразуется в <-chan int
  ```

* Использование однонаправленных каналов и правильная организация горутин позволяют создавать четкую и понятную
  структуру программы, что улучшает ее читаемость и облегчает поддержку.

____

# 8.4.4 Буферизованные каналы

* Буферизованный канал имеет очередь элементов, максимальный размер которой определяется аргументом capacity функции
  make ; это позволяет хранить определенное количество элементов в канале, а не только одно значение, как в
  небуферизованных каналах. Пример создания буферизованного канала с емкостью 3:
  ``` go
  ch := make(chan string, 3)
  ```
* Операция отправления в буферизованный канал вставляет отправляемый элемент в конец очереди, а операция получения
  удаляет первый элемент из очереди; если канал заполнен, операция отправления блокирует горутину, и наоборот, если
  канал пуст, операция получения блокирует горутину. Это обеспечивает синхронизацию между горутинами, работающими с
  каналом;
* Встроенная функция `cap` позволяет получить емкость буфера канала, а функция `len` возвращает количество элементов,
  находящихся в настоящее время в буфере. Их использование может быть полезно для оптимизации производительности или при
  отладке:

  ``` go
  fmt.Println(cap(ch)) // 3
  fmt.Println(len(ch)) // 2 
  ```

* Не рекомендуется использовать буферизованные каналы в пределах одной горутины в качестве очереди, так как каналы
  глубоко связаны с планированием горутин и могут привести к блокировке всей программы; вместо этого используйте срезы
  для создания простой очереди;
* Буферизованные каналы могут быть использованы для ускорения обработки параллельных запросов, как в примере функции
  `mirroredQuery`, которая отправляет запросы на три сервера и возвращает результат самого быстрого первого ответа,
  игнорируя остальные медленные результаты;
* Важно предотвратить утечки горутин, так как, в отличие от переменных, они не собираются сборщиком мусора
  автоматически; нужно гарантировать, что горутины прекратятся, когда они больше не нужны, особенно когда происходит
  работа с буферизованными каналами;
* Выбор между буферизованными и небуферизованными каналами влияет на корректность работы программы; небуферизованные
  каналы обеспечивают более надежную синхронизацию, так как каждая операция отправления синхронизируется с
  соответствующей операцией получения. В случае буферизованных каналов эти операции разделены;
* В некоторых случаях можно создавать буферизованный канал определенного размера и совершать все отправления значений до
  получения первого значения из канала, особенно когда заранее известна верхняя граница отправляемых значений;
* Буферизация каналов может повышать производительность программы, если операции, выполняемые разными горутинами,
  требуют разного времени на выполнение. Буферы позволяют сглаживать временные различия и обеспечивают более плавное
  выполнение программы;
* Буферизация каналов может быть неэффективной, если одна стадия выполнения работает быстрее другой, и буфер большую
  часть времени либо заполняется, либо остается пустым;
* Если определенная стадия выполнения программы сильно сложнее и медленнее остальных, можно использовать дополнительные
  горутины для выполнения этой стадии. Это позволяет более равномерно распределить нагрузку и повысить
  производительность программы.
* Примеры:

1. Небуферизованный канал:

  ``` go 
  ch := make(chan int)
  ```

2. Буферизованный канал:

``` go
 ch := make(chan int, 5)
```

3. Отправка и получение данных через канал в разных горутинах:

``` go
go func() {
    ch <- someValue
}()
 go func() {
    receivedValue := <-ch
}()
```

____

# 8.5. Параллельные циклы

* При работе с параллельными циклами в Golang можно использовать `горутины` для выполнения независимых операций в
  параллельных потоках, что увеличивает производительность и эффективность программы; `go func()`
* В задачах с `чрезвычайной параллельностью`, **когда все подзадачи полностью независимы друг от друга**, можно
  реализовать параллельное выполнение и получить линейное увеличение производительности с увеличением
  степени параллелизма;
* Для ожидания завершения горутины можно использовать `канал`, в который каждая горутина отправляет `событие` о своем
  завершении, а `главная горутина` подсчитывает количество полученных событий и завершается после обработки всех
  подзадач; `var ch = make(chan struct{}); /*...*/ ch <- struct{}{}` в горутине;
* При использовании `анонимных функций внутри цикла` стоит быть осторожным с захватом переменных цикла и передавать их
  как `явные аргументы функции`, чтобы избежать ошибок и неожиданного поведения программы;
   ``` go
    var i = make(chan int)
    for j:=0; j<10; j++ {
      go func(a int) {
        i <- a * 2
      }(j)
    }
    ```
* Если нужно возвращать значения от рабочих горутин в главную горутину, можно использовать `каналы` для передачи
  результатов или ошибок;
* Важно избегать утечек горутин, когда горутина `навсегда заблокирована` **в ожидании отправки значения в канал**, так
  как это может привести к остановке программы или нехватке памяти, для этого рекомендуется
  использовать `буферизованные каналы` с достаточной емкостью, что предотвращает блокировку рабочих горутин при отправке
  сообщений;
* Использование типа `sync.WaitGroup` позволяет обеспечить безопасное ожидание завершения работы
  **всех горутин перед закрытием канала**, а также позволяет работать с `переменной-счетчиком`, доступной для нескольких
  горутин одновременно;
  ``` go
  var wg sync.WaitGroup
  ```
* Для корректного использования `sync.WaitGroup` следует вызывать метод `Add` **перед началом рабочей горутины**, а
  метод `Done` (или `Add(-1)`) **внутри рабочей горутины**, что гарантирует правильное состояние счетчика в процессе
  работы программы;
* Использование оператора `defer` внутри рабочей горутины с методом `Done()` обеспечивает **уменьшение значения счетчика
  и завершение работы горутины даже в случае возникновения ошибки**;
* Создание параллельной горутины для ожидания завершения всех рабочих горутин и последующем закрытии канала обеспечивает
  правильное выполнение программы без блокировок и зависаний;
  ``` go
  // Ожидание счетчика
  go func() {
      wg.Wait()
      close(sizes)
  }() 
  ```
* При использовании параллельных циклов в Go стоит следить за **последовательностью вызовов и взаимодействиями между
  горутинами и счетчиками**, что позволит предотвратить возможные блокировки, ошибки или некорректное выполнение
  программы;
* Польза использования параллельных циклов заключается в **улучшении производительности программы, эффективном
  использовании ресурсов и возможности обеспечения безопасной работы** с общими переменными при помощи каналов и
  синхронизации работы горутин.

____

# 8.6. Пример: параллельный веб-сканер

____

# 8.7. Мультиплексирование с помощью select

____

# 8.8. Пример: параллельный обход каталога

____

# 8.9. Отмена

____

# 8.10. Пример: чат-сервер

____