# 8. Горутины и каналы

`Параллельное программирование`, выражение программы как композиции ряда автономных действий, никогда не было столь
важным, как сегодня. Веб-серверы одновременно обрабатывают запросы тысяч клиентов. Приложения на планшетах и в телефонах
визуализируют анимацию интерфейса пользователя и одновременно в фоновом режиме выполняют вычисления и сетевые запросы.
Даже традиционные пакетные задачи — чтение некоторых входных данных, выполнение вычислений и запись некоторых выходных
данных — используют параллелизм для того, чтобы скрыть задержки операций ввода-вывода и использовать множество
процессоров современного компьютера, количество которых с каждым годом растет все больше, в отличие от их скорости.

Go обеспечивает `два стиля` параллельного программирования. В этой главе представлены `go-подпрограммы (goroutines)` и
`каналы`, которые поддерживают `взаимодействующие последовательные процессы (communicating sequential processes — CSP)`,
`модель параллелизма`, в которой между `независимыми процессами (горутинами)` передаются значения, но переменные по
большей части ограничиваются `одним процессом`. В главе 9, "Параллельность и совместно используемые переменные"
охвачены некоторые аспекты более традиционной модели многопоточности с общей памятью, которая будет вам знакома, если
вы использовали потоки в других основных языках программирования. Там же описаны важные опасности и ловушки
параллельного программирования, в которые мы не будем углубляться в данной главе.

Несмотря на то, что поддержка параллелизма в Go является одной из его самых сильных сторон, рассмотрение параллельных
программ существенно труднее, чем последовательных, а приобретенная при последовательном программировании интуиция может
время от времени вводить в заблуждение. Если это ваша первая встреча с параллелизмом, мы рекомендуем потратить немного
дополнительного времени на серьезные размышления над приводимыми в этих двух главах примерами.

# Выводы к главе:

<!-- TOC -->

* [8.1. Go-подпрограммы](#81-go-подпрограммы)
* [8.2. Пример: параллельный сервер часов](#82-пример-параллельный-сервер-часов)
* [8.3. Пример: параллельный эхо-сервер](#83-пример-параллельный-эхо-сервер)
* [8.4. Каналы](#84-каналы)
	* [8.4.1 Небуферизованные каналы](#841-небуферизованные-каналы)
	* [8.4.2 Конвейеры](#842-конвейеры)
	* [8.4.3 Однонаправленные каналы](#843-однонаправленные-каналы)
	* [8.4.4 Буферизованные каналы](#844-буферизованные-каналы)
* [8.5. Параллельные циклы](#85-параллельные-циклы)
* [8.6. Пример: параллельный веб-сканер](#86-пример-параллельный-веб-сканер)
* [8.7. Мультиплексирование с помощью select](#87-мультиплексирование-с-помощью-select)
* [8.8. Пример: параллельный обход каталога](#88-пример-параллельный-обход-каталога)
* [8.9. Отмена](#89-отмена)
* [8.10. Пример: чат-сервер](#810-пример-чат-сервер)

<!-- TOC -->
____

# 8.1. Go-подпрограммы

* `Горутины` - это способ выполнения нескольких задач `одновременно` в Go, сходные с `потоками` в других языках, но
  более легковесные и эффективные;
* `Главная горутина` создается и выполняется автоматически при запуске программы, она вызывает функцию `main`;
* Для создания `новых горутин` используется инструкция `go`, за которой следует `вызов функции или метода`, который
  будет выполняться параллельно;
* `Горутины` прекращают выполнение, когда `главная горутина завершается` или когда **программа явно завершает свою
  работу**;
* **Нет прямых способов остановить одну** `горутину` **из другой**, но имеются **способы обмена информацией** между
  `горутинами`, с помощью которых можно попросить `горутину` **остановиться самостоятельно**;
* `Горутины` способствуют написанию **чистых, композитных программ**, состоящих из `автономных процессов`, **работающих
  одновременно**.
* `Композитная программа` - это программа, состоящая из `нескольких отдельных модулей или компонентов`, которые
  **взаимодействуют друг с другом для выполнения задачи целиком**. Каждый `компонент` может быть
  **автономным процессом**, который работает **одновременно с другими**. Это позволяет **более эффективно** использовать
  **ресурсы компьютера и ускоряет выполнение задачи**. Такой подход также **упрощает разработку и
  тестирование программы**, поскольку каждый `компонент` может быть разработан, проверен и оптимизирован **отдельно от
  других**. Использование `композитных программ` способствует написанию более **гибких и модульных приложений**, которые
  могут быть **проще поддерживать и расширять** в будущем.

____

# 8.2. Пример: параллельный сервер часов

* Сети являются естественной областью применения параллелизма, так как серверы обычно **обрабатывают много** клиентских
  подключений **одновременно**;
* Пакет `net` предоставляет компоненты для **построения сетевых клиентов и серверов**, работающих
  посредством `TCP`, `UDP` или сокетов `Unix`. Пакет `net/http` является надстройкой над функциями пакета `net`;
* В качестве примера рассмотрен последовательный сервер часов, который выводит текущее время клиенту один раз в секунду;
* При создании сервера используются функция `net.Listen` для прослушивания входящих соединений и метод `Accept` для
  обработки входящих запросов на подключение (возвращает значение только в тот момент, когда устанавливается
  подключение);
* Функция `handleConn` обрабатывает одно клиентское соединение, в цикле выводит текущее время клиенту с использованием
  метода `time.Now().Format`;
* Для подключения к серверу можно использовать стандартную вспомогательную программу `nc (netcat)` или аналогичную
  Go-версию (`netcat1.go`);
* При использовании `последовательного сервера`, второй клиент **вынужден ждать завершения работы первого**, поскольку
  сервер обрабатывает только одно соединение за раз;
* Для создания `параллельного сервера`, можно добавить ключевое слово `go` перед вызовом функции `handleConn`, что
  позволит каждому вызову **осуществляться в собственной горутине и обрабатывать несколько клиентов одновременно**.

____

# 8.3. Пример: параллельный эхо-сервер

* Горутины в Golang позволяют выполнять параллельные вычисления в одном соединении;
* Добавление ключевого слова go перед вызовом функции echo позволяет горутинам работать параллельно и обрабатывать
  запросы одновременно;
* Использование горутин позволяет параллельно отправлять сообщения на сервер и выводить ответ сервера на экран;
  ``` go
  go mustCopy(os.Stdout, conn)
  mustCopy(conn, os.Stdin)
  ```
* Важно убедиться, что одновременные вызовы методов объектов языка Golang безопасны, для чего необходимо обеспечить
  безопасность параллелизма.

____

# 8.4. Каналы

* Горутины представляют собой `процессы` в рамках параллельной программы Go, а каналы
  являются `соединениями между ними`;
* `Канал` представляет собой механизм связи, который позволяет **одной горутине отправлять значения другой горутине**;
* Каждый канал имеет `тип элементов канала`, записывается как `chan <тип_элементов>`, например `chan int`;
* Канал создается с использованием встроенной функции `make`. Пример: `ch := make(chan int)`;
* Копируя канал или передавая его функции в качестве аргумента, копируется `ссылка` на структуру данных;
* Каналы поддерживают три операции: `отправление`, `получение` и `закрытие` канала;
* Отправление значения через канал: `ch <- value`; пример:` ch <- 3`;
* Получение значения из канала: `value = <-ch`; пример: `x := <-ch`;
* Закрытие канала с помощью встроенной функции `close`: `close(ch)`;
* Каналы могут быть `небуферизованными` (не иметь емкости) или `буферизованными` (иметь емкость). Создание
  буферизованного канала: `ch = make(chan int, 3)`;
* Небуферизованные каналы `блокируют отправляющую горутину` до тех пор, пока получающая горутина не заберет значение.
  Буферизованные каналы `имеют очередь для хранения значений` до получения их другими горутинами.

____

# 8.4.1 Небуферизованные каналы

* Операция отправления в небуферизованный канал блокирует горутину до тех пор, пока другая горутина не выполнит
  соответствующее получение из того же канала; это обеспечивает синхронизацию отправления и получения данных между
  горутинами. Пример:
  ``` go
  ch := make(chan int)
  go func() {
    ch <- 42 // Отправление значения в канал; горутина блокируется, пока другая горутина не выполнит получение
  }()
  val := <-ch // Получение значения из канала; обе горутины продолжают работу
  ```
* Небуферизованные каналы иногда называют `синхронными`, поскольку они обеспечивают синхронизацию операций отправления и
  получения. Это может быть полезно для упорядочивания выполнения горутин и избегания проблем с параллельным доступом к
  переменным;
* Если нужно передать событие без значения, можно использовать канал с типом элементов `struct{}`; это подчеркивает, что
  важен только факт передачи сообщения. Пример:
  ``` go
  done := make(chan struct{})
  go func() {
      // Работа в фоновой горутине
      done <- struct{}{} // Сигнал главной горутине об окончании работы
  }()
  <-done // Ожидание завершения фоновой горутины
  ```
* Использование каналов для синхронизации горутин обеспечивает явное взаимодействие и гарантирует, что определенные
  действия завершены до продолжения работы других горутин; это помогает избежать ошибок, связанных с параллельным
  доступом к общим данным и состоянию.

* При реализации клиент-серверной связи с использованием горутин и каналов важно использовать синхронизацию для
  корректного завершения работы программы и предотвращения потери данных. Пример кода:
  ``` go
  func main() {
    conn, err := net.Dial("tcp", "localhost:8000")
    if err != nil {
        log.Fatal(err)
    }
    done := make(chan struct{})
    go func() {
        io.Copy(os.Stdout, conn) // Примечание: игнорируем ошибки
        log.Println("done")
        done <- struct{}{} // Сигнал главной горутине
    }()
    mustCopy(conn, os.Stdin)
    conn.Close()
    <-done // Ожидание завершения фоновой горутины
  }
  ```

____

# 8.4.2 Конвейеры

* `Конвейер (pipeline)` в Go - это способ подключения горутин друг к другу с использованием каналов так, чтобы выход
  одной горутины становился входом для другой;
* Закрытие каналов при помощи функции `Close` используется для сообщения получающей горутине о том, что больше не будет
  отправляться значений;
* После закрытия канала, все последующие операции отправления вызовут **панику**, а операции получения будут возвращать
  **нулевые значения** без блокировки;
* Для определения закрытия канала используется вариант операции получения с двумя результатами: **полученный элемент** и
  **логическое значение** `ok` , которое равно `true`, если получено значение, и `false`, если канал закрыт и опустошен:
  ``` go
  x, ok := <-naturals
    if !ok {
      break // Канал закрыт и опустошен
    }
  ```
* Цикл по диапазону используется для получения всех значений из канала и автоматического завершения работы после
  получения последнего значения:
  ``` go
  for x := range naturals {
      squares <- x * x
    }
  ```
* Закрытие каналов не обязательно после завершения работы с ними, но используется при необходимости сообщить принимающей
  горутине о завершении отправки значений;
* Попытка закрыть уже закрытый или нулевой канал вызывает панику;
* Закрытие каналов может использоваться как механизм оповещения о завершении работы.

____

# 8.4.3 Однонаправленные каналы

* Каналы в Go могут быть `двунаправленными` (для отправления и получения данных) или `однонаправленными` (только для
  отправления или только для получения данных);
  ``` go
  chan int   // двунаправленный канал
  chan<- int // канал только для отправления данных
  <-chan int // канал только для получения данных 
  ```
* Однонаправленные каналы используются для документирования намерений разработчика и предотвращения неправильного
  использования каналов в функциях, ограничения доступа к каналам только для чтения или только для записи, что может
  повысить безопасность, уменьшить сложность кода и улучшить производительность в некоторых случаях.
* Положение стрелки `<-` относительно ключевого слова `chan` является мнемоническим. Нарушения использования
  однонаправленных каналов обнаруживаются на этапе компиляции, что позволяет предотвратить ошибки в реализации функций;
* Операция `Close` для каналов должна вызываться только отправляющей горутиной, потому что она утверждает, что больше не
  будет отправления данных в канал. Попытка закрыть канал только для получения приводит к ошибке времени компиляции;
* Двунаправленные каналы могут быть неявно преобразованы в однонаправленные, но обратное преобразование невозможно;

  ``` go
  naturals := make(chan int)
  go counter(naturals) // naturals преобразуется в chan<- int
  go printer(squares) // squares преобразуется в <-chan int
  ```

* Использование однонаправленных каналов и правильная организация горутин позволяют создавать четкую и понятную
  структуру программы, что улучшает ее читаемость и облегчает поддержку.

____

# 8.4.4 Буферизованные каналы

* Буферизованный канал имеет очередь элементов, максимальный размер которой определяется аргументом `capacity` функции
  `make`; это позволяет хранить определенное количество элементов в канале, а не только одно значение, как в
  небуферизованных каналах. Пример создания буферизованного канала с емкостью 3:
  ``` go
  ch := make(chan string, 3)
  ```
* Операция отправления в буферизованный канал вставляет отправляемый элемент в конец очереди, а операция получения
  удаляет первый элемент из очереди; если канал заполнен, операция отправления блокирует горутину, и наоборот, если
  канал пуст, операция получения блокирует горутину. Это обеспечивает синхронизацию между горутинами, работающими с
  каналом;
* Встроенная функция `cap` позволяет получить емкость буфера канала, а функция `len` возвращает количество элементов,
  находящихся в настоящее время в буфере. Их использование может быть полезно для оптимизации производительности или при
  отладке:

  ``` go
  fmt.Println(cap(ch)) // 3
  fmt.Println(len(ch)) // 2 
  ```

* Не рекомендуется использовать буферизованные каналы в пределах одной горутины в качестве очереди, так как каналы
  глубоко связаны с планированием горутин и могут привести к блокировке всей программы; вместо этого используйте срезы
  для создания простой очереди;
* Буферизованные каналы могут быть использованы для ускорения обработки параллельных запросов, как в примере функции
  `mirroredQuery`, которая отправляет запросы на три сервера и возвращает результат самого быстрого первого ответа,
  игнорируя остальные медленные результаты;
* Важно предотвратить утечки горутин, так как, в отличие от переменных, они не собираются сборщиком мусора
  автоматически; нужно гарантировать, что горутины прекратятся, когда они больше не нужны, особенно когда происходит
  работа с буферизованными каналами;
* Выбор между буферизованными и небуферизованными каналами влияет на корректность работы программы; небуферизованные
  каналы обеспечивают более надежную синхронизацию, так как каждая операция отправления синхронизируется с
  соответствующей операцией получения. В случае буферизованных каналов эти операции разделены;
* В некоторых случаях можно создавать буферизованный канал определенного размера и совершать все отправления значений до
  получения первого значения из канала, особенно когда заранее известна верхняя граница отправляемых значений;
* Буферизация каналов может повышать производительность программы, если операции, выполняемые разными горутинами,
  требуют разного времени на выполнение. Буферы позволяют сглаживать временные различия и обеспечивают более плавное
  выполнение программы;
* Буферизация каналов может быть неэффективной, если одна стадия выполнения работает быстрее другой, и буфер большую
  часть времени либо заполняется, либо остается пустым;
* Если определенная стадия выполнения программы сильно сложнее и медленнее остальных, можно использовать дополнительные
  горутины для выполнения этой стадии. Это позволяет более равномерно распределить нагрузку и повысить
  производительность программы.
* Примеры:

	1. Небуферизованный канал:

  ``` go 
  ch := make(chan int)
  ```

	2. Буферизованный канал:

  ``` go
   ch := make(chan int, 5)
  ```

	3. Отправка и получение данных через канал в разных горутинах:

  ``` go
  go func() {
      ch <- someValue
  }()
   go func() {
      receivedValue := <-ch
  }()
  ```

____

# 8.5. Параллельные циклы

* При работе с параллельными циклами в Golang можно использовать `горутины` для выполнения независимых операций в
  параллельных потоках, что увеличивает производительность и эффективность программы; `go func()`
* В задачах с `чрезвычайной параллельностью`, **когда все подзадачи полностью независимы друг от друга**, можно
  реализовать параллельное выполнение и получить линейное увеличение производительности с увеличением
  степени параллелизма;
* Для ожидания завершения горутины можно использовать `канал`, в который каждая горутина отправляет `событие` о своем
  завершении, а `главная горутина` подсчитывает количество полученных событий и завершается после обработки всех
  подзадач; `var ch = make(chan struct{}); /*...*/ ch <- struct{}{}` в горутине;
* При использовании `анонимных функций внутри цикла` стоит быть осторожным с захватом переменных цикла и передавать их
  как `явные аргументы функции`, чтобы избежать ошибок и неожиданного поведения программы;
   ``` go
    var i = make(chan int)
    for j:=0; j<10; j++ {
      go func(a int) {
        i <- a * 2
      }(j)
    }
    ```
* Если нужно возвращать значения от рабочих горутин в главную горутину, можно использовать `каналы` для передачи
  результатов или ошибок;
* Важно избегать утечек горутин, когда горутина `навсегда заблокирована` **в ожидании отправки значения в канал**, так
  как это может привести к остановке программы или нехватке памяти, для этого рекомендуется
  использовать `буферизованные каналы` с достаточной емкостью, что предотвращает блокировку рабочих горутин при отправке
  сообщений;
* Использование типа `sync.WaitGroup` позволяет обеспечить безопасное ожидание завершения работы
  **всех горутин перед закрытием канала**, а также позволяет работать с `переменной-счетчиком`, доступной для нескольких
  горутин одновременно;
  ``` go
  var wg sync.WaitGroup
  ```
* Для корректного использования `sync.WaitGroup` следует вызывать метод `Add` **перед началом рабочей горутины**, а
  метод `Done` (или `Add(-1)`) **внутри рабочей горутины**, что гарантирует правильное состояние счетчика в процессе
  работы программы;
* Использование оператора `defer` внутри рабочей горутины с методом `Done()` обеспечивает **уменьшение значения счетчика
  и завершение работы горутины даже в случае возникновения ошибки**;
* Создание параллельной горутины для ожидания завершения всех рабочих горутин и последующем закрытии канала обеспечивает
  правильное выполнение программы без блокировок и зависаний;
  ``` go
  // Ожидание счетчика
  go func() {
      wg.Wait()
      close(sizes)
  }() 
  ```
* При использовании параллельных циклов в Go стоит следить за **последовательностью вызовов и взаимодействиями между
  горутинами и счетчиками**, что позволит предотвратить возможные блокировки, ошибки или некорректное выполнение
  программы;
* Польза использования параллельных циклов заключается в **улучшении производительности программы, эффективном
  использовании ресурсов и возможности обеспечения безопасной работы** с общими переменными при помощи каналов и
  синхронизации работы горутин.

____

# 8.6. Пример: параллельный веб-сканер

* Для избежания проблемы захвата переменной цикла, горутина сканирования принимает параметр ссылки, а не использует
  переменную цикла напрямую;
* Передача аргументов командной строки в рабочий список осуществляется в отдельной горутине, чтобы избежать
  взаимоблокировки между основной горутиной и горутинами сканирования;
* Слишком высокая параллельность может привести к проблемам, таким как превышение ограничения на количество одновременно
  открытых файлов и сбоев сетевых операций;
* Ограничение количества параллельных обращений к ресурсам может быть достигнуто путем контроля числа одновременно
  выполняемых функций с использованием буферизованного канала и подсчитывающего семафора;
* Каждый свободный слот в буфере канала представляет маркер, который занимается при выполнении функции и освобождается
  при завершении, что обеспечивает ограничение параллелизма;
* Использование подсчитывающего семафора для ограничения параллельных запросов: ограничивает количество одновременно
  выполняющихся HTTP-запросов, что позволяет достичь баланса между производительностью и нагрузкой на сервер;
* Включение счетчика для отслеживания количества отправок в рабочий список (var n int): позволяет определить, работает
  ли программа и следует ли ожидать завершения работы. Это используется для корректного завершения программы после
  обнаружения всех достижимых ссылок из начального URL;
* Создание основного цикла для удаления дубликатов ссылок и отправки непросмотренных ссылок сканерам: уменьшает
  количество одинаковых запросов и делает код более эффективным;
* Использование замкнутой переменной в главной горутине для обеспечения сокрытия информации: делает программу более
  безопасной и корректной, защищая переменные от несанкционированного доступа другими частями программы.

____

# 8.7. Мультиплексирование с помощью select

* Мультиплексирование с `select` позволяет ожидать событий от нескольких каналов одновременно;
* Можно использовать инструкцию `select` для выполнения операций отправления или получения на каналах без блокировки;
* Если готовы (отправка &&|| получение) несколько вариантов, `select` выбирает один из них случайным образом;
* Инструкция `select` может иметь вариант по умолчанию (`default`) для обозначения операции, которую необходимо
  выполнять, когда другие связи не готовы к обработке, и для обеспечения неблокирующей связи;
* Возможно использовать `time.Tick` для запуска периодических действий, однако это может привести к утечке горутин, если
  отсчеты времени не нужны на протяжении всего жизненного цикла приложения. В таких случаях нужно
  использовать `time.NewTicker` и `ticker.Stop()`;
* Нулевое значение для канала (`nil`) может быть полезно, поскольку операции отправления и получения с нулевым каналом
  блокируются навсегда. В таких случаях варианты с нулевыми каналами в инструкции `select` никогда не выбираются, что
  позволяет включить или отключить варианты в зависимости от других входных событий или генерации вывода.

____

# 8.8. Пример: параллельный обход каталога

* Функция `walkDir` обходит все файлы и подкаталоги в каталоге, отправляет размеры файлов в канал и вызывает сама себя
  для
  подкаталогов;
* Главная горутина считывает данные из канала и выводит результаты, второстепенная горутина вызывает walkDir для каждого
  каталога и закрывает канал после завершения;
* Вариант программы, который выводит промежуточные результаты об использовании диска, если установлен флаг "-v" и
  использует таймер для генерации событий каждые 500 мс;
* Параллелизм с использованием sync.WaitGroup и создание новой горутины для каждого вызова walkDir: Третья версия
  программы использует WaitGroup для подсчета вызовов walkDir, создает новые горутины для каждого вызова walkDir, и
  закрывает канал fileSizes, когда счетчик достигает нуля;
* Можно использовать семафор для ограничения количества одновременно открытых файлов и предотвращения создания слишком
  большого количества горутин, что может привести к исчерпанию системных ресурсов.

____

# 8.9. Отмена

* Отмена горутин важна: Иногда необходимо указать горутине на прекращение выполнения, например, в случае разрыва
  соединения с клиентом на веб-сервере. Однако, непосредственное прекращение другой горутины невозможно, так как это
  может привести к неопределенному состоянию совместно используемых переменных;
* Решение с каналом прерывания: Вместо отправки значения в канал для отмены нескольких горутин, закрываем его. Это
  создает механизм широковещательной передачи, поскольку закрытый канал немедленно возвращает нулевые значения для всех
  последующих операций получения;
* Создание канала отмены: Создаем канал отмены, в который не передаются значения, но его закрытие означает, что
  программа должна прекратить работу. Добавляем вспомогательную функцию cancelled() , которая проверяет состояние
  отмены при вызове;
* Чтение из стандартного ввода для отмены: Создаем горутину, которая считывает данные из стандартного ввода. При
  считывании любого ввода (например, нажатии клавиши <Enter> пользователем), горутина
  уведомляет об этом все остальные, закрывая канал отмены;
* Реагирование горутин на сигнал отмены: В главной горутине добавляем в инструкцию `select` вариант, который
  проверяет получение от канала отмены. При выборе этого варианта происходит возврат из функции с опустошением канала
  `fileSizes`, игнорируя все значения и предотвращая зависание при отправке в канал `fileSizes`;
* Проверка состояния отмены: Горутины могут опрашивать состояние отмены, и если оно установлено, возвращаться без
  выполнения действий. Это помогает избежать создания новых горутин после отмены;
* Оптимизация отмены: Важно проверять состояние отмены в ключевых местах кода, чтобы уменьшить задержку отмены и
  обеспечить возможность быстрого завершения всех горутин при отмене. Это может потребовать изменений в логике
  программы, но в результате достигается большая гибкость и контроль над выполнением горутин;
* Тестирование отмены: Можно использовать вызов `panic` вместо возврата из функции `main` при отмене, чтобы среда
  выполнения создала **дамп стека всех горутин** в программе. Это помогает определить, были ли все горутины корректно
  отменены или требуют дополнительного расследования.

____

# 8.10. Пример: чат-сервер

* В примере чат-сервера используются четыре вида горутин:  `main`, `broadcaster`, `handleConn` и `clientWriter`. Это
  позволяет организовать общение между несколькими пользователями и обрабатывать подключение и отключение клиентов;
* Главная горутина `main` отвечает за прослушивание входящих сетевых подключений от клиентов, а для каждого из них
  создается новая горутина `handleConn`, которая обрабатывает подключение клиента;
* Использование `select` в горутине `broadcaster` помогает организовать обработку различных видов сообщений от клиентов
  и событий подключения/отключения клиентов;
* Горутина `broadcaster` отвечает за широковещание сообщений от одного клиента ко всем остальным и обработку событий
  подключения/отключения клиентов;
* Горутина `handleConn` отвечает за создание нового канала исходящих сообщений для клиента, считывание текста от клиента
  и отправку сообщений широковещателю;
* Горутина `clientWriter` отвечает за отправку широковещательных сообщений клиентам;
* Использование переменных, **безопасных с точки зрения параллелизма**, таких как каналы и экземпляры `net.Conn`,
  исключает необходимость явных операций блокировки.

____