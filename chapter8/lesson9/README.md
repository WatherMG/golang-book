# 8.9 Отмена

Иногда нужно указать горутине, что она должна прекратить свои действия, например, на веб-сервере, где она
выполняет вычисления для клиента, соединение с которым разорвано.

Нет никакого способа, которым одна горутина могла бы прекратить выполнение другой непосредственно, поскольку это
допускало бы ситуацию, когда совместно используемые переменные могли оказаться в неопределенном состоянии. В программе
запуска ракеты (раздел 8.7) мы отправляли одно значение в канал с именем `abort`, которое горутина отсчета
интерпретировала как запрос на прекращение работы. Но что если нам нужно отменить две горутины или произвольное
число горутин?

Одна из возможностей может заключаться в отправлении стольких событий в канал прерывания, сколько горутин следует
отменить. Однако если некоторые из горутин уже прекратили работу, наш счетчик окажется слишком большим, и наш
отправитель остановится. С другой стороны, если эти горутины породили другие горутины, счетчик окажется
слишком мал, и некоторые горутины так и останутся в неведении относительно требующегося прекращения работы. В
общем случае трудно знать, сколько горутин работают от нашего имени в произвольный момент времени. Кроме того,
горутина, получив значение из канала `abort`, забирает это значение, и другие горутины его не видят. Для
отмены нам нужен надежный механизм широковещания события по каналу, чтобы многие горутины могли его увидеть.
Вспомним, что после того, как канал был закрыт и опустошен от всех отправленных значений, последующие операции получения
значения немедленно выдают нулевые значения. Мы можем использовать это свойство для создания механизма широковещания: не
отправляйте значение в канал, а просто закройте его.

Мы можем добавить такую возможность в программу `du` из предыдущего раздела с помощью нескольких простых изменений.
Сначала мы создаем **канал отмены**, в который не передаются никакие значения, но закрытие которого означает, что
программа должна прекратить свою работу. Мы также определим вспомогательную функцию `cancelled`, которая проверяет, или
опрашивает, состояние отмены при вызове.

``` go
var done = make(chan struct{})

func cancelled() bool {
	select {
	case <-done:
		return true
	default:
		return false
	}
}
```

Далее мы создаем горутину, которая будет считывать данные из стандартного ввода (обычно подключенного к
терминалу). Как только будет считан любой ввод (например, пользователь нажмет клавишу <Enter>), данная горутина
сообщает об этом всем прочим горутинам путем закрытия канала `done`.

``` go
// Отмена обхода при обнаруженном вводе.
	go func() {
		os.Stdin.Read(make([]byte, 1))
		close(done)
	}()
```

Теперь нужно сделать наши горутины реагирующими на сигнал отмены. В главной горутине добавим в инструкцию
`select` третий вариант, который пытается выполнить получение от канала `done`. При выборе этого варианта выполняется
возврат из функции, но перед этим следует опустошить канал `fileSizes`, проигнорировав все значения до закрытия канала.
Это делается для того, чтобы убедиться, что все активные вызовы `walkDir` могут выполняться до завершения без
"зависания" при попытке отправления в канал `fileSizes`.

``` go
for {
	select {
	case <-done:
		// Опустошение канала fileSizes, чтобы позволить
		// завершиться существующим горутинам
		for range fileSizes {
			// Ничего не делаем
		}
		return
	case size, ok := <-fileSizes:
	//...
	}
}
```

Горутина `WalkDir` опрашивает состояние отмены, когда начинает работу, и, если это состояние установлено,
возвращается, не выполняя никаких действий. Так все горутины, созданные после отмены, превращаются в "пустышки":

``` go
defer wg.Done()
	
	if cancelled() {
		return
	}

	for _, entry := range dirents(dir) {
		//...
	}
}
```

Может оказаться выгодным опрос состояния отмены в цикле `walkDir`, чтобы избежать создания горутин после события
отмены. Отмена включает компромисс; быстрый ответ часто требует больших изменений в логике программы. Гарантия
отсутствия дорогостоящих операций после отмены может потребовать обновления многих мест кода, но зачастую наибольшие
выгоды могут быть получены от проверки отмены в нескольких важных местах.

Небольшое профилирование этой программы показало, что узким местом является захват маркера семафора в `dirents`.
Инструкция `select`, показанная ниже, позволяет отменить эту операцию и уменьшает типичную задержку отмены программы от
сотен миллисекунд до десятков:

``` go
func dirents(dir string) []os.FileInfo {
	select {
	case sema <- struct{}{}: // Захват маркера
	case <-done:
		return nil // Отмена
	}

	defer func() {
		<-sema // Освобождение токена
	}()

	// ...Чтение каталога...
}
```

Теперь, когда происходит отмена, все фоновые горутины быстро останавливаются и происходит возврат из функции
`main`. Конечно, когда происходит возврат из функции `main`, программа завершает работу, поэтому может быть трудно
сказать, точно ли функция `main` очищает все после себя. Есть удобный трюк, который можно использовать в ходе
тестирования: если вместо возврата из функции `main` в случае отмены мы выполним вызов `panic`, то среда выполнения
создаст дамп стека каждой горутины в программе. Если остается только одна главная горутина, то она выполняет всю
очистку. Но если остаются другие горутины, они могут не быть корректно отменены или, возможно, их отмена требует
времени. В этом случае может быть целесообразным небольшое расследование. Дамп аварийной ситуации часто содержит
достаточную информацию, чтобы различить эти случаи.

## Выводы:

* Отмена горутин важна: Иногда необходимо указать горутине на прекращение выполнения, например, в случае разрыва
  соединения с клиентом на веб-сервере. Однако, непосредственное прекращение другой горутины невозможно, так как это
  может привести к неопределенному состоянию совместно используемых переменных;
* Решение с каналом прерывания: Вместо отправки значения в канал для отмены нескольких горутин, закрываем его. Это
  создает механизм широковещательной передачи, поскольку закрытый канал немедленно возвращает нулевые значения для всех
  последующих операций получения;
* Создание канала отмены: Создаем канал отмены, в который не передаются значения, но его закрытие означает, что
  программа должна прекратить работу. Добавляем вспомогательную функцию cancelled() , которая проверяет состояние
  отмены при вызове;
* Чтение из стандартного ввода для отмены: Создаем горутину, которая считывает данные из стандартного ввода. При
  считывании любого ввода (например, нажатии клавиши <Enter> пользователем), горутина
  уведомляет об этом все остальные, закрывая канал отмены;
* Реагирование горутин на сигнал отмены: В главной горутине добавляем в инструкцию `select` вариант, который
  проверяет получение от канала отмены. При выборе этого варианта происходит возврат из функции с опустошением канала
  `fileSizes`, игнорируя все значения и предотвращая зависание при отправке в канал `fileSizes`;
* Проверка состояния отмены: Горутины могут опрашивать состояние отмены, и если оно установлено, возвращаться без
  выполнения действий. Это помогает избежать создания новых горутин после отмены;
* Оптимизация отмены: Важно проверять состояние отмены в ключевых местах кода, чтобы уменьшить задержку отмены и
  обеспечить возможность быстрого завершения всех горутин при отмене. Это может потребовать изменений в логике
  программы, но в результате достигается большая гибкость и контроль над выполнением горутин;
* Тестирование отмены: Можно использовать вызов `panic` вместо возврата из функции `main` при отмене, чтобы среда
  выполнения создала **дамп стека всех горутин** в программе. Это помогает определить, были ли все горутины корректно
  отменены или требуют дополнительного расследования.