# 4.4.3 Встраивание структур и анонимные поля

Механизм **_встраивания структур (struct embedding)_** позволяет использовать именованный структурный тип в качестве
**_анонимного поля (anonymous field)_** другого структурного типа, обеспечивая удобное синтаксическое сокращение, так
что простое выражение с точкой, такое как `x.f`, может означать целую цепочку полей наподобие `x.d.e.f`.

Рассмотрим программу двумерного рисования, которая предоставляет библиотеку фигур, таких как прямоугольники, эллипсы,
звезды и колеса. Ниже пример двух типов, которые она может определять:

``` go
type Circle struct {
    X, Y, Radius int
}

type Wheel struct {
    X, Y, Radius, Spokes int
}
```

`Circle` имеет поля для координат центра `X` и `Y`, и `Radius.Wheel` обладает всеми возможностями `Circle`, а так же
имеет поле `Spokes`, содержащее количество радиальных спиц. Создадим колесо:

``` go
var w Wheel
w.X = 8
w.Y = 8
w.Radius = 5
w.Spokes = 20
```

По мере роста множества фигур мы обязательно заметим, сходства и повторения среди них, так что может оказаться удобным
выделить их общие части:

``` go
type Point struct {
	X, Y int
}

type Circle struct {
	Center Point
	Radius int
}

type Wheel struct {
	Circle Circle
	Spokes int
}
```

Приложение от этого может стать понятнее, но такое изменение усложняет доступ к полям `Wheel`:

``` go
var w Wheel
w.Circle.Center.X = 8
w.Circle.Center.Y = 8
w.Circle.Radius = 5
w.Spokes = 20
```

Go позволяет объявить поле с типом, но без имени. Такие поля называются **_анонимными полями_**. Тип поля должен
представлять собой именованный тип или указатель на именованный тип. Ниже `Circle` и `Wheel` имеют по одному анонимному
полю. Мы говорим, что тип `Point` **_встроен (embedded)_** в тип `Circle`, а `Circle` встроен в `Wheel`.

Благодаря встраиванию анонимных полей, можно обращаться к полям этих типов без указания промежуточных имен. То есть,
если у нас есть переменная типа Wheel, то мы можем обращаться к полям Point и Circle напрямую, как если бы они были
частью структуры Wheel, без необходимости указывать промежуточные имена.

``` go
var w Wheel
w.X = 8 // Эквивалентно записи w.Circle.Point.X = 8
w.Y = 8 // Эквивалентно записи w.Circle.Point.Y = 8
w.Radius = 5 // Эквивалентно записи w.Circle.Radius = 5
w.Spokes = 20
```

Явная запись показанная в комментариях, по-прежнему действительны, что показывает, что **_анонимное поле_** - это не
совсем точное название. Поле `Circle` и `Point` содержат имена - те, что у именованных типов, но эти имена необязательны
в точечных выражениях. Мы можем опустить любое или все анонимные поля при выборе их подполей.

К сожалению, не существует соответствующего сокращения для синтаксиса структурного литерала, поэтому ни один из
следующих примеров не будет компилироваться:

``` go
w = Wheel{8, 8, 5, 20} // Ошибка: неизвестные поля
w = Wheel{X:8, Y:8, Radius:5, Spokes: 20} // Ошибка: неизвестные поля
```

Структурный литерал должен следовать форме объявления типа, поэтому мы должны использовать один из двух приведенных
в `emded.go` вариантов, которые эквивалентны один другому.

Символ `#` заставляет символы преобразования `%v` в функции `Printf` выводить значения в виде, похожем на синтаксис Go.
Для структур этот вид включает имя каждого поля.

Поскольку **_анонимные_** поля имеют неявные имена, у нас не может быть двух анонимных полей одинакового типа, так как
их имена будут конфликтовать. И поскольку имя поля неявно определяется его типом, то же самое относится и к видимости
поля. В приведенных примерах (embed.go) анонимные поля `Point` и `Circle` экспортируются. Если бы они были не
экспортируемыми (`point`, `circle`), мы могли бы по-прежнему использовать сокращенную запись:

``` go
w.X = 8 // Эквивалентно записи w.Circle.Point.X = 8
```

Однако явная длинная запись, показанная в комментарии, была бы запрещена вне объявляющего структуру пакета, поскольку
`circle` и `point` были бы недоступны.

То, как мы использовали до настоящего момента встраивание структур, является не более чем **_синтаксическим сахаром_**
для выбора полей структуры с помощью записи с точкой.

Анонимные поля не обязаны быть структурными типами. Это может быть любой именованный тип или указатель на именованный
тип. Но какой смысл встраивать тип, не имеющий подполей?

Ответ имеет отношение к методам. Сокращенная запись, используемая для выбора поля встроенного типа, работает и для
выбора его методов. По сути, тип внешней структуры получает не только поля встроенного типа, но и его методы. Этот
механизм является основным способом получения поведения сложного объекта с помощью композиции более простых.
**_Композиция_** является центральным моментом объектно-ориентированного программирования в Go.

## Выводы:

* Встраивание структур позволяет использовать именованный структурный тип в качестве анонимного поля другого
  структурного типа, обеспечивая удобное синтаксическое сокращение для доступа к полям и методам встроенного типа; это
  упрощает код и делает его более читаемым.
  Пример:
  ``` go
  type Point struct {
    X, Y int
  }
  
  type Circle struct {
    Point
    Radius int
  }
  ```
* Анонимные поля - `поля структуры`, которые имеют тип, но не имеют имени; тип поля должен быть именованным типом или
  указателем на именованный тип, а имя поля неявно определяется его типом;  
  Пример:
  ``` go
  type Circle struct {
      Point
      Radius int
  }
  ```
* Благодаря встраиванию `анонимных полей`, можно обращаться к полям этих типов без указания промежуточных имен, упрощая
  обращение к полям вложенных структур;  
  Пример:
  ``` go
  var c Circle
  c.X = 8
  c.Y = 8
  c.Radius = 5
  ```
* Встраивание структур также позволяет получать `методы встроенного типа` для типа внешней структуры, обеспечивая
  `механизм композиции` и `объектно-ориентированного программирования` в Go;  
  Пример:
  ``` go
  type Point struct {
    X, Y int
  }

  func (p Point) Distance() float64 {...}

  type Circle struct {
    Point
    Radius int
  }

  var c Circle
  distance := c.Distance() // вызывает Point.Distance() для c.Point
  ```
* Несмотря на возможность использования сокращенной записи для доступа к полям и методам встроенного типа, структурный
  литерал должен следовать форме объявления типа, поэтому простое указание значений полей без их имен не будет
  допустимо;  
  Пример:
  ```  go
  c := Circle{Point{8, 8}, 5} // верно
  c := Circle{8, 8, 5} // ошибка компиляции
  ```
* `Композиция` в Go - это механизм, который позволяет объединять несколько типов в один тип, подобно наследованию в
  других языках программирования. Он позволяет одному типу включать в себя другой тип как поле. При использовании
  композиции, все методы, свойства и функциональность включенного типа становятся доступными для включающего типа,
  который может дополнительно определять свои собственные методы и свойства;
* В Go `композиция` и `наследование` имеют свои отличия:

	1. `Наследование` - это механизм, который позволяет создавать новый тип на основе существующего типа, который может
	   использовать и переопределить методы базового типа. В то время как `композиция` - это механизм, который позволяет
	   включать один тип в другой тип как поле.
	2. В наследовании подтип наследует каждый метод базового типа, включая его состояние. В композиции тип включает в
	   себя
	   другой тип как поле, но не наследует его состояние.
	3. При использовании композиции, включающий тип может использовать методы включенного типа как свои собственные
	   методы,
	   но не может изменять их поведение. В наследовании подтип может переопределить методы базового типа и изменить их
	   поведение.
В целом, композиция и наследование имеют очень разные цели и могут использоваться в разных ситуациях в зависимости от
потребностей программы.