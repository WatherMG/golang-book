# 4.4.3 Встраивание структур и анонимные поля

Механизм **_встраивания структур (struct embedding)_** позволяет использовать именованный структурный тип в качестве
**_анонимного поля (anonymous field)_** другого структурного типа, обеспечивая удобное синтаксическое сокращение, так
что простое выражение с точкой, такое как `x.f`, может означать целую цепочку полей наподобие `x.d.e.f`.

Рассмотрим программу двумерного рисования, которая предоставляет библиотеку фигур, таких как прямоугольники, эллипсы,
звезды и колеса. Ниже пример двух типов, которые она может определять:

``` go
type Circle struct {
    X, Y, Radius int
}

type Wheel struct {
    X, Y, Radius, Spokes int
}
```

`Circle` имеет поля для координат центра `X` и `Y`, и `Radius.Wheel` обладает всеми возможностями `Circle`, а так же
имеет поле `Spokes`, содержащее количество радиальных спиц. Создадим колесо:

``` go
var w Wheel
w.X = 8
w.Y = 8
w.Radius = 5
w.Spokes = 20
```

По мере роста множества фигур мы обязательно заметим, сходства и повторения среди них, так что может оказаться удобным
выделить их общие части:

``` go
type Point struct {
	X, Y int
}

type Circle struct {
	Center Point
	Radius int
}

type Wheel struct {
	Circle Circle
	Spokes int
}
```

Приложение от этого может стать понятнее, но такое изменение усложняет доступ к полям `Wheel`:

``` go
var w Wheel
w.Circle.Center.X = 8
w.Circle.Center.Y = 8
w.Circle.Radius = 5
w.Spokes = 20
```

Go позволяет объявить поле с типом, но без имени. Такие поля называются **_анонимными полями_**. Тип поля должен
представлять собой именованный тип или указатель на именованный тип. Ниже `Circle` и `Wheel` имеют по одному анонимному
полю. Мы говорим, что тип `Point` **_встроен (embedded)_** в тип `Circle`, а `Circle` встроен в `Wheel`.

Благодаря встраиванию анонимных полей, можно обращаться к полям этих типов без указания промежуточных имен. То есть,
если у нас есть переменная типа Wheel, то мы можем обращаться к полям Point и Circle напрямую, как если бы они были
частью структуры Wheel, без необходимости указывать промежуточные имена.

``` go
var w Wheel
w.X = 8 // Эквивалентно записи w.Circle.Point.X = 8
w.Y = 8 // Эквивалентно записи w.Circle.Point.Y = 8
w.Radius = 5 // Эквивалентно записи w.Circle.Radius = 5
w.Spokes = 20
```

Явная запись показанная в комментариях, по-прежнему действительны, что показывает, что **_анонимное поле_** - это не
совсем точное название. Поле `Circle` и `Point` содержат имена - те, что у именованных типов, но эти имена необязательны
в точечных выражениях. Мы можем опустить любое или все анонимные поля при выборе их подполей.

К сожалению, не существует соответствующего сокращения для синтаксиса структурного литерала, поэтому ни один из
следующих примеров не будет компилироваться:

``` go
w = Wheel{8, 8, 5, 20} // Ошибка: неизвестные поля
w = Wheel{X:8, Y:8, Radius:5, Spokes: 20} // Ошибка: неизвестные поля
```

Структурный литерал должен следовать форме объявления типа, поэтому мы должны использовать один из двух приведенных
в `emded.go` вариантов, которые эквивалентны один другому.

Символ `#` заставляет символы преобразования `%v` в функции `Printf` выводить значения в виде, похожем на синтаксис Go.
Для структур этот вид включает имя каждого поля.

Поскольку **_анонимные_** поля имеют неявные имена, у нас не может быть двух анонимных полей одинакового типа, так как
их имена будут конфликтовать. И поскольку имя поля неявно определяется его типом, то же самое относится и к видимости
поля. В приведенных примерах (embed.go) анонимные поля `Point` и `Circle` экспортируются. Если бы они были не
экспортируемыми (`point`, `circle`), мы могли бы по-прежнему использовать сокращенную запись:

``` go
w.X = 8 // Эквивалентно записи w.Circle.Point.X = 8
```

Однако явная длинная запись, показанная в комментарии, была бы запрещена вне объявляющего структуру пакета, поскольку
`circle` и `point` были бы недоступны.

То, как мы использовали до настоящего момента встраивание структур, является не более чем **_синтаксическим сахаром_**
для выбора полей структуры с помощью записи с точкой.

Анонимные поля не обязаны быть структурными типами. Это может быть любой именованный тип или указатель на именованный
тип. Но какой смысл встраивать тип, не имеющий подполей?

Ответ имеет отношение к методам. Сокращенная запись, используемая для выбора поля встроенного типа, работает и для
выбора его методов. По сути, тип внешней структуры получает не только поля встроенного типа, но и его методы. Этот
механизм является основным способом получения поведения сложного объекта с помощью композиции более простых. 
**_Композиция_** является центральным моментом объектно-ориентированного программирования в Go.

