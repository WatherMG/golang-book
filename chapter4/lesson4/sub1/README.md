# 4.4.1 Структурные литералы

Существуют две разновидностей структурных литералов. Первая - требует указания значения для каждого поля в правильном
порядке (как правило, используется только внутри пакета, который определяет структурный тип, или с малым количеством
структурных полей):

``` go
type Point struct{X, Y int}
p := Point{1, 2}
```

Вторая (используется чаще) - значения структуры инициализируются с помощью перечисления некоторых или всех имена полей с
соответствующими значениями.

``` go
anim := gif.GIF{LoopCount: nframes} // пример из раздела 1.4
```

Если поле в таком литерале опущено, оно получает нулевое значение соответствующего типа. Поскольку в литерале указаны
имена полей, их порядок становиться не имеющим значения.

В одном и том же литерале нельзя смешивать две описанные разновидности. Так же нельзя применять первую разновидность
литерала (использующую порядок полей), чтобы обойти правило, согласно которому к не экспортируемым идентификаторам
нельзя
обращаться из других пакетов:

``` go
package p

type T struct{ a, b int } // a и b не экспортируемы

package q
import "p"

var _ = p.T{a: 1, b: 2} // Ошибка компиляции: нельзя обращаться к a и b
var _ = p.T{1, 2}       // Ошибка компиляции: нельзя обращаться к a и b
```

Хоть и в последней строке выше не упоминаются идентификаторы не экспортируемых полей, в действительности они
используются неявно, поэтому данный код не компилируется.

Значения структур могут быть переданы как аргументы в функцию и быть возвращены из нее. Например, приведенная ниже
функция масштабирует `Point` с использованием некоторого коэффициента:

``` go
func Scale(p Point, factor int) Point {
    return Point{p.X * factor, p.Y * factor}
}

fmt.Println(Scale(Point{1, 2}, 5)) // "{5, 10}"
```

Для повышения эффективности большие структурные типы обычно передаются в функции или возвращаются из них косвенно с
помощью указателя:

``` go
func Bonus(e *Employee, percent int) int {
    return e.Salary * percent / 100
}
```

Такая передача обязательна, если функция должна модифицировать свой аргумент, поскольку при передаче по значению
вызываемая функция получает только копию аргумента, а не ссылку на исходный аргумент:

``` go
func AwardAnnualRaise(e *Employee) {
    e.Salary = e.Salary * 105 / 100
}
```

Поскольку работа со структурами очень часто выполняется через указатели, можно использовать следующую сокращенную
запись для создания и инициализации структурной переменной и получения ее адреса:

``` go
pp := &Point{1, 2}
// Эта запись эквиватентна следующей:
pp := new(Point)
*pp = Point{1, 2}
```

Однако `&Point{1, 2}` можно использовать непосредственно в выражении, таком, как вызов функции.

## Выводы:

* Структурные литералы в Golang имеют две разновидности: с указанием значений для каждого поля в правильном порядке и с
  перечислением некоторых или всех имен полей с соответствующими значениями;
* Если поле в структурном литерале опущено, оно получает нулевое значение соответствующего типа;
* Значения структур могут быть переданы как аргументы в функцию и быть возвращены из нее;
* Большие структурные типы обычно передаются в функции или возвращаются из них косвенно с помощью указателя для
  повышения эффективности;
* Если функция должна модифицировать свой аргумент, передача через указатель становится обязательной;
* Можно использовать сокращенную запись для создания и инициализации структурной переменной и получения ее
  адреса (`p := &Person{"John", 30}`);
* Примеры:
  * Создание структуры с использованием разных видов литералов:
  ``` go
  type Person struct {
      name    string
      age     int
      address struct {
          street string
          city   string
      }
  }
  
  person := Person{
      name: "John",
      age:  30,
      address: struct{ street, city string }{
          street: "123 Main St",
          city:   "New York",
      },
  }
  ```
  * Функция, масштабирующая Point с использованием некоторого коэффициента:
  ``` go
  func Scale(p Point, factor int) Point {
     return Point{p.X * factor, p.Y * factor}
  }
  ```
  * Передача структуры в функцию через указатель для модификации аргумента:
  ``` go 
  func AwardAnnualRaise(e *Employee) {
      e.Salary = e.Salary * 105 / 100
  }
  ```
  * Сокращенная запись для создания и инициализации структурной переменной и получения ее адреса:
     `pp := &Point{1, 2}`