# 4.4 Структуры

Структура - агрегированный тип данных, объединяющий нуль или более именованных произвольных типов в единое целое.
Каждое значение называется **полем**. Классическим примером структуры является запись о сотруднике, ее полями являются:
уникальный идентификатор, имя, адрес, дата рождения, должность, зарплата и т.п. Все эти поля собраны в единую сущность,
которая может копироваться как единое целое, передаваться функции и возвращаться ею, хранится в массивах и т.д.

``` go
type Empluyee struct {
    ID int
    Name string
    Address string
    DoB time.Time
    Position string
    Salary int
    ManagerID int
}

var dilbert Employee
```

Доступ к отдельным полям `diblert` осуществляется с помощью записи с точкой, например `diblert.Name` или `diblert.DoB`.
Поскольку `diblert` является переменной, ее поля также являются переменными, поэтому им можно выполнять присваивание:

``` go
dilbert.Salary -= 500 // Снизили зарплату
```

Можно взять адрес и получить к нему доступ через указатель:

``` go
position := &dilbert.Position
*position = "Senior" + *position
```

Запись с точкой работает и с указателем на структуру:

``` go
var employeeOfTheMonth *Employee = &dilbert
employeeOfTheMonth.Position += " (активный участник команды) "
// эта запись эквивалентна следующей:
(*employeeOfTheMonth).Position += " (активный участник команды) "
```

Функция `EmployeeByID` возвращает указатель на структуру `Employee`. Мы можем получить доступ к его полям через `.`:

``` go
func EmployeeByID(id int) *Employee { /*...*/ }

fmt.Println(EmployeeByID(dilbert.ManagerID).Position) // BOSS

id := dilbert.ID
EmployeeByID(id).Salary = 0 // Уволить
```

Последняя инструкция обновляет структуру `Employee`, на которую указывает результат вызова `EmployeeByID`. Если тип
результата `EmployeeByID` изменить на `Employee`, вместо `*Employee`, инструкция присваивания не будет компилироваться,
поскольку ее левая сторона не будет определять переменную.

Поля обычно записываются по одному в строке. При этом имя поля предшествует его типу. Однако последовательные поля
одного и того же типа могу быть объединены, как поля `Name` и `Address` ниже:

``` go
type Employee struct {
    ID int,
    Name, Adress string
    DoB, time.Time
    Position int
    ManagerID int
}
```

Порядок полей имеет важное значение для идентификации типа. Объединим ли мы с упомянутыми полями объявление
поля `Position` (тоже string) или поменяем местами `Name` и `Address`, мы при этом определим другой тип структуры.
Обычно объединяются только объявления связанных полей.

Если имя поля начинается с прописной буквы - оно экспортируется. Это основной механизм управления доступом в Go.
Структурный тип может содержать комбинацию экспортируемых и не экспортируемых полей.

Именованный структурный тип `S` не может объявить поле того же типа `S`: агрегатное значение не может содержать само
себя (Аналогичное ограничение применимо и к массивам). Но `S` может объявить поле с типом указателя `*S`, который
позволяет создавать рекурсивные структуры данных, такие как связанные списки и деревья. В коде (см. treesort.go)
используется бинарное дерево, в котором реализован алгоритм сортировки вставками.

Нулевое значение для структуры состоит из нулевых значений каждого из ее полей. Обычно, желательно, чтобы нулевое
значение было естественным или разумным значением по умолчанию. Например, в `bytes.Buffer` начальное значение структуры
представляет собой готовый к использованию пустой буфер, а нулевой значение `sync.Mutex`, представляет собой
разблокированный мьютекс. Иногда такое разумное первоначальное поведение получается без особых усилий, но иногда над ним
приходится поработать.

Тип структуры без полей называется **_пустой структурой_**, записываемой как `struct{}`. Она имеет нулевой размер и не
несет в себе никакой информации, но может оказаться полезной. Некоторые программисты Go используют ее вместо `bool` в
качестве типа значения в карте `map`, которое представляет собой множество.
Такой выбор подчеркивает, что в `map` играют роль только ключи. Экономия памяти при этом оказывается незначительной, а
синтаксис - более громоздким, поэтому мы, как правило, избегаем такого решения:

``` go
seen := make(map[string]struct{}) // Множество строк
// ...
if _, ok := seen[s]; !ok {
    seen[s] = struct{}{}
    // ... s встречается впервые...
}
```

## Выводы:

* `Структура` в Go - это `агрегированный тип данных`, объединяющий нуль или более именованных произвольных типов в
  единое целое;
* Каждое значение в структуре называется `полем`, и к ним можно получить доступ через запись с точкой (например,
  `dilbert.Name`);
* Структуры могут быть переданы функциям, возвращаться из них и храниться в массивах;
* В Go поле структуры экспортируется, если его имя начинается с `прописной буквы`;
* Именованный структурный тип `S` может объявить поле с типом указателя `*S`, что позволяет создавать рекурсивные
  структуры данных, такие как связанные списки и деревья;
* Нулевое значение для структуры состоит из нулевых значений каждого из ее полей;
* Тип структуры без полей называется пустой структурой `struct{}` и может использоваться в качестве значения для
  множества с ключами в `map`.
* Пример структуры:
  ``` go
  type Employee struct {
    ID int
    Name string
    Address string
    DoB time.Time
    Position string
    Salary int
    ManagerID int
  }
  ```
* Пример использования указателя на структуру для доступа к полям:
  ``` go
  position := &dilbert.Position
  *position = "Senior" + *position
  ```