# 4. Составные типы

В этой главе речь пойдет о составных типах - массивах, срезах, хеш-таблицах и структурах.

Массивы и структуры являются **_составными (агрегированными)_** типами данных - их значения создаются путем конкатенации
в памяти других значений.

Массивы **_гомогенны (все элементы массива имеют один и тот же тип)_**, в то время как структуры **гетерогенны (могут
иметь разный тип)**.

В отличие от них срезы и хеш-таблицы являются динамическими структурами данных, растущими по мере добавления в них
значений.

# Выводы к главе:

<!-- TOC -->

* [4.1. Массивы](#41-массивы)
* [4.2. Срезы](#42-срезы)
	* [4.2.1 Функция append](#421-функция-append)
	* [4.2.2 Работа со срезами "на лету"](#422-работа-со-срезами-на-лету)
* [4.3. Хеш-таблица](#43-хеш-таблица)
* [4.4. Структуры](#44-структуры)
	* [4.4.1 Структурные литералы](#441-структурные-литералы)
	* [4.4.2 Сравнение структур](#442-сравнение-структур)
	* [4.4.3 Встраивание структур и анонимные поля](#443-встраивание-структур-и-анонимные-поля)
* [4.5. JSON](#45-json)
* [4.6. Текстовые и HTML-шаблоны](#46-текстовые-и-html-шаблоны)

<!-- TOC -->

____

## 4.1. Массивы

* Массивы в Go - последовательности фиксированной длины из нуля или более элементов определенного типа.
	* Пример: `var a [3]int`.
* Фиксированная длина массивов делает их менее гибкими по сравнению со срезами.
* Доступ к элементу массива осуществляется через индекс, начиная с `0` до `n-1` длины массива.
* Для инициализации массива списком значений можно использовать литерал массива.
	* Пример: `q := [...]int{1, 2, 3}`.
* Синтаксис `[...]` объявляет неопределенный массив фиксированной длины, которая определяется автоматически на основе
  числа элементов, перечисленных в фигурных скобках;
* Размер массива является частью его типа, так что типы `[3]int` и `[4]int` различны.
* Если тип элемента массива является сравниваемым, то таким же является и тип массива.
	* Пример сравнения: `fmt.Println(a == b, a == c, b == c)`.
* При передаче в функцию по значению для каждого значения аргумента, функция получает копию аргумента, а не оригинал.
* Можно использовать указатели на массивы для изменения оригинального массива внутри функции.
	* Пример функции с указателем на массив: `func zero(ptr *[32]byte)`.
* Массивы используются редко из-за их негибкости, вместо массивов обычно используют срезы.

____

## 4.2. Срезы

* Срезы в Golang представляют собой последовательности переменной длины с элементами одного типа и описываются
  как `[]T`, где `T` - тип элементов среза;
* Срез состоит из трех компонентов: `указателя на массив`, `длины` и `емкости`. Указатель указывает на первый доступный
  элемент массива, а длина и емкость определяют размер и максимальный размер среза соответственно;
* Срезы могут совместно использовать один и тот же базовый массив, что позволяет манипулировать субпоследовательностями
  элементов массива с минимальными затратами памяти;
* Оператор среза `s[i:j]` создает новый срез, ссылающийся на элементы последовательности `s` с `i` до `j-1`, при
  этом `0 <= i <= j <= cap(s)`;
* Пример объявления массива и создания срезов:
  ``` go
  months := [...]string{1: "Январь", 2: "Февраль", /*...*/, 12: "Декабрь"}
  Q2 := months[4:7]
  summer := months[6:9]
  ```
* Срезы содержат указатель на элемент массива, что позволяет изменять элементы базового массива при передаче среза в
  функцию;
* При сравнении срезов можно использовать функцию `bytes.Equal` для срезов байтов `[]byte`, но для других типов срезов
  необходимо выполнять сравнение вручную, создавая соответствующую функцию, например:
  ``` go
  func equal(x, y []string) bool {
    len(x) != len(y) {
	  return false
    }
    for i := range x {
      if x[i] != y[i] {
        return false
      }
    }
    return true
  }
  ```
* Использование срезов упрощает манипуляции с данными, сохраняя память и предоставляя простые и понятные методы работы с
  подпоследовательностями массивов;
* Срезы в Go являются косвенными элементами, что позволяет им содержать самих себя и изменяться при изменении
  содержимого базового массива;
* Функция `make` создает массив заданного размера, на который ссылается срез, и этот массив доступен только через
  возвращаемый срез `a := make([]string, 0, 3)`;
* Длина среза - количество элементов в нем, емкость среза - максимальное число элементов, которые могут быть содержимым
  среза;
* У срезов имеется нулевое значение `nil`, такой срез ни на что не ссылается, и его длина и емкость равны нулю;
* При сравнении срезов с помощью `==`, данные срезы сравниваются не всегда корректно, только `nil` значения могут быть
  сравнены. Если хотя бы один элемент или длина срезов отличаются, оператор `==` вернет `false`. Сравнение срезов с
  помощью оператора `==` может быть неэффективно, поскольку сравнение происходит поэлементно;
* Если необходимо сравнить содержимое срезов, нужно использовать функцию `reflect.DeepEqual` или `bytes.Equal`;
* Если срез имеет длину, равную нулю, нужно проверять его на пустоту с помощью `len(s) == 0`, а не `s == nil`;
* Для проверки равенства ссылочных типов, таких как указатели и каналы, нужно использовать операторы `==` для проверки
  ссылочной тождественности;
* Если необходимо добавить элементы в срез, и емкость его не достаточна, Go создаст новый массив большего размера и
  скопирует в него элементы из старого массива;
* В Go есть встроенные функции, такие как `append`, чтобы изменять размер среза;
* Срезы являются важными и удобными конструкциями в Go, их использование позволяет сделать программирование более гибким
  и поддерживаемым.

____

### 4.2.1 Функция append

* Функция `append` в Golang используется для добавления элементов к `срезу (slice)`; это встроенная функция, которая
  имеет ключевое значение для работы со срезами;
* Функция `append` проверяет, имеет ли срез `достаточную емкость (capacity)` для добавления элементов; если да,
  она `расширяет` срез,
  если нет – выделяет новый массив и копирует в него элементы старого среза и новые элементы;
* Для копирования элементов из одного среза в другой можно использовать функцию `copy`; она принимает два аргумента –
  целевой срез и исходный срез, и возвращает количество фактически скопированных элементов;
* Увеличение размера массива при добавлении элементов выполняется путем удвоения его размера, что позволяет снизить
  количество выделений памяти и гарантировать константное время добавления одного элемента в среднем;
* Встроенная функция `append` может использоваться для добавления одного элемента, нескольких элементов или даже другого
  среза; например: `x = append(x, 1, 2, 3)` или `x = append(x, x...)`;
* `x...` - распаковка среза - используется для передачи каждого элемента, например в функцию `append`, в качестве
  отдельного аргумента;
* Для корректной работы со срезами важно помнить, что хотя элементы базового массива доступны косвенно, указатель среза,
  его длина и емкость не являются ссылочными; для обновления их требуется присваивание, например: `runes = append(runes,
  r)`;
* Обновление переменной среза требуется не только при вызове функции `append`, но и для любой функции, которая может
  изменить длину или емкость среза, или сделать его ссылающимся на другой базовый массив;
* `Вариадическая функция` – функция, которая принимает переменное количество аргументов; объявление вариадической
  функции выглядит как функция с аргументом `y ...int`; например, можно использовать вариадическую
  функцию `appendInt(x []int, y ...int)` для имитации встроенной функции append.

____

### 4.2.2 Работа со срезами "на лету"

* Изменение элементов среза `"на лету"` позволяет обрабатывать данные, не привлекая дополнительную память;
* Срезы можно использовать для реализации стека: добавление элемента - `stack := append(stack, v)`, получение вершины
  стека - `top := stack[len(stack) - 1]`, удаление элемента - `stack = stack[:len(stack) - 1]`;
* Чтобы удалить элемент из `середины среза` и сохранить порядок элементов, можно использовать функцию `copy`:
  ``` go
  func remove(slice []int, i int) []int {
      copy(slice[:i], slice[i+1:])
      return slice[:len(slice) - 1]
  }
  ```
* Если порядок элементов не важен, можно просто перенести последний элемент на место удаляемого:
  ``` go
  func remove(slice []int, i int) []int {
      slice[i] = slice[len(slice) - 1]
      return slice[:len(slice) - 1]
  }
  ```
* Эффективное использование срезов может быть полезным и экономичным с точки зрения использования памяти, хотя требует
  особой внимательности при работе с данными.

____

## 4.3. Хеш-таблица

* `Хеш-таблица (map)` в Go представляет собой `неупорядоченную коллекцию пар ключ-значение`, где все ключи уникальны и
  значения могут быть найдены, обновлены или удалены с использованием в среднем константного количества сравнений
  ключей (`O(1)`);
* Тип карты записывается как `map[K]V`, где `K` и `V` являются типами ключей и значений соответственно;
* Для создания `map` используется встроенная функция `make`, например:  `ages := make(map[string]int)`;
* `Map` можно создать с использованием литералов: `ages := map[string]int{"alice": 31, "charlie": 34}`;
* Для удаления элемента из `map` используется встроенная функция `delete`: `delete(ages, "alice")`;
* Итерация по элементам `map` варьируется от одного запуска программы к другому, для определенного порядка итерации
  нужно явно сортировать ключи;
* Нулевым значением для типа `map` является `nil`, большинство операций с ним выполняются безопасно, но сохранение
  значений в нулевом `map` вызовет `panic`;
* Для проверки наличия элемента в `map`, можно использовать двойное значение переменной, например: `age, ok :=
  ages["bob"]`;
* `Map` нельзя сравнивать друг с другом, единственное разрешенное сравнение - сравнение с `nil` ;
* Так как все ключи `map` различны, `map` может служить в качестве множества `(set)`;
* Ключи в `map` должны быть сравниваемыми, поэтому ключами срезы не могут быть напрямую; однако можно использовать
  вспомогательную функцию для преобразования срезов в строки, сохраняющих условия равенства исходных срезов;
* Использование вспомогательной функции для преобразования ключей позволяет применять подходы с использованием
  `map[string]bool` для любых несравниваемых типов ключей, а также для сравниваемых типов ключей, требующих особого
  определения равенства, например, сравнение без учета регистра для строк;
* Использование `map` для подсчета количества вхождений различных символов `Unicode` позволяет легко и эффективно решать
  задачи в документах с разными наборами символов, поскольку отслеживаются только встречающиеся символы;
* Встроенный метод `ReadRune` из пакета `bufio` позволяет декодировать символы `Unicode` в тексте, обрабатывая
  корректные и некорректные `UTF-8` коды;
* Вложенные составные типы в значении `map`, такие как `map` или срезы, позволяют создавать гибкую и полезную структуру
  данных для организации и сохранения связей между строками (`map[string][]string{}`).

____

## 4.4. Структуры

* `Структура` в Go - это `агрегированный тип данных`, объединяющий нуль или более именованных произвольных типов в
  единое целое;
* Каждое значение в структуре называется `полем`, и к ним можно получить доступ через запись с точкой (например,
  `dilbert.Name`);
* Структуры могут быть переданы функциям, возвращаться из них и храниться в массивах;
* В Go поле структуры экспортируется, если его имя начинается с `прописной буквы`;
* Именованный структурный тип `S` может объявить поле с типом указателя `*S`, что позволяет создавать рекурсивные
  структуры данных, такие как связанные списки и деревья;
* Нулевое значение для структуры состоит из нулевых значений каждого из ее полей;
* Тип структуры без полей называется пустой структурой `struct{}` и может использоваться в качестве значения для
  множества с ключами в `map`.
* Пример структуры:
  ``` go
  type Employee struct {
    ID int
    Name string
    Address string
    DoB time.Time
    Position string
    Salary int
    ManagerID int
  }
  ```
* Пример использования указателя на структуру для доступа к полям:
  ``` go
  position := &dilbert.Position
  *position = "Senior" + *position
  ```

____

### 4.4.1 Структурные литералы

* Структурные литералы в Golang имеют две разновидности: с указанием значений для каждого поля в правильном порядке и с
  перечислением некоторых или всех имен полей с соответствующими значениями;
* Если поле в структурном литерале опущено, оно получает нулевое значение соответствующего типа;
* Значения структур могут быть переданы как аргументы в функцию и быть возвращены из нее;
* Большие структурные типы обычно передаются в функции или возвращаются из них косвенно с помощью указателя для
  повышения эффективности;
* Если функция должна модифицировать свой аргумент, передача через указатель становится обязательной;
* Можно использовать сокращенную запись для создания и инициализации структурной переменной и получения ее
  адреса (`p := &Person{"John", 30}`);
* Примеры:
	* Создание структуры с использованием разных видов литералов:
  ``` go
  type Person struct {
      name    string
      age     int
      address struct {
          street string
          city   string
      }
  }
  
  person := Person{
      name: "John",
      age:  30,
      address: struct{ street, city string }{
          street: "123 Main St",
          city:   "New York",
      },
  }
  ```
	* Функция, масштабирующая Point с использованием некоторого коэффициента:
  ``` go
  func Scale(p Point, factor int) Point {
     return Point{p.X * factor, p.Y * factor}
  }
  ```
	* Передача структуры в функцию через указатель для модификации аргумента:
  ``` go 
  func AwardAnnualRaise(e *Employee) {
      e.Salary = e.Salary * 105 / 100
  }
  ```
	* Сокращенная запись для создания и инициализации структурной переменной и получения ее адреса:
	  `pp := &Point{1, 2}`

____

### 4.4.2 Сравнение структур

* Структуры в Go могут быть сравнимы, если все их поля являются сравнимыми (например, `int`, `string`, `bool`).
* Для сравнения двух структур используются операторы `==` или `!=`, которые последовательно сравнивают соответствующие
  поля каждой структуры.
* Операция `==` возвращает `true`, если все поля двух структур равны, в противном случае возвращает `false`.
* Сравниваемые структурные типы могут использоваться в `качестве` ключа в `map`.

____

### 4.4.3 Встраивание структур и анонимные поля

* Встраивание структур позволяет использовать именованный структурный тип в качестве анонимного поля другого
  структурного типа, обеспечивая удобное синтаксическое сокращение для доступа к полям и методам встроенного типа; это
  упрощает код и делает его более читаемым.
  Пример:
  ``` go
  type Point struct {
    X, Y int
  }
  
  type Circle struct {
    Point
    Radius int
  }
  ```
* Анонимные поля - `поля структуры`, которые имеют тип, но не имеют имени; тип поля должен быть именованным типом или
  указателем на именованный тип, а имя поля неявно определяется его типом;  
  Пример:
  ``` go
  type Circle struct {
      Point
      Radius int
  }
  ```
* Благодаря встраиванию `анонимных полей`, можно обращаться к полям этих типов без указания промежуточных имен, упрощая
  обращение к полям вложенных структур;  
  Пример:
  ``` go
  var c Circle
  c.X = 8
  c.Y = 8
  c.Radius = 5
  ```
* Встраивание структур также позволяет получать `методы встроенного типа` для типа внешней структуры, обеспечивая
  `механизм композиции` и `объектно-ориентированного программирования` в Go;  
  Пример:
  ``` go
  type Point struct {
    X, Y int
  }

  func (p Point) Distance() float64 {...}

  type Circle struct {
    Point
    Radius int
  }

  var c Circle
  distance := c.Distance() // вызывает Point.Distance() для c.Point
  ```
* Несмотря на возможность использования сокращенной записи для доступа к полям и методам встроенного типа, структурный
  литерал должен следовать форме объявления типа, поэтому простое указание значений полей без их имен не будет
  допустимо;  
  Пример:
  ```  go
  c := Circle{Point{8, 8}, 5} // верно
  c := Circle{8, 8, 5} // ошибка компиляции
  ```
* `Композиция` в Go - это механизм, который позволяет объединять несколько типов в один тип, подобно наследованию в
  других языках программирования. Он позволяет одному типу включать в себя другой тип как поле. При использовании
  композиции, все методы, свойства и функциональность включенного типа становятся доступными для включающего типа,
  который может дополнительно определять свои собственные методы и свойства;
* В Go `композиция` и `наследование` имеют свои отличия:

	1. `Наследование` - это механизм, который позволяет создавать новый тип на основе существующего типа, который может
	   использовать и переопределить методы базового типа. В то время как `композиция` - это механизм, который позволяет
	   включать один тип в другой тип как поле.
	2. В наследовании подтип наследует каждый метод базового типа, включая его состояние. В композиции тип включает в
	   себя
	   другой тип как поле, но не наследует его состояние.
	3. При использовании композиции, включающий тип может использовать методы включенного типа как свои собственные
	   методы,
	   но не может изменять их поведение. В наследовании подтип может переопределить методы базового типа и изменить их
	   поведение.
	   В целом, композиция и наследование имеют очень разные цели и могут использоваться в разных ситуациях в
	   зависимости от
	   потребностей программы.

____

## 4.5. JSON

* `JSON (JavaScript Object Notation)` - стандартная запись для передачи и получения структурированной информации;
  существуют альтернативы, такие как `XML`, `ANS.1` и `Google's Protocol Buffers`, но `JSON` является наиболее
  распространенным из-за простоты, удобочитаемости и всеобщей поддержки;
* Go предлагает превосходную поддержку кодирования и декодирования `JSON` с помощью стандартной
  библиотеки `encoding/json`, а также поддерживает другие форматы, такие как `encoding/xml`, `encoding/asn1` и другие,
  со схожими API;
* `JSON` представляет собой кодирование значений `JavaScript` (строк, чисел, логических значений, массивов и объектов) в
  текстовом формате `Unicode`; он эффективен и хорошо читается, что делает его идеальным для представления
  фундаментальных типов данных и составных типов, таких как `массивы`, `срезы`, `структуры` и карта `"map"`;
* Преобразование структуры данных Go (например, movies) в `JSON` называется `маршалингом` и выполняется с помощью
  функции `json.Marshal`: `data, err := json.Marshal(movies)`; результат - байтовый срез, содержащий текстовое
  представление данных в формате JSON;
* Чтобы получить более читаемое представление `JSON` для людей, можно использовать функцию `json.MarshalIndent`, которая
  добавляет отступы и форматирование: `data, err := json.MarshalIndent(movies, "", "  ")`;
* `Маршалинг` использует `имена полей структуры` Go в `качестве имен полей объектов JSON` и маршализует
  `только экспортируемые  поля` (с прописной первой буквой); `дескрипторы` полей могут быть использованы для указания
  альтернативных имен полей `JSON` и других параметров: `Year int json:"released"`;
* Противоположная операция маршалингу - `демаршалинг`, заключается в декодировании `JSON` и заполнении структуры данных
  Go; выполняется с помощью функции `json.Unmarshal`: `err = json.Unmarshal(data, &titles)`; позволяет выбирать, какие
  части `JSON` будут декодированы, а какие отброшены, определяя подходящие структуры данных Go;
* Веб-службы часто предоставляют интерфейс `JSON` для обмена данными, и мы можем выполнить `HTTP/S-запрос` для получения
  нужной информации в формате `JSON`;
* Для работы с API сервисов, таких как Github, необходимо создать специальные структуры и константы для представления
  данных (например, см. файл github.go);
* Важно помнить, что названия полей структуры должны начинаться с `заглавной буквы`, даже если имена полей в `JSON`
  названы `строчными буквами`. Поскольку сопоставление имен полей и JSON не учитывает регистр символов, дескриптор поля
  нужен только при наличии знака подчеркивания в имени JSON;
* Чтобы сформировать корректный запрос с использованием параметров, используйте функцию `url.QueryEscape`, чтобы символы
  со специальными значениями, такие как `?` и `&`, сохраняли свое значение;
* Для декодирования `JSON` можно использовать функцию `json.Unmarshal` или потоковый декодер `json.Decoder`, который
  позволяет декодировать несколько последовательных объектов JSON из одного потока;
* Для красивого форматирования результатов запроса можно использовать разные подходы: таблицы с фиксированной шириной
  столбцов или шаблоны (например, см. файл issues.go).

____

## 4.6. Текстовые и HTML-шаблоны

* Пакеты `text/template` и `html/template` используются для разделения форматирования и кода в Go, позволяя подставлять
  значения переменных в текстовые или HTML-шаблоны;
* Шаблон состоит из строки или файла, содержащего фрагменты в двойных фигурных скобках `{{...}}`,
  называемые `"действиями (action)"`, которые изменяют поведение программы по умолчанию;
* В действиях используется язык шаблонов, позволяющий выводить значения, выбирать поля структуры, вызывать функции и
  методы, управлять потоком и создавать другие шаблоны;
* Текущее значение в действии записывается как точка `.`, которая изначально указывает на параметр шаблона;
* Запись `|` в действии передает результат одной операции в другую, аналогично конвейеру оболочки
  Unix (`{{.CreatedAt | daysAgo}}`);
* Создание и вывод шаблона происходит в два этапа: сначала нужно выполнить синтаксический анализ шаблона в подходящее
  внутреннее представление, а затем выполнить его для конкретных входных данных;
* Вспомогательная функция `template.Must` упрощает обработку ошибок (выполняет синтаксический анализ шаблона) и
  проверяет нет ли ошибок, иначе вызывает панику `(panic)`;
* Пакет `html/template` автоматически экранирует специальные символы и последовательности в строках HTML, JavaScript,
  CSS
  и URL, что помогает избежать атак с помощью инъекций;
* Автоматическое экранирование для полей с данными HTML можно подавить с помощью именованного строкового типа
  `template.HTML`, а для JavaScript, CSS и URL - с использованием аналогичных имен типов.
  Пример:
  ``` go
  type Page struct {
      Title string
      Content template.HTML
  }
  
  func main() {
      page := Page{
          Title: "My Page",
          Content: "<h1>Hello, world!</h1>",
      }
  
      tmpl, err := template.New("page").Parse(`
          <!DOCTYPE html>
          <html>
              <head>
                  <title>{{.Title}}</title>
              </head>
              <body>
                  {{.Content}}
              </body>
          </html>
      `)
      if err != nil {
          panic(err)
      }
  
      err = tmpl.Execute(os.Stdout, page)
      if err != nil {
          panic(err)
      }
  }
  ```

____