# 4.1 Массивы

Представляет собой последовательность фиксированной длины из нуля или более элементов определенного типа.

> Из-за фиксированной длины массивы редко используются в Go.

Срезы, которые могут увеличиваться и уменьшаться, являются гораздо более гибкими, но, чтобы понять срезы, нужно понять
массивы.

Доступ к элементу осуществляется через индекс. Индексы значений начинаются с `0` до n-1 длины массива. Функция len
возвращает количество элементов массива.

``` go
var a [3]int // Массив из трех целых чисел
fmt.Println(a[0]) // "0" - значение по умолчанию для int. Вывод первого элемента.
fmt.Println(a[len(a)-1]) // "0" - /--/. Вывод последнего элемента a[2].

// Вывод знаений индексов и элементов.
for i, v := range a {
    fmt.Printf("%d %d\n", i, v)
}

// Вывод только значений.
for _, v := range a {
    fmt.Printf("%d\n", v)
}
```

По умолчанию, элементам новой переменной массива, изначально присваиваются нулевые значения типа элемента (для чисел
значение `0`). Для инициализации массива списком значений можно использовать **_литерал массива_**:

``` go
var q [3]int = [3]int{1, 2, 3}
var r [3]int = [3]int{1, 2}
fmt.Println(r[2]) // "0" - нулевое значение int
```

Если в литерале массива на месте длины находится троеточие `...`, то длина массива определяется количеством
инициализаторов. Определение `q` можно упростить до:

``` go
q := [...]int{1, 2, 3}
fmt.Printf("%T\n", q) // "[3]int"
```

Размер массива является **частью его типа**, так что типы `[3]int` и `[4]int` различны. Размер должен быть константным
выражением, т.е. выражением, значение которого может быть вычислено во время компиляции программы.

``` go
q := [3]int{1, 2, 3}
q = [4]int{1, 2, 3, 4} // Ошибка компиляции: нельзя присвоить [4]int переменной типа [3]int
```

Синтаксис литерала для массивов, срезов, хеш-таблиц и структур подобен. В коде выше используется упорядоченный список
значений, но можно также указать список пар `индекс-значение`:

``` go
type Currency int

const (
    USD Currency = iota
    EUR
    GBP
    RUB
)

symbol := [...]string{USD:"$", EUR:"€", GBP:"£", RUB:"₽"}

fmt.Println(RUB, symbor[RUB]) // "3 ₽"

```

В этом случае индексы могут появляться в любом порядке, а некоторые из них могут быть опущены. Неуказанные значения
получают нулевое значение типа элемента:

``` go
r := [...]int{99:-1}
```

Этот код определяет массив `r` со ста элементами, среди которых ненулевым является только последний элемент, его
значение равно `-1`.

Если тип элемента массива является **сравниваемым**, то таким же является и тип массива, так что можно сравнивать два
массива такого типа с помощью оператора `==`, который сообщает, все ли соответствующие элементы массивов равны.
Оператор `!=` является отрицанием оператора `==`:

``` go
a := [2]int{1, 2}
b := [...]int{1, 2}
c := [2]int{1, 3}
fmt.Println(a == b, a == c, b == c) // "true false false"
d := [3]int{1, 2}
fmt.Println(a == d) // Ошибка компиляции: разные типы [2]int и [3]int
```

Рассмотрим в качестве примера функцию `Sum256` из пакета `crypto/sha256`, которая генерирует криптографический хеш, или
**дайджест** `SHA256` сообщения, хранящегося в произвольном байтовом срезе.
Дайджест состоит из 256 битов, поэтому его типом является [32]byte. Если два дайджеста совпадают, то очень вероятно, что
соответствующие сообщения одинаковы. Если дайджесты различаются, то различаются и сообщения. Пример (см. sha256.go)
выводит и сравнивает дайджесты `SHA256` для `x` и `X`.

Эти входные данные различаются только одним битом, но в дайджестах различны примерно половина битов.

> Символы преобразования `Printf`:
>* `%x` выводит все элементы массива или среза байтов в шестнадцатеричном формате,
>* `%t` - выводит булево значение,
>* `%T` - выводит тип значения.

При вызове функции `Sum256` копия каждого значения аргумента присваивается переменной соответствующего параметра, так
что функция получает копию, а не оригинал. Передача таким образом больших массивов может быть неэффективной, а любые
изменения, вносимые функцией в элементы массива, будут влиять **только на копию**, но **_не на оригинал_**.
Поэтому Go работает с массивами как с любым другим типом, но это поведение отличается от поведения языков, которые
неявно передают массивы **по ссылке**.

Конечно, можно явно передать указатель на массив, так что любые изменения, которые функция будет делать в элементах
массива, будут видны вызывающей функции. Приведенная ниже функция заполняет нулями содержимое массива `[32]byte`:

``` go
func zero(ptr *[32]byte) {
    for i := range ptr {
        ptr[i] = 0
    }
}
```

Литерал массива `[32]byte{}` дает нам массив из 32 байтов. Каждый элемент массива имеет нулевое значение для
типа `byte`, которое просто равно нулю. Можно использовать этот факт для написания другой версии функции `zero`:

``` go
func zero(ptr *[32]byte) {
    *ptr = [32]byte{}
}
```

Применение указателя на массив оказывается эффективным и позволяет вызываемой функции изменять переменные вызывающей
функции, но массивы остаются негибким решением из-за присущего им фиксированного размера. Например, функция `zero` не 
примет указать на переменную `[16]byte`. Нет также никакого способа добавления или удаления элементов массива.
По этим причинам, за исключением особых случаев, таких как хэш `SHA256` фиксированного размера, массивы в качестве
параметров функции используются редко. Вместо массивов, обычно используют срезы.

