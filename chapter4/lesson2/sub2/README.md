# 4.2.2 Работа со срезами "на лету"

Рассмотрим больше примеров функций, которые, подобно функциям `reverse` и `rotate`, изменяют элементы среза "на лету",
без привлечения дополнительной памяти.

Функция `nonempty` для данного списка строк возвращает только непустые строки (см. nonempty.go:nonempty())

Тонкостью данной функции является то, что входной и выходной срезы разделяют один и тот же базовый массив. Это позволяет
избежать необходимости выделять еще один массив, хотя, конечно же, содержимое `data` частично перезаписывается, как
доказывает вторая инструкция вывода(см. nonempty.go:main)

Таким образом, мы должны, выполнять присваивание `data=nonempty(data)`.
Функцию `nonempty` можно переписать с использованием функции `append` (см. nonempty.go:nonempty2)

Какой бы вариант не был выбран, такое использование массива требует, чтобы для каждого входного значения генерировалось
не более одного выходного значения. Это требование выполняется для множества алгоритмов, которые отфильтровывают
элементы последовательности или объединяют соседние. Такое сложное использование срезов является **_исключением_**, а не
правилом, но в ряде случаев оно может оказаться ясным, эффективным и полезным.

Срез может быть использован для реализации стека. Для заданного изначально пустого среза `stack` поместить новое
значение в стек можно с помощью функции `append`:

``` go
stack := append(stack, v) //  внесение v в stack
```

Вершина стека представляет собой последние его элемент:

``` go
top := stack[len(stack) - 1] // вершина стека
```

Снятие элемента со стека выглядит следующим образом:

``` go
stack = stack[:len(stack) - 1] //  Удаление элемента из стека
```

Чтобы удалить элемент из середины среза, сохранив порядок оставшихся элементов, нужно использовать функцию `copy` для
переноса "вниз" на одну позицию элементов с более высокими индексами:

``` go
func remove(slice []int, i int) []int {
    copy(slice[:i], slice[i+1:])
    return slice[:len(slice) - 1]
}

func main() {
    s := []int{5, 6, 7, 8, 9}
    fmt.Println(remove(s, 2)) // "[5 6 8 9]"
}
```

Если нам необязательно сохранять порядок, можно просто перенести последний элемент на место удаляемого:

``` go
func remove(slice []int, i int) []int {
    slice[i] = slice[len(slice) - 1]
    return slice[:len(slice) - 1]
}

func main() {
    s := []int{5, 6, 7, 8, 9}
    fmt.Println(remove(s, 2)) // "[5 6 9 8]"
}
```

## Выводы:

* Изменение элементов среза `"на лету"` позволяет обрабатывать данные, не привлекая дополнительную память;
* Срезы можно использовать для реализации стека: добавление элемента - `stack := append(stack, v)`, получение вершины
  стека - `top := stack[len(stack) - 1]`, удаление элемента - `stack = stack[:len(stack) - 1]`;
* Чтобы удалить элемент из `середины среза` и сохранить порядок элементов, можно использовать функцию `copy`:
  ``` go
  func remove(slice []int, i int) []int {
      copy(slice[:i], slice[i+1:])
      return slice[:len(slice) - 1]
  }
  ```
* Если порядок элементов не важен, можно просто перенести последний элемент на место удаляемого:
  ``` go
  func remove(slice []int, i int) []int {
      slice[i] = slice[len(slice) - 1]
      return slice[:len(slice) - 1]
  }
  ```
* Эффективное использование срезов может быть полезным и экономичным с точки зрения использования памяти, хотя требует
  особой внимательности при работе с данными.