# 4.5 JSON

Запись объектов JSON (JavaScript Object Notation) является стандартной записью для пересылки и получения структурной
информации. JSON - не единственный способ такой записи. Аналогичной цели служат `XML`, `ANS.1`,
`Google's Protocol Buffers`, и каждый имеет свою нишу. Однако из-за простоты, удобочитаемости и всеобщей поддержки
наиболее широко используется именно `JSON`.

Go обладает превосходной поддержкой кодирования и декодирования этих форматов, предоставленной в пакетах стандартной
библиотеки `encoding/json`, `encoding/xml`, `encoding/asn1` и других, и все эти пакеты имеют схожие `API`.

`JSON` является кодированием значений JavaScript - строк, чисел, логических значений, массивов и объектов - в виде
текста в кодировке `Unicode`. Это эффективное, но удобочитаемое представление фундаментальных типов данных, и составных
типов - массивов, срезов, структур и карт `map`.

Фундаментальными типами `JSON` являются числа (в десятичной или научной записи), логические значения (true, false),
и строки, которые представляют собой последовательности `Unicode`, заключенные в двойные кавычки, с управляющими
последовательностями, начинающимися с обратной косой черты, как в Go, хотя в `JSON` последовательности `\Uhhh`
обозначают коды `UTF-16`, а не руны.

Эти фундаментальные типы могут быть рекурсивно скомбинированы с помощью массивов и объектов `JSON`. Массив `JSON`
представляет собой упорядоченную последовательность значений, записываемую как список с запятыми в качестве
разделителей, заключенный в квадратные скобки. Массивы `JSON` используются для кодирования массивов и срезов Go.
Объект `JSON` является отображением строк на значения, записываемым в виде последовательности пар `name:value`,
разделенных запятыми и заключенными в фигурные скобки. Объекты `JSON` используются для кодирования карт `map` Go (со
строковыми ключами) и структур, например:

``` go
boolean true
number  273.15
string  "She said \"Hello, World!\""
array   ["gold", "silver", "bronze"]
object  {"year": 1980,
         "event": "archery",
         "medals": ["gold", "silver", "bronze"]}

```

Рассмотрим приложение (см. movie.go), которое собирает кинообзоры и предлагает рекомендации. Его тип данных `Movie` и
типичный список значений объявляются ниже. (Строковые литералы после объявлений полей `Year` и `Color` являются
**_дескрипторами полей (field tags)_**).

Такие структуры данных отлично подходят для `JSON` и легко конвертируются в обоих направлениях. Преобразование структуры
данных Go, наподобие `movies` в `JSON` называется **_маршалингом (marshaling)_**. Маршалинг осуществляется с помощью
`json.Marshal`:

``` go
data, err := json.Marshal(movies)
if err != nil {
	log.Fatalf("Сбой маршалинга JSON: %s", err)
}
fmt.Printf("%s\n", data)
```

`Marshal` генерирует байтовый срез, содержащий очень длинную строку без лишних пробелов:

``` go
[{"Title":"Casablanca","released":1942,"Actors":["Humphrey Bogart","Ingrid Bergman"]},{"Title":"Cool Hand Luke","released":1967,"color":true,"Actors":["Paul Newman"]},{"Title":"Bullitt","released":1968,"color":true,"Actors":["Steve McQueen","Jacqueline Bisset"]}]
```

Это компактное представление содержит всю необходимую информацию, но его трудно читать. Для чтения человеком можно
использовать функцию `json.MarshalIndent`, которая дает аккуратно отформатированное представление с отступами. Два
дополнительных аргумента определяют префикс для каждой строки вывода и строку для каждого уровня отступа:

```json
[
  {
    "Title": "Casablanca",
    "released": 1942,
    "Actors": [
      "Humphrey Bogart",
      "Ingrid Bergman"
    ]
  },
  {
    "Title": "Cool Hand Luke",
    "released": 1967,
    "color": true,
    "Actors": [
      "Paul Newman"
    ]
  },
  {
    "Title": "Bullitt",
    "released": 1968,
    "color": true,
    "Actors": [
      "Steve McQueen",
      "Jacqueline Bisset"
    ]
  }
]

```

Маршалинг использует имена полей структуры Go в качестве имен полей объектов `JSON` (используя рефлексию). Маршализуются
только экспортируемые поля. Вот почему мы использовали прописные первые буквы для всех имен полей Go.

Можно было заметить, что имя поля `Year` изменено в выводе на `released`, а поле `Color` - на `color`. Дело в
**_дескрипторах полей_**. Дескриптор поля представляет строку метаданных, связанную с полем структуры во время
компиляции:

``` go
Year int `json:"released"`
Color bool `json:"color, omitempty"`
```

Дескриптор поля может быть любым строковым литералом, но по соглашению он интерпретируется как список пар `key:"value"`,
разделенных пробелами.
Поскольку они содержат двойные кавычки, дескрипторы полей обычно записываются как неформатированные строковые литералы.
Ключ `json` управляет поведением пакета `encoding/json` и другими пакетами `encoding/...`, следующими этому соглашению.

В первой части дескриптора поля `json` определяется альтернативное имя `JSON` для поля Go. Дескрипторы полей часто
используются для указания идиоматических имен `JSON`, таких как `total_count` для поля `Go` с именем `TotalCount`.

Дескриптор для `Color` имеет дополнительный параметр, `omitempty`, который указывает, что если поле имеет нулевое
значение своего типа (здесь - `false`) или иным образом оказывается пустым, никакого вывода `JSON` не должно быть.
Очевидно, что для черно-белого фильма `Casablanca` `JSON`-вывод не имеет поля `color`.

Обратная к маршалингу операция, декодирования `JSON` и заполнения структуры данных Go, называется восстановлением
объекта или **_демаршалингом (unmarshalling)_** и выполняется с помощью `json.Unmarshal`. В приведенном коде (см.
movie.go) данные `JSON` о фильмах демаршализуются в срез структур, единственным полем которых является `Title`.
Путем определения подходящих структур данных Go мы можем выбрать, какие части входных данных `JSON` будут декодированы,
а какие отброшены. При возврате из функции `Unmarshal` она заполняет срез информацией `Title`. Все другие имена `JSON`
игнорируются.

``` go
var titles []struct{ Title string }
if err = json.Unmarshal(data, &titles); err != nil {
	log.Fatalf("Сбой демаршалинга JSON: %s", err)
}
fmt.Println(titles) // "[{Casablanca} {Cool Hand Luke} {Bullitt}]"
```

Многие веб-службы предоставляют интерфейс `JSON` - мы делаем `HTTP/S-запрос` и получаем в ответ нужную информацию в
формате `JSON`. Для иллюстрации запросим `Github` с использованием интерфейса веб-службы. Сначала определим необходимые
типы и константы (см. github.go)

Как и раннее, имена всех полей структуры должны начинаться с прописной буквы, даже если их имена не являются
именами `JSON`. Однако процесс сопоставления, который связывает имена `JSON` с именами полей структур Go при
демаршалинге не учитывает регистр символов, так что дескриптор поля необходимо использовать только тогда, когда в
имени `JSON` есть знак подчеркивания. Ответ `GitHub` содержит значительно больше информации, чем показано в примере.

Функция `SearchIsuues` выполняет HTTP-запрос и декодирует JSON-результат. Поскольку запрос, представленный
пользователем, может содержать символы наподобие `?` и `&`, которые имеют специальное значение в URL, мы используем
функцию `url.QueryEscape`, чтобы гарантировать, что эти символы будут восприняты буквально.

В предыдущих примерах для декодирования всего содержимого байтового среза как единого `JSON-объекта` использовалась
функция `json.Unmarshal`. Для разнообразия в этом примере используется **_потоковый_** декодер `json.Decoder`, который
может декодировать несколько последовательных объектов `JSON` из одного и того же потока, хотя нам эта возможность здесь
не требуется. Как и следует ожидать, существует соответствующий кодировщик `json.Encoder`.

Вызов `Decode` заполняет переменную `result`. Существуют различные способы красиво отформатировать ее значение.
Простейший продемонстрированный способ (см. issues.go) - использование текстовой таблицы с фиксированной шириной
столбца, но так же можно использовать способ, основанный на шаблонах.

Аргументы командной строки указывают параметры поиска. Показанная ниже команда запрашивает список ошибок среди проектов
Go, связанных с декодированием JSON:
``` go
repo:golang/go is:open json decoder
```