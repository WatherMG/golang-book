# 6.2 Методы с указателем в роли получателя

Вызов функции создает копию каждого значения аргумента, поэтому, если функции необходимо обновить переменную или если
аргумент является настолько большим, что желательно избежать его копирования, следует передавать адрес переменной с
помощью указателя. То же самое справедливо и для методов, которым необходимо обновить переменную получателя: их следует
присоединять к типу указателя такому как `*Point`:

``` go
func (p *Point) ScaleBy(factor float64) {
    p.X = factor
    p.Y = factor
}
```

Именем данного метода является `(*Point).ScaleBy`. Скобки необходимы - без них выражение будет трактоваться
как `*(Point.ScaleBy)`.

В реальных программах соглашение диктует, что если какой-либо метод `Point` имеет получатель-указатель, то `все` методы
`Point` должны иметь указатель в качестве получателя, даже те, которым это не требуется в обязательном порядке. Мы
нарушили это правило для `Point`, чтобы показать обе разновидности методов.

Именованные типы `(Point)` и указатели на них `(*Point)` - единственные типы, которые могут появляться в объявлении
получателя. Кроме того, чтобы избежать неоднозначности, объявления методов не разрешены для именованных типов, которые
сами являются типами указателей:

``` go
type P *int

func (P) f() {/*...*/} // Ошибка компиляции: неверный тип получателя
```

Метод `(*Point).ScaleBy` может быть вызван с помощью предоставления получателя `*Point`, например так:

``` go
r := &Point{1, 2}
r.ScaleBy(2)
fmt.Println(*r) // {2, 4}
```

Или так:

``` go
p := Point{1, 2}
pptr := &p
pprt.ScaleBy(2)
fmt.Println(p) // {2, 4}
```

Или вот так:

``` go
p := Point{1, 2}
(&p).ScaleBy(2)
fmt.Println(p) // {2, 4}
```

Но последние два варианта несколько громоздки. К счастью, здесь нам помогает язык. Если получатель `p`
является `переменной` типа `Point`, но методу необходим получатель `*Point`, можно использовать сокращенную
запись `p.ScaleBy(2)`.

При которой компилятор выполнит неявное получение адреса из `&p` этой переменной. Это работает только для переменных,
включая поля структур наподобие `p.X` и элементов массивов и срезов наподобие `perim[0]`. Мы не можем вызвать метод
`*Point` для не адресуемого получателя `Point`, так как нет никакого способа получения адреса временного значения.

``` go
Point{1, 2}.ScaleBy(2) // Ошибка компиляции: невозможно получить адрес литерала Point
```

Но мы **_можем_** вызвать метод `Point` наподобие `Point.Distance` с получателем `*Point`, поскольку есть способ
получить значение из адреса: нужно просто загрузить значение, на которые указывает получатель. Компилятор, по сути,
вставляет неявный оператор `*`. Два следующих примера вызова являются эквивалентными:

``` go
pptr.Distance(q)
(*pptr).Distance(q)
```

Подведем итоги, так как недостаточное понимание в этой области зачастую приводит к путанице. В каждом корректном
выражении вызова метода истинным является только одно из трех перечисленных утверждений.

Либо аргумент получателя имеет тот же тип, что и параметр получателя, например оба имеют тип `T` или оба имеют тип `*T`:

``` go
Point{1, 2}.Distance(q) // Point
pptr.ScaleBy(2)         // *Point
```

Либо аргумент получателя является `переменной` типа `T`, а параметр получателя имеет тип `*T`. Компилятор неявно
получает адрес переменной:

``` go
p.ScaleBy(2) // Неявное (&p)
```

Либо аргумент получателя имеет тип `*T`, а параметр получателя имеет тип `T`. Компилятор неявно разыменовывает
получателя, другими словами, загружает соответствующее значение:

``` go
pptr.Distance(q) // Неявное (*pptr)
```

Если все методы именованного типа `T` имеют тип получателя `T` (не `*T`), то копирование экземпляров этого типа
безопасно. Вызов любого из его методов обязательно делает копию. Например, значения `time.Duration` свободно копируется,
в том числе в качестве аргументов функции. Но если какой-либо метод имеет в качестве получателя указатель, следует
избегать копирования экземпляров `T`, потому что это может нарушать внутренние инварианты. Например, копирование
экземпляра `bytes.Buffer` может привести к тому, что оригинал и копия будут псевдонимами одного и того же базового
массива байтов, и последующие вызовы методов будут иметь непредсказуемые результаты.

## Выводы:

* При вызове функции создается копия каждого значения аргумента. Если нужно обновить переменную или избежать
  копирования, нужно передать в функцию адрес переменной с помощью указателя. То же самое относится к методам - их нужно
  присоединять к типу указателя `*T`;
* Имя метода выглядит так: `(*T).Method`. Скобки необходимы, без них выражение будет трактоваться как `*(T).Method`;
* По соглашению, если какой-то метод типа T имеет получатель в виде указателя, то все методы этого типа должны иметь
  указатель в качестве получателя, даже для тех, где он не обязателен;
* Получатель в объявлении метода может быть только именованным типом `T` или указателем на него `*T`;
* Объявления методов не разрешены для именованных типов, которые сами являются типами указателей;
* Если получатель является переменной типа `T`, но методу необходим получатель `*T`, можно использовать сокращенную
  запись `p.Method()`. При такой инструкции компилятор выполнит неявное получение адреса из `&p` этой переменной. Это
  работает для только для переменных, включая поля структур, наподобие `p.X` и элементов массивов и срезов,
  наподобие `perim[0]`;
* Нельзя вызвать метод `*T` для не адресуемого получателя `T`, так как нет никакого способа получения адреса временного
  значения;
* Если: `r := T{1, 2}; pptr := &r` мы можем вызвать метод типа `T` наподобие `T.Method()` с получателем типа `*T`,
  поскольку есть способ получить значение из адреса. Компилятор вставит неявный оператор `*`;
* В каждом корректном выражении вызова метода истинным является только одно из трех утверждений:
    * Либо аргумент получателя имеет тот же тип, что и параметр получателя (оба имеют тип `*T` либо `T`);
    * Либо аргумент получателя является переменной типа `T`, а параметр получателя имеет тип `*T` - компилятор неявно
      получит адрес переменной `r.Method(2) // (&r)`;
    * Либо аргумент получателя имеет тип `*T`, а параметр получателя имеет тип `T` - компилятор выполнит разыменовывание
      получателя `pptr.Distance(q) // (*pptr)`.
* Если все метода именованного типа `T` имеют тип получателя `T` (не `*T`) - копирование экземпляров этого типа
  безопасно. Вызов любого из его методов обязательно делает копию.
* Если какой-то метод имеет в качестве получателя указатель, следует избегать копирования экземпляров `T`, так как это
  может нарушать внутренние инварианты. Например, копирование экземпляра `bytes.Buffer` может привести к тому, что
  оригинал и копия будут псевдонимами одного и того же базового массива байтов, последующие вызовы методов будут иметь
  непредсказуемые результаты.
* `Внутренние инварианты` - это ограничения на значения полей и состояние объекта, которые должны соблюдаться для
  правильной работы программы или модуля. Например, для структуры, представляющей дерево, внутренний инвариант может
  заключаться в том, что каждый узел имеет не более двух потомков.























