# 6.2.1 Значение `nil` является корректным получателем

Так же, как некоторые функции допускают нулевые указатели в качестве аргументов, так и некоторые методы допускают
нулевые указатели в качестве их получателя, особенно если `nil` является полноценным нулевым значением типа, как в
случае карты или срезов. В приведенном далее простом связанном списке целых чисел значение `nil` представляет пустой
список:

``` go
// IntList представляет собой связанный список целых чисел.
// Значение *IntList, равное `nil`, представляет пустой список
type IntList struct {
    Value int
    Tail *IntList
}

// Sum возвращает сумму элементов списка
func (list *IntList) Sum() int {
    if list == nil {
        return 0
    }
    return list.Value + list.Tail.Sum()
}
```

При определении типа, методы которого допускают нулевого значение получателя, желательно указать это в документирующих
комментариях, как это сделано выше.

Вот часть определения типа `Values` из пакета `net/url`:

``` go
net/url
package url

//Values отображает строковый ключ на список значений.
type Values map[string][]string

// Get возвращает первое значение, связанное с данным ключом, или "", если такового нет
func (v Values) Get(key string) string {
    if vs := v[key]; len(vs) > 0 {
        return vs[0]
    }
    return ""
}

// Add добавляет значение к ключу. Добавление выполняется к любым существующим значениям, связанным с ключом.
func (v Values) Add(key, value string) {
    v[key] = append(v[key], value)
}
```

Оно показывает, что представлением данного типа является карта, а так же предоставляет методы для доступа к карте,
значениями которого являются срезы строк - это `мультикарта`. Клиенты могут использовать его встроенные операторы
(make, литералы срезов, m[key] и т.д.) или его методы, или и то, и другое вместе, что им больше нравиться (см.
urlvalues.go)

В последнем вызове `Get` нулевой получатель ведет себя, как пустая карта. Мы могли бы эквивалентно записать вызов как
`Values(nil).Get("item")`, но выражение `nil.Get("item")` не будет компилироваться, потому что тип `nil` не определен.
Последний же вызов `Add` приводит к панике, поскольку он пытается обновить нулевую карту.

Поскольку `url.Values` имеет тип карты, а карты обращаются к своим парам "ключ-значение" косвенно (по ссылке), любые
обновления и удаления, которые делают вызовы `url.Values.Add` с элементами карты, видны вызывающей функции. Однако, как
и в случае обычных функций, любые изменения, которые метод делает с самой ссылкой, такие как установка ее значения
равным `nil` или ее перенаправление на другую карту, не будет видимо вызывающей функции.

## Выводы:

* Некоторые методы могут принимать нулевой указатель в качестве получателя, особенно для ссылочных типов данных, таких
  как карта или срез;
* Желательно указывать в комментариях, если методы типа допускают нулевое значение получателя;
* Для типа-карты можно использовать встроенные операторы (например, make, литералы срезов, m[key]) или его методы, или и
  то, и другое вместе;
* Если мы вызовем метод обновления карты, которая является нулевой - это приведет к панике;
* Карты обращаются к своим парам "ключ-значение" косвенно (по ссылке), из-за этого любые обновления и удаления, которые
  будут делать вызовы методов с элементами карты, будут видны вызывающей функции. Однако, как и для обычных функций,
  любые
  изменения, которые метод делает с самой ссылкой, например установка ее значения равным `nil` или ее перенаправление на
  другую карту - не будут видны вызывающей функции.