# 6.3 Создание типов путем встраивания структур

Рассмотрим тип `ColoredPoint` (см. coloredpoint.go).

Мы могли бы определить `ColoredPoint` как структуру из трех полей, но вместо этого `встраиваем` `Point` для
предоставления полей `X` и `Y`. Как мы видели в разделе 4.4.3 `встраивание` позволяет нам использовать синтаксические
сокращения для определения структуры `ColoredPoint`, которая содержит все поля `Point` плюс еще некоторые. При желании
мы можем выбрать поля `ColoredPoint`, которые были предоставлены встроенной структурой `Point` без упоминания
имени `Point`:

``` go
var cp ColoredPoint
cp.X = 1
fmt.Println(cp.Point.X) // 1
cp.Point.Y = 2
fmt.Println(cp.Y) // 2
```

Аналогичный механизм применим и к методам `Point`. Мы можем вызывать методы встроенного поля `Point` с использованием
получателя типа `ColoredPoint`, несмотря на то, что `ColoredPoint` не имеет объявленных собственных методов:

``` go
red := color.RGBA{255, 0, 0, 255}
blue := color.RGBA{0, 255, 0, 255}
var p = ColoredPoint{Point{1, 1}, red}
var q = ColoredPoint{Point{5, 4}, blue}
fmt.Println(p.Distance(q.Point)) // 5
p.ScaleBy(2)
q.ScaleBy(2)
fmt.Println(p.Distance(q.Point) // 10
```

Методы `Point` были `повышены` до методов `ColoredPoint`. Таким образом, встраивание допускает наличие сложных типов со
многими методами, при этом указанные типы создаются путем `композиции` полей, каждое из которых предоставляет несколько
методов.

Читатели, знакомые с объектно-ориентированными языками, основанными на классах, могут соблазниться провести параллели и
рассматривать `Point` как базовый класс, а `ColoredPoint` как подкласс (или производный класс) или интерпретировать
связь между этими типами, как если бы `ColoredPoint` "являлся" `Point`. Но это было бы ошибкой. Обратите внимание на
показанные выше вызовы `Distance`. Метод `Distance` имеет параметр типа `Point` но `q` не является `Point`, так что хотя
`q` и имеет встроенные поля этого типа, мы должны явно их указать. Попытка передачи `q` приведет к сообщению об ошибке:

``` go
p.Distance(q) // Ошибка компиляции: нельзя использовать `q (ColoredPoint)` как `Point`
```

`ColoredPoint` не является `Point`, но "содержит" `Point` и имеет два дополнительных метода (`Distance` и `ScaleBy`),
повышенных из `Point`. Если вы предпочитаете думать в терминах реализации, встроенное поле указывает компилятору на
необходимость генерации дополнительных `методов-оберток`, которые делегируют вызов объявленным методам что-то вроде
такого кода:

``` go
func (p ColoredPoint) Distance(q Point) float64 {
    return p.Point.Distance(q)
}

func (p *ColoredPoint) ScaleBy(factor float64) {
    p.Point.ScaleBy(factor)
}
```

Когда `Point.Distance` вызывается первым из этих `методов-оберток`, значением его получателя является `p.Point`, а
не `p`, и при этом нет никакого способа, которым метод мог бы обратиться к структуре `ColoredPoint`, в которую встроена
структура `Point`.

Типом анонимного поля может быть указателем на именованный тип. В этом случае поля и методы косвенно повышаются из
указываемого объекта. Добавление еще одного уровня косвенности позволяет нам совместно использовать общие структуры и
динамически изменять взаимоотношения между объектами. Приведенное ниже объявление `ColoredPoint` встраивает `*Point`:

``` go
type ColoredPoint struct {
    *Point
    Color color.RGBA
}

p := ColoredPoint{Point{1, 1}, red}
q := ColoredPoint{Point{5, 4}, blue}
fmt.Println(p.Distance(*q.Point)) // 5
q.Point = p.Point // p и q разделяет одну и ту же `Point`
p.ScaleBy(2)
fmt.Println(*p.Point, *q.Point) // {2 2} {2 2}
```

Структурный тип может иметь более одного анонимного поля. Если мы объявим `ColoredPoint` как

``` go
type ColoredPoint struct {
    Point
    color.RGBA
}
```

То значение этого типа будет иметь все методы типа `Point`, все методы `RGBA` и любые дополнительные методы,
непосредственно объявленные для `ColoredPoint`. Когда компилятор разрешает селектор как `p.ScaleBy` для вызова метода,
сначала он ищет непосредственно объявленный метод с именем `ScaleBy`, затем - метод, однократно повышенный из встроенных
полей `ColoredPoint`, после этого - дважды повышенный метод из встроенных внутри `Point` и `RGBA`, и т.д. Компилятор
сообщает об ошибке, если селектор является неоднозначным из-за того, что имеется два или более методов с одним именем с
одинаковым рангом повышения.

Методы могут быть объявлены только для именованных типов (наподобие `Point`) и указателей на них (`*Point`), но
благодаря встраиванию `неименованные` структурные типы также могут иметь методы (иногда это оказывается полезным).

Вот неплохая иллюстрация к сказанному. В приведенном примере показана часть простого кеша, реализованного с помощью двух
переменных уровня пакета, мьютекса и карты, которое он защищает:

``` go
var (
    mu sync.Mutex // Защищает карту
    mapping = make(map[string]string)
)

func Lookup(key string) string {
    mu.Lock()
    v := mapping[key]
    mu.Unlock()
    return v
}
```

Приведенная ниже версия функционально эквивалентна, но группирует эти две связанные переменные вместе в одну переменную
уровня пакета `cache`:

``` go
var cache = struct {
    sync.Mutex
    mapping map[string]string
} {
    mapping: make(map[string]string),
}

func Lookup(key string) string {
    cache.Lock()
    v := cache.mapping[key]
    cache.Unlock()
    return v
}
```

Новая переменная дает связанным с кешем переменным более выразительные имена, а поскольку в нее встроено
поле `sync.Mutex`, его методы `Lock` и `Unlock` повышаются до неименованного структурного типа, позволяя нам блокировать
`cache` с помощью самоочевидного синтаксиса.

## Выводы:

* Чтобы использовать синтаксические сокращения для всех полей, которые содержит встраиваемая структура, можно создавать
  типы путем встраивания структур;
* Можно выбрать поля одной структуры из второй структуры, без упоминания ее имени;
* При встраивании структур можно вызывать методы встроенного поля `T` с использованием получателя типа `TName`, даже
  если `Tname` не имеет собственных методов. Методы `T` будут доступны как методы `Tname`;
* Встраивание допускает наличие сложных типов со многими методами, при этом указанные типы создаются путем `композиции`
  полей, каждое из которых предоставляет несколько методов;
* Неверно рассматривать `T` как базовый класс, а `Tname`- как подкласс при встраивании структур (другие ООП языки);
* Типом анонимного поля может быть указатель на именованный тип. В этом случае поля и методы косвенно повышаются из
  указываемого объекта. Добавление еще одного уровня косвенности позволяет нам совместно использовать общие структуры и
  динамически изменять взаимоотношение между объектами;
* Тип `Tname` не является `T`, хоть и содержит его и имеет его методы, повышенные из `T`;
* Встроенное поле указывает компилятору на необходимость генерации дополнительных `методов-оберток`, которые делегируют
  вызов объявленным методам. Когда `Tname.T.Method` вызывается первым из этих методов-оберток, значением его получателя
  является `T` а не `Tname`;
* Структурный тип может иметь более одного анонимного поля. В таком случае, значение этого типа будет иметь все методы
  всех анонимных полей и свои собственные методы;
* `p.ScaleBy` - компилятор сначала ищет объявленный метод с именем `ScaleBy`, затем метод, однократно повышенный из
  встроенных полей `Tname`, после этого дважды повышенный метод из анонимных полей и т.д. Компилятор сообщит об ошибке,
  если селектор неоднозначный, т.к. имеются несколько методов с одним именем с одинаковым рангом повышения;
* Методы могут быть объявлены только для именованных типов и указателей на них `T` и `*T`, но благодаря встраиванию
  `неименованные` структурные типы также могут иметь методы.