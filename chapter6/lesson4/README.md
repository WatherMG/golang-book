# 6.4 Значения-методы и выражения-методы

Обычно мы выбираем и вызываем метод в одном выражении, как, например, в `p.Distance()`, но эти две операции можно
разделить. Селектор `p.Distance` дает нам `значение-метод (method value)`, функцию, которая связывает
метод `(Point.Distance)` со значением конкретного получателя `p`. Эта функция может быть вызвана без указания значения
получателя. Ей нужны только аргументы не являющиеся получателем:

``` go
p := Point{1, 2}
q := Point{4, 6}

distanceFromP := p.Distance         // Значение-метод
fmt.Println(distanceFromP(q))       // 5
var origin Point                    // {0, 0}
fmt.Println(distanceFromP(origin))  // 2.23606797749979, sqrt(5)

scaleP := p.ScaleBy // Значение-метод
scaleP(2)           // p становится (2, 4)
scaleP(3)           // затем (6, 12)
scaleP(10)          // затем (60, 120)
```

`Значения-методы` полезны, когда API пакета требует `значение-функцию`, а для клиента желаемым поведением для этой
функции является вызов метода для конкретного получателя. Например, функция `time.AfterFunc` вызывает `значение-функцию`
после заданной задержки. Приведенная программа использует ее для запуска ракеты `r` через 10 секунд:

``` go
type Rocket struct {/*...*/}
func (r *Rocket) Launch() {/*...*/}

r := new(Rocket)
time.ArfetFunc(10 * time.Second, func() { r.Launch()})
```

Синтаксис с использованием `значения-метода` оказывается более коротким:

``` go
time.AfterFunc(10 * time.Second, r.Launch)
```

Со `значениями-методами` тесно связаны `выражения-методы`. При вызове метода, в противоположность обычной функции, мы
должны указать получателя с помощью синтаксиса селектора. `Выражение-метод`, записываемое как `T.f` или `(*T).f`,
где `T` - тип, дает `значение-функцию` с обычным первым параметром, представляющим собой получатель, так что его можно
вызвать как обычную функцию:

``` go
p := Point{1, 2}
q := Point{4, 6}

distance := Point.Distance // Выражение-метод
fmt.Println(distance(p, q)) // 5
fmt.Printf("%T\n", distance) // func(Point, Point) float64

scale := (*Point).ScaleBy // Выражение-метод
scale(&p, 2)
fmt.Println(p)            // {2 4}
fmt.Printf("%T\n", scale) // func(*Point, float64)
```

`Выражения-методы` могут быть полезны, когда требуется значение для представления выбора среди нескольких методов,
принадлежащих одному типу, такое, чтобы выбранный метод можно было вызвать со многими различными получателями. В
следующем примере переменная `op` представляет метод сложения либо вычитания типа `Point` и `Path.TranslateBy` называет
его для каждой точки в пути `Path`:

``` go
type Point struct { X, Y float64}

func (p Point) Add(q Point) Point { return Point{p.X+q.X, p.Y+q.Y} }
func (p Point) Sub(q Point) Point { return Point{p.X-q.X, p.Y-q.Y} }

type Path []Point

func (path Path) TranslateBy(offset Point, add bool) {
    var op func(p, q Point) Point {
        if add {
            op = Point.Add
        } else {
            op = Point.Sub
        }
        for i := range path {
            // Вызов либо path[i].Add(offset), либо path[i].Sub(offset).
            path[i] = op(path[i], offset)
        }
    }
}
```

## Выводы

* Селектор дает значение-метод (функцию), которая связывает метод селектора со значением конкретного получателя;
* Значения-методы полезны, когда API пакета требует значение-функцию, а для клиента желаемым поведением для этой функции
  является вызов метода для конкретного получателя;
* Синтаксис с использованием значения-метода оказывается более коротким;
* Выражение-метод - это функция, связанная с типом, которая может быть вызвана как обычная функция и принимает первым
  параметром получателя. Его можно вызвать как обычную функцию;
* Выражения-методы могут быть использованы для выбора нужного метода из нескольких методов, принадлежащих к одному типу,
  и вызывать выбранный метод для разных получателей.