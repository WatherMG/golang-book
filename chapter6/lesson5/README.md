# 6.5 Пример: тип битового вектора

Множества в Go обычно реализуются как `map[T]bool`, где `T` является типом элемента. Множество, представленное картой,
очень гибкое, но для некоторых задач специализированное представление может его превзойти. Например, в таких областях,
как анализ потока данных, где элементы множества представляют собой небольшие неотрицательные целые числа, множества
имеют много элементов, а распространенными операциями являются объединение и пересечение множеств, идеальным решением
оказывается `битовый вектор`.

`Битовый вектор` использует срез беззнаковых целочисленных значений, или "слов", каждый бит которых представляет
возможный элемент множества. Множество содержит `i`, если `i-й` бит установлен. Приведенная далее программа
демонстрирует простой тип битового вектора с тремя методами (см. intset.go).

Поскольку каждое слово имеет 64 бита, чтобы найти бит для значения `x`, мы используем частное `x/64` в качестве индекса
слова, а остаток `x%64` - как индекс бита внутри этого слова. Операция `UnionWith` использует оператор
побитового `ИЛИ (|)` для вычисления объединения 64 элементов за один раз. (Мы вернемся к выбору 64-битовых слов в
упражнении 6.5)

В данной реализации не хватает многих функций, которые хотелось бы иметь. Некоторые из них оставлены в качестве
упражнений читателям, но без одной из них очень трудно обойтись: это вывод множества `IntSet` в виде строки. Давайте
добавим к этому типу метод `String`, как мы уже делали для типа `Celsius` в разделе 2.5.

Обратите внимание на схожесть метода `String` в приведенном коде с `intsToString` в разделе 3.5.4. `bytes.Buffer` часто
используется таким образом в методах `String`. Пакет `fmt` рассматривает типы с методом `String` специальным образом,
так, чтобы значения сложных типов можно было выводить в удобочитаемом виде. Вместо вывода неформатированного
представления значения (в данном случае - структуры) `fmt` вызывает метод `String`. Этот механизм опирается на
интерфейсы и утверждения о типах, с которыми мы встретимся в главе 7.

Теперь можно продемонстрировать `IntSet` в действии:

``` go
var x, y IntSet
x.Add(1)
x.Add(144)
x.Add(9)
fmt.Println(x.String()) // {1 9 144}

y.Add(9)
y.Add(42)
fmt.Println(y.String()) // {9 42}

x.UnionWith(&y)
fmt.Println(x.String()) // {1 9 42 144}

fmt.Println(x.Has(9), x.Has(123)) // true false
```

Небольшое предостережение: мы объявили `String` и `Has` как методы типа указателя `*IntSet` не по необходимости, а для
обеспечения несогласованности с двумя другими методами, которым в качестве получателя нужен указатель, поскольку в этих
методах выполняется присваивание `s.words`. Следовательно, **значение** `IntSet` не имеет метода `String`, что иногда
приводит к таким сюрпризам, как этот:

``` go
fmt.Println(&x)         // {1 9 42 144}
fmt.Println(x.String()) // {1 9 42 144}
fmt.Println(x)          // {[2398046511618 0 65536]}
```

В первом случае, мы выводим указатель `*IntSet`, у которого есть метод `String`. Во втором случае мы вызываем
метод `String()` для переменной `IntSet` - компилятор вставляет неявную операцию `&`, давая нам указатель, который имеет
метод `String`. Но в третьем случае, поскольку значение `IntSet` не имеет метода `String`, `fmt.Println` выводит
представление структуры. Важно не забывать оператор `&`. Сделать `String` методом `IntSet`, а не `*IntSet`, может быть
хорошей идеей, но это зависит от конкретных обстоятельств.

## Выводы:

* Множества в Go реализуются как `map[T]bool`, где `T` является типом элемента;
* Множество, представленное картой, очень гибкое, но для некоторых задач специализированное представление может его
  превзойти (например, в анализе потока данных, где элементы множества - небольшие неотрицательные целые числа,
  множества имеют много элементов, а распространенными операциями являются объединение и пересечение множеств. Для такой
  задачи идеальным решением оказывается `битовый вектор`);
* `Битовый вектор` использует срез беззнаковых целочисленных значений, каждый бит которых, представляет возможный
  элемент множества. Множество содержит `i`, если `i-й` бит установлен;
* Каждое слово может иметь 32, либо 64 бита (в зависимости от архитектуры устройства). Чтобы найти бит для значения `x`,
  нужно использовать частное `x/64` в качестве индекса значения, а остаток `x%64` - как индекс бита внутри этого слова;
* Операция объединения использует оператор побитового `ИЛИ (|)` для вычисления объединения 64 элементов за один раз;
* Для формирования удобочитаемой строки из структуры данных часто используют `bytes.Buffer` или `strings.Builder`, а
  метод `String` определен в интерфейсе.
* Если мы объявляем метод `String` для типа указателя `*T`, то значение `T` не будет иметь метода `String`. Чтобы
  вызвать метод `String` для значения `T`, можно использовать `fmt.Println(x.String())` или `fmt.Println(&x)`. Вывод
  значения `T` с помощью `fmt.Println(x)` не даст форматированного представления.



