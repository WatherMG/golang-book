# 6.6 Инкапсуляция

Переменная (или метод объекта) называется `инкапсулированной`, если она недоступна клиенту этого
объекта. `Инкапсуляция`, иногда именуемая `сокрытием информации`, является ключевым аспектом объектно-ориентированного
программирования.

Go имеет только один механизм для управления видимостью имен: идентификаторы, начинающиеся с прописной буквы,
экспортируются из пакета, в котором они определены, а начинающиеся со строчной буквы - нет. Такой же механизм, как и
ограничивающий доступ к членам пакета, ограничивает доступ и к полям структуры или методам типа. Как следствие, для
`инкапсуляции объекта` мы должны сделать его структурой.

По этой причине тип `IntSet` из предыдущего раздела был объявлен как структурный, несмотря на то, что в нем имеется
только одно поле (2 в упражнениях):

``` go
type IntSet struct {
    words []uint64
}
```

Мы могли бы вместо этого определить `IntSet` как тип среза, как показано ниже, хотя, конечно, должны были бы при этом
заменить в его методах каждое вхождение `s.words` на `*s`:

``` go
type IntSet []uint64
```

Хотя эта версия `IntSet`, была бы, по сути, эквивалентна имеющейся, она позволяла бы клиентам из других пакетов читать
и модифицировать срез непосредственно. Иначе говоря, в то время как выражение `*s` может быть использовано в любом
пакете, `s.words` может появиться только в пакете, в котором определен `IntSet`.

Еще одним следствием механизма экспорта, основанного на именах, является то, что единицей инкапсуляции является пакет, а
не тип, как во многих других языках программирования. Поля структурного типа являются видимыми для всего кода в том же
пакете. Находится ли этот код в функции или метода, не имеет никакого значения.

Инкапсуляция имеет три преимущества. Во-первых, поскольку клиенты не могут изменять переменные объекта непосредственно,
необходимо изучать меньше инструкций, чтобы понять, какими могут быть возможные значения этих переменных.

Во-вторых, сокрытие деталей реализации устраняет зависимость клиентов от сущностей, которые могут изменяться, что дает
проектировщику большую свободу в развитии реализации без нарушения совместимости `API`.

В качестве примера рассмотрим тип `bytes.Buffer`. Он часто используется для накопления очень коротких строк, так что
выгодной оптимизацией является резервирование некоторого дополнительного пространства в объекте, чтобы избежать
излишнего перераспределения памяти в этом распространенном случае. Поскольку `Buffer` представляет собой структурный
тип, это пространство принимает вид дополнительного поля [64]byte с именем, начинающимся со строчной буквы. После
добавления этого поля в силу его неэкспортируемости клиенты `Buffer` вне пакета `bytes` ничего не знают о каких-либо
изменениях, за исключением повышения производительности. `Buffer` и его метод `Grow` приведены ниже (немного упрощены
для
ясности):

``` go
type Buffer struct {
    buf []byte
    initial [64]byte
    /*...*/
}

// Grow увеличивает при необходимости емкость буфера, 
// чтобы гарантировать наличие места для еще n байтов. [...]
func (b *Buffer) Grow(n int) {
    if b.buf == nil {
        b.buf = b.initial[:0] // Изначально используется предварительно выделенная память.
    }
    if len(b.buf)+n > cap(b.buf) {
        buf := make([]byte, b.Len(), 2*cap(b.buf) + n)
        copy(buf, b.buf)
        b.buf = buf
    }
}   
```

Третье, и во многих случаях наиболее важное, преимущество инкапсуляции состоит в том, что она не позволяет клиентам
произвольным образом устанавливать значения переменных объекта. Поскольку переменные объекта могут устанавливаться
только функциями из одного пакета, автор этого пакета может гарантировать, что все функции поддерживают внутренние
инварианты объектов. Например, показанный ниже тип `Counter` позволяет клиентам выполнять приращение счетчика или
сбрасывать его значение до нуля, но не устанавливать его равным некоторому произвольному значению:

``` go
type Counter struct {
    n int
}

func (c *Counter) N() int { return c.n }
func (c *Counter) Increment() { c.n++ }
func (c *Counter) Reset() { c.n = 0 }
```

Функции, которые просто получают доступ ко внутренним значениям типа или изменяют их, такие, как методы типа `Logger` из
пакета `log`, показанные ниже, называются методами `получения и установки значения (getter и setter)`. Однако при
именовании метода получения значения мы обычно опускаем префикс `Get`. Это предпочтение краткости относится ко всем
методам (не только к методам доступа к полям), а также к прочим избыточным префиксам, таким как `Fetch`, `Find`
или `Lookup`:

```go 
package log

type Logger struct {
	flags  int
	prefix string
	// ...
}

func (l *Logger) Flags() int
func (l *Logger) SetFlags(flag int)
func (l *Logger) Prefix() string
func (l *Logger) SetPrefix(prefix string)
```

Стиль Go не запрещает экспортировать поля. Конечно, после экспорта поле не может стать неэкспортируемым без внесения
несовместимых изменений в API, поэтому первоначальный выбор должен быть преднамеренным. Также должны быть тщательно
рассмотрены вопросы:

* о сложности инвариантов, которые должны поддерживаться
* вероятность будущих изменений и количество клиентского кода, который будет затронут внесением изменений.

Инкапсуляция желательна не всегда. Открывая представление числа наносекунд как `int64`, `time.Duration` позволяет
использовать обычные арифметические операции и операции сравнения при работе с периодами времени и даже для определения
констант этого типа:

``` go
const day = 24 * time.Hour
fmt.Println(day.Seconds()) // 86400
```

В качестве другого примера сравним `IntSet` с типом `geometry.Path` из самого начала этой главы. `Path` был определен
как тип среза и позволяет своим клиентам создавать экземпляры с использованием синтаксиса литералов срезов, выполнять
итерации по его точкам с помощью цикла по диапазону и так далее, тогда как для клиентов `IntSet` эти операции
недоступны.

Вот принципиальное отличие: `geometry.Path`, по сути, является последовательностью точек, не больше и не меньше, и
добавление в него новых полей не предвидится, так что для пакета `geometry` имеет смысл показать, что `Path` является
срезом. В противоположность этому `IntSet` просто случайно представлен в виде среза `[]uint64`. Он мог бы иметь
представление с использованием `[]uint` или чего-то совершенно иного для разреженных или очень малых множеств. Или, быть
может, определенное преимущество дадут дополнительные возможности, такие как еще одно поле для записи количества
элементов множества. По этим причинам имеет смысл сделать `IntSet` непрозрачным.

Из этой главы вы узнали, как связать методы с именованными типами и как вызывать эти методы. Хотя методы имеют решающее
значение для объектно-ориентированного программирования, они представляют только половину картины. Чтобы завершить ее,
нужны `интерфейсы`. О них речь пойдет в следующей главе.

## Выводы:

* Переменная или метод объекта называется инкапсулированным, если она недоступна для обращения вне этого объекта. Это
  называется инкапсуляцией или сокрытием информации, и она является важной частью объектно-ориентированного
  программирования (ООП).
* В языке программирования Go есть только один механизм для управления видимостью имен: идентификаторы с Прописной
  буквы - экспортируемые, со строчной - нет. Этот механизм ограничивает доступ к переменным и к полям структуры или
  методам.
* Для инкапсуляции объекта мы должны сделать его структурой. `type T struct`, выражение `s.field` может появиться только
  в пакете, в котором определен `T`;
* Если мы определяем тип как срез или другой что-то другое `type T []int`, выражение `*s` может быть использовано в
  любом пакете;
* Единицей инкапсуляции является пакет, а не тип, как во многих других ЯП;
* Поля структурного типа являются видимыми для всего кода в том же пакете;
* Инкапсуляция имеет три преимущества:
    * Так, как переменные объекта `не могут быть изменены непосредственно` (вне этого объекта), нужно изучать меньше
      инструкций для понимания возможных значений этих переменных;
    * `Сокрытие деталей реализации` устраняет зависимость клиентов от сущностей, которые могут изменяться, что дает
      проектировщику большую свободу в развитии реализации без нарушения совместимости `API`;
    * `Инкапсуляция` не позволяет клиентам произвольным образом устанавливать значения переменных объекта. Доступ только
      через `геттеры` и `сеттеры`. Они могут устанавливаться только функциями из одного пакета, автор пакета, может
      гарантировать, что все функции поддерживают внутренние инварианты объектов;
    * `Кратко`: Инкапсуляция имеет три преимущества: она уменьшает сложность кода, устраняет зависимость клиентов от
      деталей
      реализации, и предотвращает произвольное изменение значений переменных объекта.
* При именовании метода получения значения обычно префикс `Get` опускается, а при именовании метода установки значения -
  используется префикс `Set`.
* В целом, все излишние префиксы должны опускаться в наименовании методов;
* В целом, в Go можно экспортировать поля, но это нужно делать осознанно, учитывая сложность поддержки инвариантов,
  вероятность будущих изменений и количество клиентского кода, который будет подвержен внесению изменений.
    * Сложность поддержки инвариантов в Go связана с тем, что экспортирование полей может нарушить внутреннее состояние
      структуры и привести к некорректной работе программы. Инварианты - это условия, которые всегда должны выполняться
      внутри структуры или объекта, чтобы он работал корректно;
    * Когда экспортируются поля, клиентский код может изменять их значения напрямую, что может привести к нарушению
      инвариантов. При этом, если изменения внесены в экспортированные поля, но не были учтены при обновлении
      инвариантов, то это может привести к ошибкам в работе программы;
    * `Инварианты` - ограничения на значения переменных, которые должны сохраняться в любой момент выполнения программы.
* Инкапсуляция может быть нежелательной в случаях, когда требуется широкий доступ к переменным объекта, или когда общий
  доступ к ним более эффективен, чем использование геттеров и сеттеров. Также может быть нежелательно использование
  инкапсуляции при создании простых типов данных или для объектов, которые не изменяются.













