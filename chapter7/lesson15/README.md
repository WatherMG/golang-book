# 7.15 Несколько советов

Проектирование нового пакета начинающие программисты Go часто начинают с создания множества интерфейсов и только после
этого определяют конкретные типы, которые им соответствуют. Этот подход дает несколько интерфейсов, каждый из которых
имеет только одну реализацию. Не делайте этого. Такие интерфейсы являются ненужными абстракциями, которые к тому же
имеют свою ненулевую стоимость во время выполнения. Ограничить методы типа или поля структуры, видимые извне пакета,
можно с помощью механизма экспорта (раздел 6.6). Интерфейсы нужны только в том случае, если есть несколько конкретных
типов, работа с которыми должна выполниться единообразно.

Исключением из этого правила является ситуация, когда интерфейсу соответствует единственный конкретный тип, но этот тип
не может находиться в том же пакете, что и интерфейс, из-за своих зависимостей. В таком случае интерфейс является
хорошим средством развязывания двух пакетов.

Поскольку интерфейсы используются в Go только тогда, когда им соответствуют два и более типа, они обязательно
абстрагируются от деталей любой конкретной реализации. В результате получаются интерфейсы меньшего размера с небольшими,
простыми методами, причем зачастую только с одним методом, как в случае с `io.Writer` или `fmt.Stringer`. Новым типам
проще соответствовать небольшим интерфейсам. При проектировании интерфейса стоит следовать правилу `запрашивайте только
самое необходимое`.

На этом этапе наше знакомство с методами и интерфейсами завершено. Go поддерживает объектно-ориентированный стиль
программирования, но это не означает, что вам нужно использовать исключительно его. Не все должно быть объектом. Свою
нишу занимают автономные функции, так же как и не инкапсулированные типы данных. Обратите внимание, что все примеры в
первых пяти главах этой книги вместе вызывают не более двух десятков методов, таких как `input.Scan`, в отличие от
функций наподобие `fmt.Printf`

## Выводы:

* При проектировании нового пакета в Go нужно избегать создания нескольких интерфейсов до определения соответствующих им
  типов. Это поможет избежать ненужных абстракций с затратами на выполнение. Иначе, этот подход даст несколько
  интерфейсов, каждый из которых имеет только одну реализацию. Не делайте этого;
* Такие интерфейсы являются ненужными абстракциями, которые к тому же имеют свою ненулевую стоимость во время
  выполнения. Ограничить методы типа или поля структуры, видимые извне пакета, можно с помощью механизма экспорта;
* Интерфейсы нужны только в том случае, если есть несколько конкретных типов, работа с которыми должна выполниться
  единообразно.
* Исключением из этого правила является ситуация, когда интерфейс соответствует единственному конкретному типу, но этот
  тип не может находиться в том же пакете из-за зависимостей. В этом случае интерфейс может помочь развязать два пакета;
* Поскольку интерфейсы в Go абстрагируются от деталей реализации, они обычно маленькие с простыми методами, часто с
  одним методом, как `io.Writer` или `fmt.Stringer`;
* Новым типам проще соответствовать небольшим интерфейсам. При проектировании интерфейса стоит следовать
  правилу `запрашивать только самое необходимое`;
* Go поддерживает объектно-ориентированное программирование, но не обязательно использовать его исключительно. Не все
  должно быть объектом. Автономные функции и неинкапсулированные типы данных имеют свое место.