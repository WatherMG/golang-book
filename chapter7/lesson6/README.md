# 7.6 Сортировка с помощью sort.Interface

Как и форматирование строк, сортировка очень часто используется во множестве программ. Хотя минимальная быстрая
сортировка может поместиться в 15 строк, надежная реализация существенно больше, и это не тот код, который хотелось бы
писать заново или копировать всякий раз, когда он нам нужен.

К счастью, пакет `sort` предоставляет сортировку "на лету" (на месте - т.е. без привлечения дополнительной памяти) любой
последовательности в соответствии с любо функцией упорядочивания. Ее дизайн несколько необычен. Во многих языках
алгоритм сортировки связан с типом данных последовательности, в то время как функция упорядочения связана с типом
элементов. Напротив, в Go функция `sort.Sort` ничего не предполагает о представлении последовательности или ее
элементах. Вместо этого она использует интерфейс, `sort.Interface`, чтобы задать контракт между обобщенным алгоритмом
сортировки и всеми типами последовательностей, которые могут быть отсортированы. Реализация этого интерфейса определяет
как конкретное представление последовательности, которая часто является срезом, так и желаемый порядок его элементов.

Алгоритм сортировки "на месте" требует трех вещей - длины последовательности, средства сравнения двух элементов и
способа обмена двух элементов местами. Все они являются методами `sort.Interface`:

``` go
package sort

type Interface interface {
	Len() int
	Less(i, j int) bool // i, j - индексы элементов в последовательности
	Swap(i, j int)
}
```

Для сортировки любой последовательности нужно определить тип, который реализует три указанных метода, а затем применить
`sort.Sort` к экземпляру этого типа. Как один из простейших примеров рассмотрим сортировку среза строк. Новый тип
`StringSlice` и его методы `Len`, `Less` и `Swap` показаны ниже:

``` go
type StringSlice []string

func (p StringSlice) Len() int { return len(p) }
func (p StringSlice) Less(i, j int) bool { return p[i] < p[j] }
func (p StringSlice) Swap(i, j int) { p[i], p[j] = p[j], p[i] }
```

Теперь мы можем сортировать срез строк, `names`, следующим образом, преобразуя срез в `StringSlice`:

``` go
sort.Sort(StringSlice(names))
```

Преобразование типа дает значение среза с теми же длиной, емкостью и базовым массивом, что и у `names`, но типом,
который имеет три метода, необходимые для сортировки.

Сортировка среза строк настолько распространена, что пакет `sort` предоставляет тип `StringSlice` и функцию `Strings`,
так что показанный выше вызов можно упростить до `sort.Sort(names)`.

Показанная здесь методика легко адаптируется для других сортировок, например, игнорирующих регистр букв или специальные
символы. Для более сложной сортировки мы используем ту же идею, но с более сложными структурами данных или более
сложными реализациями методов `sort.Interface`.

Рассмотрим еще один пример - программу для сортировки списка воспроизведения музыки, выводимого в виде таблицы. Каждая
дорожка представлена отдельной строкой, а каждый столбец представляет один из атрибутов этой дорожки - исполнителя,
названия и другую информацию. Представим себе, что таблица выводиться с помощью графического пользовательского
интерфейса, в котором щелчок на заголовке столбца приводит к сортировке списка по указанному атрибуту. Повторный щелчок
выполняет сортировку в обратном порядке. Давайте посмотрим, какой может быть реакция на каждый щелчок.

Переменная `tracks` содержит список воспроизведения. Каждый элемент является косвенным - указателем на `Track`. Хотя
приведенный ниже код будет работать и в том случае, если мы будем хранить элементы `Track` непосредственно, но так как
функция сортировки меняет местами много пар элементов, она будет работать быстрее, если каждый элемент является
указателем (одно машинное слово), а не `Track` полностью (восемь или более слов). (см. sorting.go):

``` go
type Track struct {
	Title  string
	Artist string
	Album  string
	Year   int
	Length time.Duration
}

var tracks = []*Track{
	{"Go", "Delilah", "From the Roots Up", 2012, length("3m38s")},
	{"Go", "Moby", "Moby", 1992, length("3m37s")},
	{"Go Ahead", "Alicia Keys", "As I Am", 2007, length("4m36s")},
	{"Ready 2 Go", "Martin Solveig", "Smash", 2011, length("4m24s")},
}

func length(s string) time.Duration {
	d, err := time.ParseDuration(s)
	if err != nil {
		panic(s)
	}
	return d
}
```

Функция `printTracks` выводит список воспроизведения в виде таблицы. Графический вывод выглядел бы красивее, но в нашей
небольшой программе мы воспользовались пакетом `text/tabwriter` для генерации таблицы с красиво выровненными столбцами,
как показано ниже. Заметим, что `*tabwriter.Writer` соответствует интерфейсу `io.Writer`. Он накапливает все записанные
в него данные. Метод `Flush` этого типа форматирует всю таблицу и выводит ее на `os.Stdout`:

``` go
func printTracks(tracks []*Track) {
	const format = "%v\t%v\t%v\t%v\t%v\t\n"
	tw := new(tabwriter.Writer).Init(os.Stdout, 0, 8, 2, ' ', 0)
	fmt.Fprintf(tw, format, "Title", "Artist", "Album", "Year", "Length")
	fmt.Fprintf(tw, format, "-----", "------", "-----", "----", "------")

	for _, t := range tracks {
		fmt.Fprintf(tw, format, t.Title, t.Artist, t.Album, t.Year, t.Length)
	}
	tw.Flush()
}
```

Для сортировки списка воспроизведения по полю `Artist` мы определяем новый тип среза с необходимыми
методами `Len`, `Less` и `Swap`, аналогично тому, как мы делали это для `StringSlice`:

``` go
type byArtist []*Track

func (x byArtist) Len() int           { return len(x) }
func (x byArtist) Less(i, j int) bool { return x[i].Artist < x[j].Artist }
func (x byArtist) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }
```

Для вызова обобщенной подпрограммы сортировки преобразуем `tracks` в новый тип, `byArtist`, который определяет порядок
сортировки:

``` go
sort.Sort(byArtist(tracks))
```

После сортировки среза по исполнителям вывод `printTracks` имеет следующий вид:

```
Title       Artist          Album              Year  Length
-----       ------          -----              ----  ------
Go Ahead    Alicia Keys     As I Am            2007  4m36s
Go          Delilah         From the Roots Up  2012  3m38s
Ready 2 Go  Martin Solveig  Smash              2011  4m24s
Go          Moby            Moby               1992  3m37s
```

Если пользователь запросит сортировку по исполнителям повторно, будет выполнена сортировка в обратном порядке. Однако
нам не нужно определять новый тип `byReverseArtist` с методом `Less`, имеющим обратный смысл, поскольку пакет `sort`
предоставляет функцию `Reverse`, которая просто преобразует любой порядок сортировки в обратный:

``` go
sort.Sort(sort.Reverse(byArtist(tracks)))
```

После сортировки среза по исполнителям в обратном порядке вывод `printTracks` приобретает следующий вид:

```
Title       Artist          Album              Year  Length
-----       ------          -----              ----  ------
Go          Moby            Moby               1992  3m37s
Ready 2 Go  Martin Solveig  Smash              2011  4m24s
Go          Delilah         From the Roots Up  2012  3m38s
Go Ahead    Alicia Keys     As I Am            2007  4m36s
```

Функция `sort.Reverse` заслуживает более близкого знакомства, так как она использует `композицию` (раздел 6.3), которая
является важной идеей. Пакет `sort` определяет неэкспортируемый тип `reverse`, являющийся структурой, в которую встроен
`sort.Interface`. Метод `Less` для `reverse` вызывает метод `Less` встроенного значения `sort.Interface`, но с индексами
в обратном порядке, что приводит к обращению результата сортировки:

``` go
package sort

import . "sort"

type reverse struct{ Interface }       // т.е. sort.Interface
func (r reverse) Less(i, j int) bool   { return r.Interface.Less(j, i) }
func Reverse(data Interface) Interface { return reverse(data) }
```

Два других метода `reverse`, `Len` и `Swap`, неявно предоставляются исходным значением `sort.Interface`, которое
является встроенным полем. Экспортируемая функция `Reverse` возвращает экземпляр типа `reverse`, который содержит
исходное значение `sort.Interface`.

Для сортировки по другому столбцу нужно определить новый тип, такой как `byYear`:

``` go
type byYear []*Track

func (x byYear) Len() int           { return len(x) }
func (x byYear) Less(i, j int) bool { return x[i].Year < x[j].Year }
func (x byYear) Swap(i, j int)      { x[i], x[j] = x[j], x[i] }
```

После сортировки `tracks` по году с использованием `sort.Sort(byYear(tracks))`, `printTracks` выводит список в
хронологическом порядке:

```
Title       Artist          Album              Year  Length
-----       ------          -----              ----  ------
Go          Moby            Moby               1992  3m37s
Go Ahead    Alicia Keys     As I Am            2007  4m36s
Ready 2 Go  Martin Solveig  Smash              2011  4m24s
Go          Delilah         From the Roots Up  2012  3m38s
```

Для каждого необходимого нам типа элементов среза и каждой функции упорядочения мы объявляем новую
реализацию `sort.Interface`. Как можно увидеть, методы `Len` и `Swap` имеют одинаковые определения для всех типов
срезов. В следующем примере конкретный тип `customSort` сочетает срез с функцией, позволяя нам определить новый порядок
сортировки с помощью написания одной только функции сравнения. Кстати, конкретные типы, реализующие `sort.Interface`, не
всегда являются срезами. `customSort` - это структурный тип:

``` go
type customSort struct {
	t    []*Track
	less func(x, y *Track) bool
}

func (x customSort) Len() int           { return len(x.t) }
func (x customSort) Less(i, j int) bool { return x.less(x.t[i], x.t[j]) }
func (x customSort) Swap(i, j int)      { x.t[i], x.t[j] = x.t[j], x.t[i] }
```

Давайте определим функцию многоуровневого упорядочивания, первичным ключом сортировки которой является `Title`,
вторичным ключом `Year`, а третичным - продолжительность исполнения `Length`. Вот как выглядит `Sort` с использованием
анонимной функции упорядочения:

``` go
sort.Sort(customSort{tracks, func(x, y *Track) bool {
		if x.Title != y.Title {
			return x.Title < y.Title
		}
		if x.Year != y.Year {
			return x.Year < y.Year
		}
		if x.Length != y.Length {
			return x.Length < y.Length
		}
		return false
	}})
```

А вот какой вид имеет результат сортировки. Обратите внимание, что две дорожки с одинаковым названием `Go` упорядочены
по году выхода:

```
Title       Artist          Album              Year  Length
-----       ------          -----              ----  ------
Go          Moby            Moby               1992  3m37s
Go          Delilah         From the Roots Up  2012  3m38s
Go Ahead    Alicia Keys     As I Am            2007  4m36s
Ready 2 Go  Martin Solveig  Smash              2011  4m24s
```

Хотя сортировка последовательности длиной `n` требует `O(n log n)` операций сравнения, проверка, отсортирована ли данная
последовательность, требует не более `n-1` сравнения. Функция `IsSorted` из пакета `sort` выполняет указанную проверку.
Подобно `sort.Sort`, она абстрагирует как последовательность, так и ее функцию упорядочения с помощью `sort.Interface`,
но никогда не вызывает метод `Swap`. Приведенный ниже код демонстрирует функции `IntsAreSorted` и `Ints` и
тип `IntSlice`:

``` go
values := []int{3, 1, 4, 1}
fmt.Println(sort.IntsAreSorted(values)) // false
sort.Ints(values)
fmt.Println(values)                     // [1 1 3 4]
fmt.Println(sort.IntsAreSorted(values)) // true
sort.Sort(sort.Reverse(sort.IntSlice(values)))
fmt.Println(values)                     // [4 3 1 1]
fmt.Println(sort.IntsAreSorted(values)) // false
```

Для удобства пакет `sort` предоставляет версии своих функций и типов, специализированные для `[]int`, `[]string`
и `[]float64` с использованием их естественного порядка. Для других типов, таких как `[]int64` или `[]uint`, надо писать
собственный, пусть и достаточно короткий, код.

## Выводы:

* Пакет `sort` предоставляет сортировку "на лету", т.е. без привлечения дополнительной памяти любой последовательности в
  соответствии с любой функцией упорядочивания;
* Функция `sort.Sort` ничего не предполагает о представлении последовательности или ее элементах. Вместо этого она
  использует интерфейс, `sort.Interface`, чтобы задать контракт между обобщенным алгоритмом сортировки и всеми типами
  последовательностей, которые могут быть отсортированы. Реализация этого интерфейса определяет как конкретное
  представление последовательности, которая часто является срезом, так и желаемый порядок его элементов.
* Алгоритм сортировки "на лету" требует трех вещей, которые являются методами `sort.Interface`:
	* Длины последовательности;
	* Средства сравнения двух элементов;
	* Способа обмена двух элементов местами.
* Для сортировки любой последовательности нужно определить тип, который реализует три указанных метода, а затем
  применить `sort.Sort` к экземпляру этого типа `sort.Sort(StringSlice(names))`, где `StringSlice` - тип, а `names` -
  срез строк;
* Преобразование типа дает значение среза с теми же длиной, емкостью и базовым массивом, что и у исходного среза, но
  типом, который имеет три метода, необходимые для сортировки;
* Пакет `sort` предоставляет тип `StringSlice` и функцию `Strings` для сортировки среза строк, так что вызов выше можно
  сократить до `sort.Sort(names)`;
* Пакет `text/tabwriter` генерирует таблицы. `*tabwriter.Writer` соответствует интерфейсу `io.Writer`. Он накапливает
  все данные. Метод `Flush` этого типа форматирует всю таблицу и выводит результат;
* Чтобы выполнить сортировку в обратном порядке, не нужно определять новый тип с методом `Less`. Пакет `sort`
  предоставляет функцию `Reverse`, которая преобразует любой порядок сортировки в обратный;
* Функция `Reverse` использует `композицию`. Пакет `sort` определяет неэкспортируемый тип `reverse`, являющийся
  структурой, в которую встроен `sort.Interface`. Метод `Less` для `reverse` вызывает метод `Less` встроенного значения
  `sort.Interface`, но с индексами в обратном порядке, что приводит к обращению результата сортировки;
* Два других метода `reverse`, `Len` и `Swap`, неявно предоставляются исходным значением `sort.Interface`, которое
  является встроенным полем;
* Экспортируемая функция `Reverse` возвращает экземпляр типа `reverse`, который содержит исходное
  значение `sort.Interface`;
* Чтобы определить новый порядок сортировки (по разным полям сразу), нужно определить конкретный тип и функцию
  многоуровневого упорядочивания, где есть первичный, вторичный, третичный ключи. Это требует использования анонимной
  функции;
* Конкретные типы, реализующие интерфейс `sort.Interface` не всегда являются срезами (можно использовать структурный
  тип).
* Чтобы отсортировать последовательность, нужно выполнить `O(n log n)` операций сравнения. Чтобы проверить,
  отсортирована ли последовательность, нужно выполнить не более `n-1` сравнения. Функция `IsSorted` из пакета `sort`
  проверяет, отсортирована ли последовательность. Она использует функцию упорядочения и `sort.Interface`, но не вызывает
  метод `Swap`;
* Для удобства, пакет `sort` предоставляет версии своих функций и типов, специализированные
  для `[]int`, `[]string`, `[]float64` с использованием их естественного порядка. Для других типов, таких
  как `[]int64`, `[]uint`, нужно писать собственную реализацию.