# 7.1 Интерфейсы как контракты

Все типы, которые мы рассматривали до сих пор, были `конкретными типами`. `Конкретный тип` определяет точное
представление своих значений и предоставляет встроенные операции этого представления, например арифметические операции
для чисел, или индексацию, добавление значений и цикл по диапазону для срезов. Конкретный тип может также предоставлять
дополнительное поведение с помощью своих методов. Если у нас есть значение конкретного типа, мы точно знаем, что оно
из себя **представляет**, и, что мы можем с ним **сделать**.

В Go имеется еще одна разновидность типов - `тип интерфейса`. Интерфейс является `абстрактным типом`. Он не раскрывает
представление или внутреннюю структуру своих значений, или набор основных поддерживаемых ими операций. Он показывает
только некоторые из их методов. Если у нас есть значение интерфейсного типа, мы ничего не знаем о том, чем оно
`является`. Мы знаем только то, что оно может `делать` или точнее `какое поведение предоставляется его методами`.

Во всей этой книге мы использовали две схожие функции для форматирования строк: `fmt.Printf`, которая записывает
результаты в стандартный поток вывода (файл), и `fmt.Sprintf`, которая возвращает результат в виде строки `string`. Было
бы грустно, если бы самую сложную часть, форматирование результата, пришлось бы дублировать из-за поверхностных различий
в использовании результатов. Благодаря интерфейсам все оказывается не так грустно. Обе функции являются, по
сути, `обертками` для третьей функции, `fmt.Fprintf`, которая ничего не знает о том, что будет с результатом, который
она вычисляет:

```go
package fmt

import (
	"bytes"
	"io"
	"os"
)

func Fprintf(w io.Writer, format string, args ...interface{}) (int, error)

func Printf(format string, args ...interface{}) (int, error) {
	return Fprintf(os.Stdout, format, args...)
}

func Sprintf(format string, args ...interface{}) string {
	var buf bytes.Buffer
	Fprintf(&buf, format, args...)
	return buf.String()
}

```

Префикс `F` в `Fprintf` обозначает `файл` и указывает, что отформатированный вывод должен записываться в файл,
предоставляемый в качестве первого аргумента. В случае `Printf` аргумент, `os.Stdout`, имеет тип `*os.File`. Однако в
случае `Sprintf` аргумент не является файлом, хотя внешне напоминает его: `&buf` - это указатель на буфер в памяти, в
который можно записать байты.

Первый параметр `Fprintf` вообще не является файлом. Его тип - `io.Writer`, который является типом интерфейса со
следующим объявлением:

```go
package io

// Writer является интерфейсом, являющимся оболочкой метода `Write`.
type Writer interface {
	// Write записывает len(p) байтов из p в базовый поток данных.
	// Метод возвращает количество байтов, записанных из p
	// (0 <= n <= len(p)), а любая ошибка вызывает прекращение записи.
	// Write должен вернуть ненулевую ошибку при n < len(p)`.
	// Write не должен изменять данные среза, даже временно.
	//
	// Реализации не должны сохранять p.
	Write(p []byte) (n int, err error)
}
```

Интерфейс `io.Writer` определяет контракт между `Fprintf` и вызывающими его функциями. С одной стороны, контракт
требует, чтобы вызывающая функция предоставляла значение конкретного типа наподобие `*os.File` или `*bytes.Buffer`,
который содержит метод с именем `Write` с соответствующими сигнатурой и поведением. С другой стороны, контракт
гарантирует, что `Fprintf` будет выполнять свою работу для любого значения, соответствующего интерфейсу `io.Writer`.
Функция `Fprintf` не может считать, что выполняет запись в файл или в память, — она может только вызывать `Write`.

Поскольку `fmt.Fprintf` ничего не предполагает о представлении значения и полагается только на поведение,
гарантированное контрактом `io.Writer`, мы можем безопасно передать значение любого конкретного типа, который
соответствует интерфейсу `io.Writer`, в качестве первого аргумента `fmt.Fprintf`. Эта свобода замены одного типа другим,
которые соответствует тому же интерфейсу, называется `взаимозаменяемостью (substitutability)` и является отличительной
способностью ООП.

Давайте проверим это с помощью нового типа. Метод `Write` в коде (см. bytecounter.go) типа `*ByteCounter` просто
подсчитывает количество записанных в него байт, после чего игнорирует их. (для соответствия типа `len(p)` типу `*с` в
операторе `+=` необходимо выполнить преобразование типа.)

Поскольку `*ByteCounter` соответствует контракту `io.Writer`, мы можем передать его в `Fprintf`, который выполняет
форматирование строки, даже не замечая этого изменения. `ByteCounter` накапливает длину выводимого результата.

Помимо `io.Writer`, имеется еще один очень важный для пакета `fmt` интерфейс. Функции `Fprintf` и `Fprintln`
предоставляют типам возможность управлять видом их значений при выводе. В разделе 2.5 мы определили метод `String` для
типа `Celsius` таким образом, чтобы температура выводилась как `100°С`, а в разделе 6.5 мы оснастили методом `String`
тип `*IntSet` для визуализации последнего с использованием традиционного обозначения множества как `{1 2 3}`. Объявление
метода `String` делает тип соответствующим одному из наиболее широко используемых интерфейсов, `fmt.Stringer`:

``` go
package fmt
// Метод `String` используется для вывода значений, передаваемых в качестве операндов
// любому формату, принимающему строку, или неформатированному принтеру, такому как `Print`.
type Stringer interface {
	String() string
}
```

Как пакет `fmt` выясняет, какие значения соответствуют интерфейсу, будет рассмотрено в разделе 7.10

## Выводы:

* Конкретные типы имеют точное представление значений и встроенные операции. Интерфейсы же являются абстрактными типами,
  которые не раскрывают представление значений и операций, но определяют некоторые методы. Методы можно использовать с
  любым типом, соответствующим интерфейсу. Обертки для функций на основе интерфейсов позволяют избежать дублирования
  кода;
* Интерфейс `io.Writer` определяет контракт между вызывающим кодом и функцией, которая его реализует. Функция должна
  иметь
  метод `Write`, соответствующий сигнатуре и поведению интерфейса `io.Writer`. Это позволяет вызывающему коду передавать
  разные типы данных, которые соответствуют интерфейсу `io.Writer`, и гарантирует, что функция выполнит свою работу для
  любого значения, соответствующего этому интерфейсу;
* Одной из ключевых особенностей ООП является взаимозаменяемость - возможность передачи разных типов, которые
  соответствуют одному интерфейсу. Это позволяет создавать универсальные функции и методы, которые могут работать с
  различными типами данных;
* Объявление метода `String` позволяет типу соответствовать интерфейсу `fmt.Stringer` и определить формат вывода для
  своих значений. Это полезно при выводе сложных структур данных в удобочитаемом формате.