# 7. Интерфейсы

Интерфейсные типы выражают обобщения или абстракции поведения других типов. С помощью абстракции интерфейсы позволяют
писать более гибкие и адаптируемые функции, не привязанные к деталям одной конкретной реализации.

Некоторое понятие интерфейсов имеется у многих ООП языков, но отличительной особенностью интерфейсов Go является то, что
они `удовлетворяются неявно`. Другими словами, нет необходимости объявлять все интерфейсы, которым соответствует данный
конкретный тип, достаточно просто наличия необходимых методов. Такой дизайн позволяет создавать новые интерфейсы,
которым соответствуют существующие конкретные типы, без изменения существующих типов, что особенно удобно для типов,
определенных в пакетах, которые вы не контролируете.
Эту главу мы начнем с рассмотрения основ механики интерфейсных типов и их значений. Попутно мы изучим несколько важных
интерфейсов из стандартной библиотеки. Многие программы Go используют стандартные интерфейсы ничуть не меньше, чем
собственные. Наконец мы рассмотрим `декларации типов` и `переключатели типов` и увидим, как они обеспечивают
обобщенность иного рода.

# Выводы к главе:
<!-- TOC -->
* [7.1. Интерфейсы как контракты](#71-интерфейсы-как-контракты)
* [7.2. Типы интерфейсов](#72-типы-интерфейсов)
* [7.3. Соответствие интерфейсу](#73-соответствие-интерфейсу)
* [7.4. Анализ флагов с помощью flag.Value](#74-анализ-флагов-с-помощью-flagvalue)
* [7.5. Значения интерфейсов](#75-значения-интерфейсов)
  * [7.5.1 Осторожно: интерфейс, содержащий нулевой указатель не является нулевым](#751-осторожно-интерфейс-содержащий-нулевой-указатель-не-является-нулевым)
* [7.6. Сортировка с помощью sort.Interface](#76-сортировка-с-помощью-sortinterface)
* [7.7. Интерфейс http.Handler](#77-интерфейс-httphandler)
* [7.8. Интерфейс error](#78-интерфейс-error)
* [7.9. Пример: вычислитель выражения](#79-пример-вычислитель-выражения)
* [7.10. Декларации типов](#710-декларации-типов)
* [7.11. Распознавание ошибок с помощью деклараций типов](#711-распознавание-ошибок-с-помощью-деклараций-типов)
* [7.12. Запрос поведения с помощью деклараций типов](#712-запрос-поведения-с-помощью-деклараций-типов)
* [7.13. Выбор типа](#713-выбор-типа)
* [7.14. Пример: XML-декодирование на основе лексем](#714-пример-xml-декодирование-на-основе-лексем)
* [7.15. Несколько советов](#715-несколько-советов)
<!-- TOC -->
____

## 7.1. Интерфейсы как контракты

* Конкретные типы имеют точное представление значений и встроенные операции. Интерфейсы же являются абстрактными типами,
  которые не раскрывают представление значений и операций, но определяют некоторые методы. Методы можно использовать с
  любым типом, соответствующим интерфейсу. Обертки для функций на основе интерфейсов позволяют избежать дублирования
  кода;
* Интерфейс `io.Writer` определяет контракт между вызывающим кодом и функцией, которая его реализует. Функция должна
  иметь
  метод `Write`, соответствующий сигнатуре и поведению интерфейса `io.Writer`. Это позволяет вызывающему коду передавать
  разные типы данных, которые соответствуют интерфейсу `io.Writer`, и гарантирует, что функция выполнит свою работу для
  любого значения, соответствующего этому интерфейсу;
* Одной из ключевых особенностей ООП является взаимозаменяемость - возможность передачи разных типов, которые
  соответствуют одному интерфейсу. Это позволяет создавать универсальные функции и методы, которые могут работать с
  различными типами данных;
* Объявление метода `String` позволяет типу соответствовать интерфейсу `fmt.Stringer` и определить формат вывода для
  своих значений. Это полезно при выводе сложных структур данных в удобочитаемом формате.

____

## 7.2. Типы интерфейсов

* Интерфейс определяет множество методов, необходимых для рассматривания типа в качестве экземпляра этого интерфейса;
* `io.Writer` - один из самых популярных интерфейсов в Go, представляет собой абстракцию всех типов, в которые можно
  записывать байты;
* Пакет `io` включает в себя много других полезных интерфейсов, таких как `Reader`, `Closer`;
* Использования встраивания интерфейсов (`внедрения интерфейсов`) позволяет создавать новые интерфейсы, объединяя уже
  существующие интерфейсы и их методы;
* Примерами таких объединенных интерфейсов являются `ReadWriter` и `ReadWriteCloser`;
* Порядок в котором объявлены методы\интерфейсы в интерфейсе, не имеет значения, главное их множество.

____

## 7.3. Соответствие интерфейсу

* Чтобы тип `удовлетворял` интерфейсу, он должен иметь все методы, которые требует интерфейс;
* Чтобы выражение могло быть присвоено интерфейсу, его тип должен соответствовать этому интерфейсу. Это относится к
  обеим сторонам `a = b`, если они являются интерфейсами;
* Для каждого типа `T` некоторые методы могут быть вызваны с помощью значения типа `T`, а другие требуют указателя на
  тип `*T`. Можно вызывать методы типа `*T` с помощью переменной типа `T`, но это не значит, что значение типа `T`
  обладает всеми методами, которые есть у указателя на `*T`. Поэтому, при использовании значения типа `T`, может быть
  доступно меньшее количество методов, чем при использовании указателя на `*T`;
* Интерфейс скрывает конкретный тип и значения, которые он содержит. Можно использовать только методы, объявленные в
  интерфейсе, даже если конкретный тип имеет другие методы;
* Тип `interface{}` является `пустым интерфейсом` и не накладывает требований на типы, которые ему соответствуют (может
  быть присвоен любой тип);
* Создав значение `interface{}`, с любым значением, мы ничего не можем сделать с ним непосредственно, т.к. интерфейс не
  имеет методов;
* Обычно нет необходимости объявлять отношения между конкретным типом и интерфейсом, которому он соответствует. Однако
  иногда полезно документировать и проверять эти отношения;
* Объявление `var w io.Writer = new(bytes.Buffer)` проверяет, что значение типа `*bytes.Buffer` соответствует интерфейсу
  `io.Writer` во время компиляции. Нет необходимости создавать новую переменную, поскольку любое значение
  типа `*bytes.Buffer` будет подходить, даже `nil`, который можно записать как `(*bytes.Buffer)(nil)`;
* Непустым типам интерфейсов, таким как `io.Writer`, чаще всегда соответствуют типы указателей, особенно когда один или
  несколько методов интерфейса подразумевают некоторые изменения получателя, как метод `Write`. Особенно часто
  используется указатель на структуру;
* Помимо указателей, можно использовать и другие ссылочные типы для удовлетворения интерфейсов, даже с методами,
  изменяющими получателя;
* Фундаментальные типы могут соответствовать интерфейсам;
* Тип `time.Duration` соответствует интерфейсу `fmt.Stringer`;
* Один конкретный тип может соответствовать нескольким интерфейсам;
* Используя интерфейсы, мы можем группировать конкретные типы по их общим аспектам и выражать их общие свойства;
* Каждая группировка конкретных типов может быть выражена в виде интерфейса, и мы можем определять новые интерфейсы,
  когда в них нуждаемся, не изменяя при этом объявления конкретных типов. Это особенно удобно, когда мы используем
  конкретный тип из пакета другого автора. Однако все конкретные типы, которые мы хотим группировать с помощью
  интерфейса, должны удовлетворять базовым общим требованиям.

____

## 7.4. Анализ флагов с помощью flag.Value

* Стандартный интерфейс `flag.Value` помогает определить новую запись для флагов командной строки;
* Функция `flag.Duration` создает переменную типа `time.Duration` и разрешает пользователю указывать продолжительность
  в различных удобных для человека форматах, включая вывод метода `String`;
* Для создания собственного флага нужно определить тип данных, соответствующий интерфейсу flag.Value;
* Метод `String` из интерфейса `flag.Value` форматирует значение флага для использования в сообщениях справки командной
  строки. Таким образом, каждый `flag.Value` так же является `fmt.Stringer`;
* Метод `Set` из интерфейса `flag.Value` анализирует свой строковый аргумент и обновляет значения флага. По сути, метод
  `Set` является обратным методом для метода `String`, и использовать для них одни и те же обозначения - хорошая
  практика;
* Функция `fmt.Sscanf` получает данные из строки с указанными форматами;
* Для использования флага, нужно создать функцию, которая будет возвращать указатель на поле, встроенное в структуру.
  Это поле является переменной, которая будет обновляться методом `Set` при обработке флага;
* Вызов `Var` в `flag.CommandLine.Var` добавляет флаг во множество флагов командной строки приложения, и присваивает
  значение аргумента параметру `flag.Value`, проверяя наличие необходимых методов в структуре типа.

____

## 7.5. Значения интерфейсов

* `Интерфейс` в Go состоит из двух компонентов - `динамического типа` и `динамического значения`, которые представляют
  `конкретный тип` и `его значение` соответственно;
* Для Go, как для статически типизированного языка, типы являются понятием времени компиляции, поэтому тип не является
  значением;
* `Дескрипторы типов` предоставляют информацию о каждом типе, такую как его имя и методы;
* В `значении интерфейса` компонент типа представлен дескриптором соответствующего типа;
* Переменные в Go всегда инициализируются точным значением, интерфейсы не являются исключением;
* Нулевое значение для интерфейса имеет и тип, и значение, равные `nil`;
* Значение интерфейса можно описать как нулевое или ненулевое, в зависимости от его динамического типа;
* Для проверки, является ли значение интерфейса нулевым, можно использовать инструкции `w==nil` и `w!=nil`;
* Вызов любого метода нулевого интерфейса приводит к
  панике `w.Write([]byte("hello")) // panic: разыменовывание нулевого указателя`;
* `w = os.Stdout` - эта инструкция присваивает `w` значение типа `*os.File` и включает неявное преобразование из
  конкретного типа в тип интерфейса, которое эквивалентно явному преобразованию `io.Writer(os.Stdout)`. Такие
  преобразования охватывают тип и значение своего операнда. Динамический тип значения интерфейса устанавливается равным
  дескриптору для типа указателя `*os.File`, а его динамическое значение хранит **копию** `os.Stdout`, которая является
  указателем на переменную `os.File`, представляющую стандартный вывод процесса;
* Во время компиляции мы не можем знать, каким будет динамический тип значения интерфейса, поэтому вызов
  с помощью интерфейса должен использовать `динамическую диспетчеризацию`;
* Вместо непосредственного вызова компилятор должен генерировать код для получения адреса метода с именем `Write` из
  дескриптора типа и выполнить косвенный вызов по этому адресу. Аргументом получателя для вызова является копия
  динамического значения интерфейса `os.Stdout`. Когда мы используем интерфейсы в Go, то мы можем вызвать методы,
  которые не определены в интерфейсе, но определены в типе, который реализует этот интерфейс. Вместо того чтобы прямо
  вызывать метод, компилятор создает код для получения адреса этого метода из типа и вызывает его через адрес;
* `w = new(bytes.Buffer)` - присваивает значение типа `bytes.Buffer` значению интерфейса. Теперь `динамический тип`
  представляет собой `*bytes.Buffer`, а динамическое значение представляет собой указатель на вновь выделенный буфер;
* Значения интерфейсов в Go могут хранить динамические значения любого размера, что позволяет нам создавать обобщенные
  функции и методы;
* Значения интерфейсов можно сравнивать с использованием операторов `==` и `!=`. Два значения интерфейсов равны, если
  оба равны `nil` или если их динамические типы одинаковы, а динамические значения равны согласно результату сравнения с
  помощью оператора `==` с обычным поведением для данного типа;
* Поскольку значения интерфейсов сравнимы, они могут использоваться в качестве ключей карт или операндов
  инструкции `switch`. Но, если сравниваются два значения интерфейсов, имеющих одинаковые динамические типы и эти типы
  не сравнимы (например, срезы), то сравнение заканчивается паникой;
* В этом отношении типы интерфейсов в Go отличаются от других типов. Другие типы безопасно сравниваемы (такие, как
  фундаментальные типы или указатели) или не сравниваемы вообще (срезы, карты, функции), но при сравнении значений
  интерфейсов или составных типов, содержащих значения интерфейсов, мы должны учитывать потенциальную возможность
  возникновения паники;
* Значения интерфейсов можно сравнивать только в том случае, если мы уверены, что они содержат динамические значения
  сравниваемых типов;
* Аналогичный риск существует при использовании интерфейсов в качестве ключей карт или операндов `switch`. Значения
  интерфейсов можно сравнивать только в том случае, если мы уверены, что они содержат динамические значения сравниваемых
  типов;
* При обработке ошибок или при отладке часто оказывается полезной информация о динамическом типе значения интерфейса.
  Для этого можно использовать символы преобразования `%T` пакета `fmt`.

____

### 7.5.1 Осторожно: интерфейс, содержащий нулевой указатель не является нулевым

* Нулевое значение интерфейса, которое не содержит значения как такового, не совпадает со значением интерфейса,
  содержащим нулевой указатель;
* Если значение `debug` равно `true`, функция `main` накапливает вывод функции `f` в `bytes.Buffer`, и при изменении
  значения `debug` на `false` накопление вывода отключается, что приводит к панике во время вызова `out.Write`;
* Динамическое значение `out` равно `nil`, но динамический тип `out` является `*bytes.Buffer`, что пройдет защитную
  проверку
  `out != nil`, но вызов `(*bytes.Buffer).Write` со значением получателя, равным `nil`, приводит к панике;
* Изменение типа `buf` в функции `main` на `io.Writer` избегает присваивания дисфункционального значения интерфейсу и
  решает проблему с некорректным вызовом `out.Write`.

____

## 7.6. Сортировка с помощью sort.Interface

* Пакет `sort` предоставляет сортировку "на лету", т.е. без привлечения дополнительной памяти любой последовательности в
  соответствии с любой функцией упорядочивания;
* Функция `sort.Sort` ничего не предполагает о представлении последовательности или ее элементах. Вместо этого она
  использует интерфейс, `sort.Interface`, чтобы задать контракт между обобщенным алгоритмом сортировки и всеми типами
  последовательностей, которые могут быть отсортированы. Реализация этого интерфейса определяет как конкретное
  представление последовательности, которая часто является срезом, так и желаемый порядок его элементов.
* Алгоритм сортировки "на лету" требует трех вещей, которые являются методами `sort.Interface`:
	* Длины последовательности;
	* Средства сравнения двух элементов;
	* Способа обмена двух элементов местами.
* Для сортировки любой последовательности нужно определить тип, который реализует три указанных метода, а затем
  применить `sort.Sort` к экземпляру этого типа `sort.Sort(StringSlice(names))`, где `StringSlice` - тип, а `names` -
  срез строк;
* Преобразование типа дает значение среза с теми же длиной, емкостью и базовым массивом, что и у исходного среза, но
  типом, который имеет три метода, необходимые для сортировки;
* Пакет `sort` предоставляет тип `StringSlice` и функцию `Strings` для сортировки среза строк, так что вызов выше можно
  сократить до `sort.Sort(names)`;
* Пакет `text/tabwriter` генерирует таблицы. `*tabwriter.Writer` соответствует интерфейсу `io.Writer`. Он накапливает
  все данные. Метод `Flush` этого типа форматирует всю таблицу и выводит результат;
* Чтобы выполнить сортировку в обратном порядке, не нужно определять новый тип с методом `Less`. Пакет `sort`
  предоставляет функцию `Reverse`, которая преобразует любой порядок сортировки в обратный;
* Функция `Reverse` использует `композицию`. Пакет `sort` определяет неэкспортируемый тип `reverse`, являющийся
  структурой, в которую встроен `sort.Interface`. Метод `Less` для `reverse` вызывает метод `Less` встроенного значения
  `sort.Interface`, но с индексами в обратном порядке, что приводит к обращению результата сортировки;
* Два других метода `reverse`, `Len` и `Swap`, неявно предоставляются исходным значением `sort.Interface`, которое
  является встроенным полем;
* Экспортируемая функция `Reverse` возвращает экземпляр типа `reverse`, который содержит исходное
  значение `sort.Interface`;
* Чтобы определить новый порядок сортировки (по разным полям сразу), нужно определить конкретный тип и функцию
  многоуровневого упорядочивания, где есть первичный, вторичный, третичный ключи. Это требует использования анонимной
  функции;
* Конкретные типы, реализующие интерфейс `sort.Interface` не всегда являются срезами (можно использовать структурный
  тип).
* Чтобы отсортировать последовательность, нужно выполнить `O(n log n)` операций сравнения. Чтобы проверить,
  отсортирована ли последовательность, нужно выполнить не более `n-1` сравнения. Функция `IsSorted` из пакета `sort`
  проверяет, отсортирована ли последовательность. Она использует функцию упорядочения и `sort.Interface`, но не вызывает
  метод `Swap`;
* Для удобства, пакет `sort` предоставляет версии своих функций и типов, специализированные
  для `[]int`, `[]string`, `[]float64` с использованием их естественного порядка. Для других типов, таких
  как `[]int64`, `[]uint`, нужно писать собственную реализацию.

____

## 7.7. Интерфейс http.Handler

* Функция `ListenAndServe` требует адрес сервера и экземпляр интерфейса `Handler`, которому направляются все запросы. Он
  работает бесконечно, если только не происходит ошибка (или при запуске сервера происходит сбой), в таком случае он
  возвращает ненулевую ошибку;
* Интерфейс `http.Handler` имеет единственный метод `ServeHTTP(w ResponseWriter, *Requests`, который позволяет отвечать
  на `HTTP-запросы`;
* `ResponseWriter` - еще один интерфейс, он дополняет интерфейс `io.Writer` методами для отправки HTTP-заголовков
  ответа, а `http.Requests` - структура, которая содержит данные, соответствующие HTTP-запросу, такие, как URL,
  заголовки, тело ответа и т.д.;
* Если мы создадим тип и реализуем для него метод `ServeHTTP`, он будет соответствовать интерфейсу `http.Handler`;
* Чтобы сообщить клиенту об ошибке HTTP, если она произошла, нужно вызвать `w.WriteHeader(http.Status*...)`. Это должно
  быть сделано до записи любого текста в `w`. Так же можно использовать вспомогательную
  функцию `http.Error(w, msg, status)`;
* `r.URL.Query()` - выполняет запрос преобразования параметров HTTP-запроса в мультикарту типа `url.Values` Например:
  ``` go
    vals := r.URL.Query()
    val1 := vals.Get("key1")
    val2 := vals.Get("key2");
    ```
* Если мы реализуем для нашего типа метод `ServeHTTP`, нам нужно использовать `r.URL.Path` и инструкцию `switch` для
  определения адреса из запроса. Это несколько неудобно. Удобнее будет определить логику для каждого случая в виде
  отдельной функции или метода. Плюс к этому, связанным URL может потребоваться схожая логика, например, несколько
  изображений могут иметь `URL` вида `images/*.png`;
* Чтобы удобно добавлять разные варианты действий, и избежать вышеописанной ситуации, пакет `net/http`
  предоставляет `ServeMux` - `мультиплексор запросов`, упрощающий связь между URL и обработчиками (`Handler`);
* `ServeMux` собирает целое множество обработчиков `http.Handler` в единый `http.Handler`. Различные типы,
  соответствующие одному и тому же интерфейсу, являются `взаимозаменяемыми`. Веб-сервер может диспетчеризовать запросы к
  любому `http.Handler`, независимо от того, какой конкретный тип скрывается за ним;
* В более сложных приложениях могут использоваться несколько `ServeMux` и объединятся;
* В Go нет канонического веб-фреймворка, аналогичного Ruby on Rails или Django. Но это не значит, что такого фреймворка
  не может быть. Просто стандартная библиотека Go является настолько гибкой, что конкретный фреймворк просто не нужен.
  Тем более, что наличие фреймворка удобно на ранних этапах проекта, но связанные с ним дополнительные сложности могут
  усложнить дальнейшую поддержку проекта;
* `mux := http.NewServeMux(); mux.Handle("/list", http.HandlerFunc(db.list))` - создаем новый `ServeMux` и используем
  его для сопоставления URL с соответствующим обработчиком. После этого используем `ServeMux` как основной обработчик в
  вызове `log.Fatal(http.ListenAndServe(":8000", mux))`;
* `db.list` в `mux.Hanlde` представляет собой значение-метод, т.е. значение
  типа `func(w http.ResponseWriter, r *http.Requests)`, которое при вызове вызывает метод `database.list`, со значением
  получателя `db`. Проще говоря, `db.list` является функцией, которая реализует поведение обработчика, но, так как у
  этой функции нет методов, она не может соответствовать интерфейсу `http.Hanlder` и не может быть передана
  непосредственно `mux.Handle`;
* `http.HandlerFunc(db.list)` - это преобразование типа, а не вызов функции, поскольку `http.HandlerFunc` является
  типом;
* `HandlerFunc` демонстрирует некоторые необычные возможности механизма интерфейсов Go. Это тип функции, который имеет
  методы и соответствует интерфейсу `http.Handler`. Поведением его метода `ServeHTTP` является вызов базовой функции.
  Таким
  образом, `HandlerFunc` является адаптером, который позволяет значению-функции соответствовать интерфейсу, когда
  функция и единственный метод интерфейса имеют одинаковую сигнатуру;
* Этот трюк, позволяет типу `type database map[string]dollar` соответствовать интерфейсу `http.Handler`
  различными способами - его методами, которые имеют ту же сигнатуру как и интерфейс;
* `ServeMux` имеет удобный метод `HandleFunc`, который приводит тип `database` к соответствию интерфейсу `http.Handler`.
  Поэтому можно упростить код регистрации обработчика до `mux.HandleFunc("/list", db.list)`;
* Чтобы создать два разных веб сервера, которые будут прослушивать разные порты, определять разные URL и выполнять
  диспетчеризацию разными обработчиками - нужно создать еще один `ServeMux` и выполнить еще один вызов `ListenAndServe`;
* Пакет `net/http` предоставляет глобальный экземпляр `ServeMux` с именем `DefaultServeMux` и функциями уровня
  пакета `http.Hanlde` и `http.HanldeFunc`;
* Для использования `DefaultServeMux` в качестве основного обработчика сервера в `ListenAndServe` нужно передать `nil`;
* Веб-сервер вызывает каждый обработчик в новой горутине, так что обработчики должны принимать меры предосторожности,
  такие как блокировки при доступе к переменным, к которым могут обращаться другие горутины (включая другие запросы того
  же обработчика).

____

## 7.8. Интерфейс error

* `error` - это тип интерфейса в Go, который используется для представления ошибок. Он имеет один метод `Error`, который
  возвращает сообщение об ошибке.
* Чтобы создать новое значение `error`, можно использовать функцию `errors.New(msg)`, которая принимает сообщение об
  ошибке и возвращает новое значение `error`;
* Внутри пакета `errors` есть тип `errorString`, который является структурой и используется для хранения сообщения об
  ошибке. Он не может быть изменен после создания (`инкапсуляция`);
* Каждый вызов `errors.New` создает новый экземпляр `error`, который не равен никакому другому. Это означает, что две
  ошибки с одинаковым сообщением об ошибке будут разными значениями `error`;
* Есть также функция `fmt.Errorf`, которая позволяет форматировать сообщение об ошибке и возвращает новое
  значение `error`. Она часто используется вместо `errors.New`
* Пакет `syscall` также предоставляет типы ошибок, которые соответствуют интерфейсу `error`. Они используются для
  представления ошибок системных вызовов. Он предоставляет `API` низкоуровневых системных вызовов Go.
  На многих платформах он предоставляет числовой тип `Errno`.

____

## 7.9. Пример: вычислитель выражения

____

## 7.10. Декларации типов

* `Декларация типа (type assertion)` - это операция, которая проверяет, что значение интерфейса имеет определенный тип.
  Синтаксически она выглядит, как `x.(T)`;
* Если декларация типа успешна, то результатом операции будет значение этого типа. Если нет, то операция вызовет панику;
* Декларация типа может использоваться для извлечения значения из интерфейса;
* Если значение интерфейса равно `nil`, то декларация типа не будет успешной;
* Можно использовать декларацию типа с двумя результатами, чтобы избежать паники. В этом случае второй результат будет
  иметь тип `bool` и указывать на успех или неудачу операции. `f, ok := w.(*os.File)`;
* Если декларация типа используется в присваивании с двумя результатами, то второй результат можно использовать для
  принятия решения о последующих действиях. `if f, ok := w.(*os.File); ok {...}`;
* Иногда имя переменной может быть повторно использовано в декларации типа, чтобы затенить (переприсвоить) оригинальную
  переменную. `w, ok := w.(*os.File)`;
* В общем, декларация типа - это способ проверить и извлечь значение из интерфейса в Go. Она может использоваться для
  обработки ошибок и принятия решений в зависимости от типа значения интерфейса.

____

## 7.11. Распознавание ошибок с помощью деклараций типов

* Операции ввода-вывода могут завершиться ошибкой по разным причинам. В Go есть пакет `os`, который помогает
  обрабатывать эти ошибки. Он предоставляет три функции для классификации ошибок:
	* Файл уже существует (для операций создания файла);
	* Файл не найден (для операций чтения);
	* Отсутствие прав доступа.
* Вместо того чтобы проверять сообщение об ошибке на наличие определенной подстроки, пакет `os` использует специальный
  тип `PathError` для описания ошибок, связанных с операциями над файлами (`Open`, `Delete`). Также есть
  тип `LinkError` (`Symlink`, `Rename`) для ошибок, связанных с операциями над двумя файлами.
* Большинство программистов не обращают внимание на `PathError` и обрабатывают все ошибки одинаково, путем вызова их
  методов `Error`. Хотя метод `Error` ошибки `PathError` формирует сообщение с использованием простой конкатенации
  полей, структура `PathError` сохраняет базовые компоненты ошибки;
* Если нам нужно отличать один тип ошибки от другого, можно использовать декларации типа для обнаружения
  определенного типа ошибки; Это даст больше информации, чем просто строка;
* Если сообщение об ошибке объединяется в более крупную строку, например с помощью вызова `fmt.Errof`, то
  структура `PathError` теряется;
* Обычно распознавание ошибки должно выполняться сразу после сбоя, прежде чем ошибка будет
  передана вызывающей функции.

____

## 7.12. Запрос поведения с помощью деклараций типов

* Метод `Write` интерфейса `io.Writer` принимает байтовый срез в качестве аргумента. Если нужно записать строку,
  необходимо преобразовать ее в байтовый срез с помощью преобразования типа `[]byte(string)`. Это преобразование
  выделяет память и создает копию строки;
* Некоторые типы, соответствующие интерфейсу `io.Writer`, также имеют метод `WriteString`, который позволяет эффективно
  записывать строки без создания временной копии. Примерами таких типов являются `*os.File`, `*bytes.Buffer`
  и `*bufio.Writer`
* Нельзя утверждать, что произвольный `io.Writer w` также имеет метод `WriteString`. Но, можно определить новый
  интерфейс, который имеет только метод `WriteString`, и использовать декларацию типа для проверки, соответствует ли
  динамический тип объекта этому новому интерфейсу. Если это так, то можно вызвать метод `WriteString` для эффективной
  записи строки без создания временной копии;
* Стандартная библиотека Go предоставляет функцию `io.WriteString`, которая использует этот подход для эффективной
  записи строки в объект, соответствующий интерфейсу `io.Writer`;
* `io.WriteString` документирует предположение о том, что конкретный тип соответствует интерфейсу `stringWriter`, но
  функции которые его вызывают, должны документировать, что они делают такое предположение;
* Определение метода у некоторого типа является неявным согласием на определенный поведенческий контракт. Например, если
  тип имеет метод `WriteString`, то предполагается, что этот метод позволяет эффективно записывать строки без создания
  временной копии;
* Декларацию типа можно использовать для проверки типа во время выполнения. Это позволяет выяснить, соответствует ли
  значение общего типа интерфейса более конкретному типу интерфейса, и если это так, то она использует поведение
  последнего. Эта методика может использоваться независимо от того, является ли запрашиваемый интерфейс стандартным,
  как `io.ReadWriter`, или пользовательским, как `stringWriter`;
* Эта методика может использоваться независимо от того, является ли запрашиваемый интерфейс стандартным или
  пользовательским. Например, функция `fmt.Fprintf` использует этот подход для определения, соответствует ли значение
  интерфейсам `error` или `fmt.Stringer`, и изменяет форматирование значения в зависимости от этого;
* Если значение не соответствует ни одному из этих двух интерфейсов (или другим, которые в нем определены), то
  выполняется унифицированная обработка всех прочих типов с использованием рефлексии.

____

## 7.13. Выбор типа

* Интерфейсы в Go могут использоваться двумя способами: для выражения подобия типов и для объединения типов:
	* Первый способ - это когда интерфейс определяет методы, которые должны быть реализованы типами. Это похоже на
	  полиморфизм подтипов, когда объекты разных типов могут использоваться одинаково благодаря общему
	  интерфейсу. `type Expr interface { String() string }`;
	* Второй способ - это когда интерфейс используется как объединение типов. Это позволяет хранить значения разных
	  типов в одной переменной и обрабатывать их по-разному в зависимости от типа. Это похоже на перегрузку, когда
	  функция может принимать аргументы разных типов и обрабатывать их
	  по-разному; `func getType(x interface{}) string {/*...*/}`
* API Go для работы с базами данных SQL позволяет безопасно создавать запросы, заменяя символы `?` на значения
  аргументов;
* Построение запросов таким образом позволяет избежать атак SQL-инъекций. Метод `Exec` преобразует значение каждого
  аргумента в его SQL-запись в виде литерала;
* Инструкция `switch` в Go упрощает написание цепочек `if-else`. Аналогично, `type switch` упрощает написание
  цепочек `if-else` для проверки типов;
* `Type switch` - это инструкция `switch`, которая проверяет динамический тип значения интерфейса;
* Она выглядит как обычная инструкция `switch`, но вместо значения используется `x.(type)`, где `x` - это переменная
  интерфейса, `type` представляет собой ключевое слово;
* Каждый `case` указывает один или несколько типов. Если тип значения `x` соответствует типу в `case`, то выполняется
  тело этого `case`;
* Если ни один `case` не соответствует типу значения `x`, то выполняется тело `default` (если оно есть).
* Все инструкции `case` рассматриваются по порядку, и когда соответствие найдено, выполняется тело соответствующей
  инструкции `case`. Однако, порядок `case` имеет значение в `type switch`, если несколько `case` могут соответствовать
  типу значения `x`. Например, если у
  нас есть интерфейс `interface{}` и два `case`: `case int` и `case interface{int}`. Если значение `x` имеет тип `int`,
  то оба `case` могут соответствовать этому типу. В этом случае будет выполнен `первый case` в порядке следования.
  Поэтому порядок `case` важен при написании `type switch`;
* Использование `fallthrough` запрещено в `type switch`;
* Можно использовать расширенную форму `type switch`, чтобы связать извлеченное значение с новой переменной в
  каждом `case`. Это позволяет получить доступ к значению, извлеченному декларацией типа. `switch x := x.(type)`. Эта
  новая переменная может иметь то же имя, что и переменная интерфейса `x`;
* В каждом `case` с единственным типом новая переменная имеет этот тип. `case int: x // x.(type) == int`;
* В `type switch` можно объединить несколько `case`, если требуется выполнить одно и то же действие для нескольких
  типов (`case int, uint:`);
* Хотя типом переменной `x` является `interface{}`, ее можно рассматривать как `объединение типов`, которые могут
  соответствовать ее значению. Например, если мы знаем, что значение `x` может быть `int, uint, bool, string или nil`,
  то можем рассматривать `x` как объединение этих типов.

____

## 7.14. Пример: XML-декодирование на основе лексем

* Пакет `encoding/xml` в Go предоставляет API для работы с документами XML. Он позволяет декодировать документы XML в
  структуры Go и кодировать структуры Go обратно в XML. Также он предоставляет низкоуровневый API для декодирования XML
  на основе лексем;
* Стиль на основе лексем означает, что синтаксический анализатор получает входные данные и генерирует поток лексем.
  `Лексема` - это единица информации, которая генерируется синтаксическим анализатором. Каждый
  вызов `(*xml.Decoder).Token` возвращает одну лексему;
* Интерфейс Token является примером распознаваемого объединения. Это означает, что он позволяет работать с фиксированным
  набором типов, которые изначально определены и не скрыты;
* Типы распознаваемого объединения обрабатываются с помощью `type switch`, где каждый `case` имеет свою логику;
* API гарантирует, что лексемы `StartElement` и `EndElement` будут соответствовать друг другу даже в неверно
  сформированных документах.

____

## 7.15. Несколько советов

* При проектировании нового пакета в Go нужно избегать создания нескольких интерфейсов до определения соответствующих им
  типов. Это поможет избежать ненужных абстракций с затратами на выполнение. Иначе, этот подход даст несколько
  интерфейсов, каждый из которых имеет только одну реализацию. Не делайте этого;
* Такие интерфейсы являются ненужными абстракциями, которые к тому же имеют свою ненулевую стоимость во время
  выполнения. Ограничить методы типа или поля структуры, видимые извне пакета, можно с помощью механизма экспорта;
* Интерфейсы нужны только в том случае, если есть несколько конкретных типов, работа с которыми должна выполниться
  единообразно.
* Исключением из этого правила является ситуация, когда интерфейс соответствует единственному конкретному типу, но этот
  тип не может находиться в том же пакете из-за зависимостей. В этом случае интерфейс может помочь развязать два пакета;
* Поскольку интерфейсы в Go абстрагируются от деталей реализации, они обычно маленькие с простыми методами, часто с
  одним методом, как `io.Writer` или `fmt.Stringer`;
* Новым типам проще соответствовать небольшим интерфейсам. При проектировании интерфейса стоит следовать
  правилу `запрашивать только самое необходимое`;
* Go поддерживает объектно-ориентированное программирование, но не обязательно использовать его исключительно. Не все
  должно быть объектом. Автономные функции и неинкапсулированные типы данных имеют свое место.

____