# 7.4 Анализ флагов с помощью `flag.Value`

В этом разделе мы рассмотрим еще один стандартный интерфейс, `flag.Value`, который помогает определить новую запись для
флагов командной строки. Рассмотрим приведенную программу (см. sleep.go), которая бездействует указанный период времени.

Перед тем, как перейти в режим ожидания, программа выводит соответствующий период времени. Пакет `fmt` вызывает метод
`String` типа `time.Duration` для вывода периода не как количества наносекунд, а в удобочитаемом виде:

```shell
$ go build \sleep.go
$ .\sleep
Ожидание 1s...
```

По умолчанию период бездействия составляет одну секунду, но им можно управлять с помощью флага командной
строки `period`. Функция `flag.Duration` создает переменную типа `time.Duration` и разрешает пользователю указывать
продолжительность в различных удобных для человека форматах, включая вывод метода `String`. Такой симметричный дизайн
приводит к удобному пользовательскому интерфейсу:

``` shell
$ .\sleep period
50ms
Ожидание 50ms...
$ .\sleep period
2m30s
Ожидание 2m30s...
$ .\sleep period
1.5h
Ожидание 1h30m0s...
$ .\sleep period
"1 day"
Неверное значение "1 day" для флага period
```

Поскольку флаги продолжительности очень полезны, эта возможность встроена в пакет `flag`, но можно легко определить
новый флаг для собственных типов данных. Нужно только определить тип, который соответствует интерфейсу `flag.Value`,
объявление которого показано ниже:

``` go
// Value представляет собой интерфейс значения, хранящегося в флаге.
type Value interface {
    String() string
    Set(string) error
}
```

Метод `String` форматирует значение флага для использования в сообщениях справки командной строки. Таким образом, каждый
`flag.Value` также является `fmt.Stringer`. Метод `Set` анализирует свой строковый аргумент и обновляет значения флага.
По сути, метод `Set` является обратным методом для метода `String`, и использовать для них одни и те же обозначения -
хорошая практика.

Давайте определим тип `Celsius` (раздел 2.5), тем самым получая метод `String` бесплатно. Чтобы удовлетворить интерфейсу
`flag.Value`, осталось только объявить метод `Set` (см. tempconv.go).

Вызов `fmt.Sscanf` получает из входной строки `s` число с плавающей точкой (`value`) и строку (`unit`). Хотя обычно
необходимо проверить результат вызова `Sscanf` на наличие ошибки, в этом случае такая проверка не нужна, поскольку, если
возникнет проблема, в инструкции `switch` просто не найдется нужного соответствия (и тогда вернется ошибка).

Приведенная ниже функция `CelsiusFlag` объединяет все сказанное. Вызывающей функции она возвращает указатель на поле
`Celsius`, встроенное в переменную `f` типа `celsiusFlag`. Поле `Celsius` является переменной, которая будет обновляться
методом `Set` при обработке флага. Вызов `Var` добавляет флаг во множество флагов командной строки приложения
(глобальную переменную `flag.CommandLine`). У программ с необычно сложными интерфейсами командной строки может быть
несколько переменных этого типа. Вызов `Var` присваивает аргумент `*celsiusFlag` параметру `flag.Value`, заставляя
компилятор выполнить проверку того, что тип `*celsiusFlag` имеет необходимые методы.

Теперь можно начать использовать новый флаг в своих программах (см. tempflag.go)

Вот типичные результаты работы программы:

``` shell
$ go build \tempflag
$ .\tempflag
20°C
$ .\tempflag -temp -18C
-18°C
$ .\tempflag -temp -273.15K
неверное значение "273.15K" для флага -temp: неверная температура "273.15K"
Использование .\tempflag:
    -temp value
        температура (по умолчанию 20°C)
$ .\tempflag -help
Использование .\tempflag:
    -temp value
        температура (по умолчанию 20°C)
```

## Выводы:

* Стандартный интерфейс `flag.Value` помогает определить новую запись для флагов командной строки;
* Функция `flag.Duration` создает переменную типа `time.Duration` и разрешает пользователю указывать продолжительность
  в различных удобных для человека форматах, включая вывод метода `String`;
* Для создания собственного флага нужно определить тип данных, соответствующий интерфейсу flag.Value;
* Метод `String` из интерфейса `flag.Value` форматирует значение флага для использования в сообщениях справки командной
  строки. Таким образом, каждый `flag.Value` так же является `fmt.Stringer`;
* Метод `Set` из интерфейса `flag.Value` анализирует свой строковый аргумент и обновляет значения флага. По сути, метод
  `Set` является обратным методом для метода `String`, и использовать для них одни и те же обозначения - хорошая
  практика;
* Функция `fmt.Sscanf` получает данные из строки с указанными форматами;
* Для использования флага, нужно создать функцию, которая будет возвращать указатель на поле, встроенное в структуру.
  Это поле является переменной, которая будет обновляться методом `Set` при обработке флага;
* Вызов `Var` в `flag.CommandLine.Var` добавляет флаг во множество флагов командной строки приложения, и присваивает
  значение аргумента параметру `flag.Value`, проверяя наличие необходимых методов в структуре типа.