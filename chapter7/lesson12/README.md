# 7.12 Запрос поведения с помощью деклараций типов

Приведенная ниже логика схожа с частью веб-сервиса `net/http`, ответственной за написание полей `HTTP-заголовка`, таких
как `Content-Type: text/html`. `io.Writer w` представляет HTTP-ответ: байты, записываемые в него, в конечном итоге
отправляются кому-то на веб-браузер:

``` go
func writeHeader(w io.Writer, contentType string) error {
	if _, err := w.Write([]byte("Content-Type: ")); err != nil {
		return err
	}
	if _, err := w.Write([]byte(contentType)); err != nil {
		return err
	}
	//...
}
```

Поскольку метод `Write` требует байтового среза, а значение, которое мы хотим записывать, является строкой, необходимо
преобразование `[]byte(...)`. Это преобразование выделяет память и делает копию, но копия почти сразу же после записи
отбрасывается. Давайте представим, что эта часть является чуть ли не ядром веб-сервера и что профилирование кода
показывает, что такое распределение памяти существенно замедляет работу. Можем ли мы избежать такого распределения
памяти?

Интерфейс `io.Writer` говорит нам о конкретном типе, хранящемся в `w`, только то, что в него можно записать байты. Если
мы взглянем за кулисы пакета `net/http`, то увидим, что динамический тип, который хранит `w`, имеет также
метод `WriteString`, который позволяет нам эффективно записывать строки без создания временной копии (Это может
показаться странным, но ряд важных типов, соответствующих интерфейсу `io.Writer`, имеют также метод `WriteString`,
включая такие типы, как `*bytes.Buffer`, `*os.File`, `*bufio.Writer`).

Мы не можем утверждать, что произвольный `io.Writer w` также имеет метод `WriteString`. Но мы можем определить новый
интерфейс, который имеет только этот метод, и использовать декларацию типа для проверки, соответствует ли динамический
тип `w` этому новому интерфейсу:

``` go
// writeString записывает s в w.
// Если w имеет метод WriteString, он вызывается вместо w.Write.
func writeString(w io.Writer, s string) (n int, err error) {
	type stringWriter interface {
		WriteString(string) (n int, err error)
	}
	if sw, ok := w.(stringWriter); ok {
		return sw.WriteString(s) // Избегаем копирования
	}
	return w.Write([]byte(s)) // Используем временную копию
}

func writeHeader(w io.Writer, contentType string) error {
	if _, err := writeString(w, "Content-Type: "); err != nil {
		return err
	}
	if _, err := writeString(w, contentType); err != nil {
		return err
	}
	//...
}
```

Чтобы избежать повторения, мы переместили проверку во вспомогательную функцию `writeString`, но она настолько полезна,
что стандартная библиотека предоставляет ее как `io.WriteString`. Это рекомендованный способ записи строки
в `io.Writer`.

В этом примере любопытно то, что нет стандартного интерфейса, который определяет метод `WriteString` и указывает его
требуемое поведение. Кроме того, соответствует ли конкретный тип интерфейсу `stringWriter`, определяется только его
методами, а не каким-то объявленным взаимоотношением между ним и типом интерфейса. Это означает, что показанная выше
методика опирается на предположение, что `если` тип соответствует показанному ниже интерфейсу, `то`
вызов `WriteString(s)` должен выполнять те же действия, что и `Write([]byte(s))`.

``` go
interface {
	io.Writer
	WriteString(s string) (n int, err error)
}
```

Хотя `io.WriteString` документирует это предположение, несколько функций, которые его вызывают, вероятно, должны
документировать, что они делают такое же предположение. Определение метода у некоторого типа является неявным согласием
на определенный поведенческий контракт. Новичкам в Go, особенно тем, у которых имеется опыт работы со строго
типизированными языками, это отсутствие явного указания намерений может показаться тревожащим, но на практике оно редко
вызывает проблемы. За исключением пустого интерфейса `interface{}`, типы интерфейса редко удовлетворяются из-за
непреднамеренного совпадения.

Показанная выше функция `writeString` использует декларацию типа для того, чтобы выяснить, соответствует ли значение
общего типа интерфейса более конкретному типу интерфейса, и если это так, то она использует поведение последнего. Эта
методика может использоваться независимо от того, является ли запрашиваемый интерфейс стандартным, как `io.ReadWriter`,
или пользовательским, как `stringWriter`.

Именно так `fmt.Fprintf` отличает значения, соответствующие `error` или `fmt.Stringer`, от всех прочих значений. В
`fmt.Fprintf` имеется шаг, преобразующий отдельный операнд в строку, что-то вроде этого:

``` go
package fmt

func formatOneValue(x interface{}) string {
	if err, ok := x.(error); ok {
		return err.Error()
	}
	if str, ok := x.(Stringer); ok {
		return str.String()
	}
	//... Все прочие типы... 
}
```

Если `x` соответствует любому из этих двух интерфейсов, они определяют форматирование данного значения. Если же нет,
выполняется более или менее унифицированная обработка всех прочих типов с использованием рефлексии (глава 12.).

И вновь здесь используется предположение, что любой тип с методом `String` соответствует контракту
поведения `fmt.Stringer`, который возвращает годящуюся для вывода строку.

## Выводы:

* Метод Write интерфейса io.Writer принимает байтовый срез в качестве аргумента. Если нужно записать строку, необходимо
  преобразовать ее в байтовый срез с помощью преобразования типа []byte(string). Это преобразование выделяет память и
  создает копию строки;
* Некоторые типы, соответствующие интерфейсу `io.Writer`, также имеют метод `WriteString`, который позволяет эффективно
  записывать строки без создания временной копии. Примерами таких типов являются `*os.File`, `*bytes.Buffer`
  и `*bufio.Writer`
* Нельзя утверждать, что произвольный `io.Writer w` также имеет метод `WriteString`. Но, можно определить новый
  интерфейс, который имеет только метод `WriteString`, и использовать декларацию типа для проверки, соответствует ли
  динамический тип объекта этому новому интерфейсу. Если это так, то можно вызвать метод `WriteString` для эффективной
  записи строки без создания временной копии;
* Стандартная библиотека Go предоставляет функцию `io.WriteString`, которая использует этот подход для эффективной
  записи строки в объект, соответствующий интерфейсу `io.Writer`;
* `io.WriteString` документирует предположение о том, что конкретный тип соответствует интерфейсу `stringWriter`, но
  функции которые его вызывают, должны документировать, что они делают такое предположение;
* Определение метода у некоторого типа является неявным согласием на определенный поведенческий контракт. Например, если
  тип имеет метод `WriteString`, то предполагается, что этот метод позволяет эффективно записывать строки без создания
  временной копии;
* Декларацию типа можно использоваться для проверки типов во время выполнения. Это позволяет выяснить, соответствует ли
  значение общего типа интерфейса более конкретному типу интерфейса, и если это так, то она использует поведение
  последнего. Эта методика может использоваться независимо от того, является ли запрашиваемый интерфейс стандартным,
  как `io.ReadWriter`, или пользовательским, как `stringWriter`;
* Эта методика может использоваться независимо от того, является ли запрашиваемый интерфейс стандартным или
  пользовательским. Например, функция `fmt.Fprintf` использует этот подход для определения, соответствует ли значение
  интерфейсам `error` или `fmt.Stringer`, и изменяет форматирование значения в зависимости от этого;
* Если значение не соответствует ни одному из этих двух интерфейсов (или другим, которые в нем определены), то
  выполняется унифицированная обработка всех прочих типов с использованием рефлексии.