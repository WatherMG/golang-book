# 7.11 Распознавание ошибок с помощью декларации типов

Рассмотрим множество ошибок, возвращаемых файловыми операциями в пакете `os`. Операция ввода-вывода может завершиться
ошибкой из-за множества причин, но зачастую три разновидности неудач должны быть обработаны по-разному:

* файл уже существует (для операций создания файла);
* файл не найден (для операций чтения);
* отсутствие прав доступа.

Пакет `os` предоставляет три вспомогательные функции для классификации сбоев в соответствии со значением `error`:

```go
package os

func IsExist(err error) bool
func IsNotExist(err error) bool
func IsPermission(err error) bool
```

Наивная реализация этих предикатов может проверять, что сообщение об ошибке содержит определенную подстроку:

``` go
func IsNotExist(err error) bool {
	// Примечание: не надежно!
	return strings.Contains(err.Error(), "файл не существует")
}
```

Однако, поскольку логика обработки ошибок ввода-вывода может варьироваться от одной платформы к другой, этот подход не
является надежным, а одна и та же ошибка может быть передана с различными сообщениями. Проверка наличия подстроки в
сообщении об ошибке может оказаться полезной при тестировании, чтобы обеспечить корректное сообщение об ошибке функцией,
но для продакшн кода его недостаточно.

Более надежный подход заключается в представлении структурированных значений ошибок с помощью специального типа.
Пакет `os` определяет тип `PathError` для описания сбоев, связанных с операциями над путями файлов, такими как `Open`
или `Delete`, а также вариант `LinkError` для описания сбоев операций, включающих два пути к файлам, например операций
`Symlink` или `Rename`. Вот как выглядит `os.PathError`:

```go
package os

// PathError записывает ошибку, а также операцию и путь к файлу, которые ее вызвали.
type PathError struct {
	Op   string
	Path string
	Err  error
}

func (e *PathError) Error() string {
	return e.Op + " " + e.Path + ": " + e.Err.Error()
}
```

Большинство клиентов не обращают внимания на `PathError` и обрабатывают все ошибки единообразно, путем вызова их методов
`Error`. Хотя метод `Error` ошибки `PathError` формирует сообщение с использованием простой конкатенации полей,
структура `PathError` сохраняет базовые компоненты ошибки. Клиенты, которым необходимо отличать один вид отказа от
другого, могут использовать декларации типа для обнаружения определенного типа ошибки; конкретный тип обеспечивает более
подробную информацию, чем простая строка.

``` go
_, err := os.Open("/no/such/file")
fmt.Println(err) // открытие /no/such/file: нет такого файла
fmt.Printf("%#v\n", err)
// Вывод:
// &fs.PathError{Op:"open", Path:"/no/such/file", Err:0x3}
```

Так работают три упомянутые вспомогательные функции. Например, показанная ниже `IsNotExist` сообщает, равна ли ошибка
`syscall.ENOENT` (раздел 7.8) или отличной от нее ошибке `os.ErrNotExist` (см. io.EOF в разделе 5.4.2),
или `*PathError`, базовой ошибкой которой является одной из перечисленных:

``` go
var ErrNotExist = errors.New(`file does not exist`)

// IsNotExist возвращает булево значение, указывающее, произошла ли ошибка,
// связанная с отсутствием файла или каталога. Условию соответствует как ошибка
// ErrNotExist, так и некоторые ошибки системных вызовов.
func IsNotExist(err error) bool {
	if pe, ok := err.(*PathError); ok {
		err = pe.Err
	}
	return err == syscall.ENOENT || err == ErrNotExist
}
```

А вот как выглядит применение этой функции:

``` go
_, err := os.Open("/no/such/file")
fmt.Println(os.IsNotExist(err)) // true
```

Конечно, структура `PathError` теряется, если сообщение об ошибке объединяется в более крупную строку, например с
помощью вызова `fmt.Errof`. Обычно распознавание ошибки должно выполняться сразу после сбоя, прежде чем ошибка будет
передана вызывающей функции.

## Выводы:

* Операции ввода-вывода могут завершиться ошибкой по разным причинам. В Go есть пакет `os`, который помогает
  обрабатывать эти ошибки. Он предоставляет три функции для классификации ошибок:
	* Файл уже существует (для операций создания файла);
	* Файл не найден (для операций чтения);
	* Отсутствие прав доступа.
* Вместо того чтобы проверять сообщение об ошибке на наличие определенной подстроки, пакет `os` использует специальный
  тип `PathError` для описания ошибок, связанных с операциями над файлами (`Open`, `Delete`). Также есть
  тип `LinkError` (`Symlink`, `Rename`) для ошибок, связанных с операциями над двумя файлами.
* Большинство программистов не обращают внимание на `PathError` и обрабатывают все ошибки одинаково, путем вызова их
  методов `Error`. Хотя метод `Error` ошибки `PathError` формирует сообщение с использованием простой конкатенации
  полей, структура `PathError` сохраняет базовые компоненты ошибки;
* Если нам нужно отличать один тип ошибки от другого, можно использовать декларации типа для обнаружения
  определенного типа ошибки; Это даст больше информации, чем просто строка;
* Если сообщение об ошибке объединяется в более крупную строку, например с помощью вызова `fmt.Errof`, то
  структура `PathError` теряется;
* Обычно распознавание ошибки должно выполняться сразу после сбоя, прежде чем ошибка будет
  передана вызывающей функции.