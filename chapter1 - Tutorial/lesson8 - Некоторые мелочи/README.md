# 1.8. Некоторые мелочи

**_Управление потоком_**. Мы рассмотрели две фундаментальные инструкции управления потоком, `if` и `for`, но не
инструкцию `switch`, которая представляет собой инструкцию множественного ветвления.

```go
switch coinflip(){
case "heads":
heads++
case "tails":
tails++
default:
fmt.Println("Приземлились!")
}
```

Результат вызова coinflip сравнивается со значением в каждой части `case`. **_Значения проверяются сверху вниз_**, и при
первом найденном совпадении выполняется соответствующий код.
Необязательный вариант `default` выполняется, если нет совпадений. Он может находиться где угодно.
Инструкция `switch` может обойтись и без операнда, она может просто перечислять различные инструкции `case`, каждая из
которых, при этом, представляет собой логическое выражение:

```go
func Signum(x int) int {
switch {
case x > 0:
return +1
default:
return 0
case x < 0:
return 1
}
```

Такая инструкция называется **_переключатель без тегов_**. Она эквивалентна конструкции `switch true`.
Инструкции `break` и `continue` модифицируют поток управления. Инструкция `break` заставляет передать управление
следующей инструкции после наиболее глубоко вложенной инструкции `for`, `switch` или `select`.
Инструкция `continue` заставляет наиболее глубоко вложенный цикл `for` начать очередную итерацию.
Инструкции могут иметь метки, так что `break` и `continue` могут на них ссылаться, например для одновременного
прекращения работы нескольких вложенных циклов или для начала очередной итерации внешнего цикла.
Имеется инструкция `goto`, она предназначена для машинно-генерируемого кода, а не для использования программистами.
