# 1.3 Поиск повторяющихся строк

Для условия инструкции `if`, как и в цикле `for`, не нужно ставить вокруг скобки, но для тела инструкции фигурные скобки
обязательны. Может существовать необязательная часть `else` - выполняется, если условие `if` ложно.

`map` - содержит набор пар "ключ-значение" и обеспечивает константное время выполнения операций хранения, извлечения
или проверки наличия элемента во множестве. `Ключ` может быть любого типа, если значения этого типа можно сравнить при
помощи оператора `==` (в основном используют строки). Значение может быть любого типа.

https://github.com/WatherMG/golang-book/blob/474fd7800d3cd8f86aff873c1ddbbb90985b8e80/chapter1%20-%20Tutorial/lesson3%20-%20%D0%9F%D0%BE%D0%B8%D1%81%D0%BA%20%D0%BF%D0%BE%D0%B2%D1%82%D0%BE%D1%80%D1%8F%D1%8E%D1%89%D0%B8%D1%85%D1%81%D1%8F%20%D1%81%D1%82%D1%80%D0%BE%D0%BA/dup1.go#L17-L21

> В примере (см. **dup1.go**) встроенная функция `make` сознает новое пустое множество `map`. **_Ключи_** представляют
> собой строки, а **_значения_** представлены типом `int`.
> Каждый раз, когда программа считывает строку ввода, эта строка используется как **_ключ_** в `map`, и увеличивает
> значение на 1 с этим ключом.
> Инструкция `counts[input.Text()]++` эквивалентна:

```
line := input.Text()
counts[line] = counts[line] + 1
```

Если во множестве нет нужного ключа это не проблема. Когда новая строка встречается впервые, выражение `counts[line]`
в правой части присваивает нулевое значение новому элементу, которое для типа `int` = `0`.

> Для вывода результатов мы используем цикл по диапазону, на этот раз по множеству `counts`. Каждая итерация возвращает
> ключ и значение элемента множества для конкретного ключа. Порядок обхода множества не определен, на практике он
> случаен.
> **_Элементы множества не отсортированы. Это сделано преднамеренно - при сортировке было бы недостижимо
> константное время операций с множествами._**

Пакет `bufio`, он помогает сделать ввод и вывод эффективным и удобным. Тип `Scanner` - один из
наиболее полезных, он **_считывает входные данные и разбивает их на строки или слова._** _Как правило, это самый простой
способ обработки ввода, который поступает построчно._

> Мы используем краткое объявление переменной `:=`, для создания новой переменной и ссылаемся на `bufio.Scanner()`
>
> Сканер считывает ввод из консоли `os.Stdin`, каждый вызов `input.Scan()` считывает очередную строку в цикле и удаляет
> завершающий символ новой строки `\n`. Результат можно получить используя `input.Text()`.
>
> Функция `Scan` возвращает значение `true`, если строка считана и доступна, и значение `false`, если входные данные
> исчерпаны (в данном примере программа завершила выполнение).

Функция `fmt.Printf()` - выполняет форматированный вывод на основе списка выражений. Первый аргумент - строка формата,
которая указывает, как должны быть отформатированы последующие аргументы. Формат каждого аргумента определяется символом
преобразования - `символ процента и буква`. Например `%d` - форматирует целочисленный операнд в десятичной записи, а
`%s` - выводит значение строки.

Функция `Printf()` имеет больше десятка преобразований `verbs`. Краткий перечень:

| **Наименование** | **Описание**                                                                           |
|:----------------:|:---------------------------------------------------------------------------------------|
|      **%d**      | Десятичное целое число                                                                 |
|  **%x, %o, %b**  | Целое число в 16-м, 8-м и двоичном представлении                                       |
|  **%f, %g, %e**  | Числа с плавающей точкой.<br/> **3.141593** / **3.141592653589793** / **3.141593e+00** |
|      **%t**      | Булево значение true или false                                                         |
|      **%с**      | Руна (**символ Unicode**)                                                              |
|      **%s**      | Строка                                                                                 |
|      **%q**      | Выводит в кавычках строку типа "abc" или символ типа 'c'                               |
|      **%v**      | Любое значение в формате по умолчанию                                                  |
|      **%T**      | Тип любого значения                                                                    |
|      **%%**      | Символ процента (не требует операнда)                                                  |

Строки могут содержать _управляющие последовательности символов_, их не видно при выводе текста, например - `\n` -
символ новой строки, `\t` - символ табуляции.
**_По умолчанию `Printf()` не содержит символ новой строки._**
_По соглашению, функции форматирования, имена у которых заканчиваются на `f`, такие, как `log.Printf` и `fmt.Errorf`_
используют такие же правила форматирования как в `fmt.Printf()`. Функции, имена которых заканчиваются на `ln` -
форматируют свои аргументы так, как будто используется символ преобразования `%v`, а за ним `\n`.

Функция `os.Open()` возвращает 2 значения: 1 - открытый файл, который в дальнейшем читает `Scanner`. 2 - значение
встроенного типа `error`. Если возвращает `nil` - файл открыт `os.Open()` и по достижении конца файла он закрывается
функцией `Close()` и освобождает все ресурсы связанные с ним. Если `err != nil` - что-то пошло не так. Возвращаемая
ошибка
содержит описание из-за чего что-то пошло не так.

https://github.com/WatherMG/golang-book/blob/474fd7800d3cd8f86aff873c1ddbbb90985b8e80/chapter1%20-%20Tutorial/lesson3%20-%20%D0%9F%D0%BE%D0%B8%D1%81%D0%BA%20%D0%BF%D0%BE%D0%B2%D1%82%D0%BE%D1%80%D1%8F%D1%8E%D1%89%D0%B8%D1%85%D1%81%D1%8F%20%D1%81%D1%82%D1%80%D0%BE%D0%BA/dup2.go#L23-L28
> В примере, для обработки ошибок, мы используем функцию `Fprintf` с символом преобразования `%v` которая выведет
> сообщение в консоль, после чего программа перейдет к следующему файлу с помощью `continue`