# 3.4 Булевы значения

Тип `bool` или **_булев тип (boolean)_**, имеет только два возможных значения - `true`, `false`. Булевым являются
условия в инструкциях `if`, `for`, а операторы сравнения `==`, `!=`, `<` и т.д. дают булев результат.

Унарный оператор `!` представляет собой логическое отрицание, так, что `!true` равно `false` (можно сказать, что
`(!true==false)==true`), но, в качестве хорошего стиля, лучше всегда упрощать излишние булевы выражения:
вместо `x==true`, лучше `x`.

Булевы значения могут быть объеденины с помощью операторов `&& (И)` и `||(ИЛИ)`, при вычислении которых используется
**_сокращенное (shortcircuit)_** вычисление: если ответ определяется значением левого операнда, правый операнд не
вычисляется. Это делает безопасными выражения, подобные следующему:

``` go
s != "" && s[0] == 'x'
```

Выражение `s[0]` приводит к сбою программы при применении к пустой строке.
Поскольку оператора `&&` имеет более высокий приоритет, чем оператор `||` (мнемоника: `&&` представляет собой булево
умножение, а `||` - булево сложение), для условий приведенного ниже вида не требуются никакие скобки:

``` go
if 'a' <= c && c <= 'z' || 
	'A' <= c && c <= 'Z' || 
	'0' <= c && c <= '9' { 
	// ...ASCII-буква или цифра...
    }
```

Не существует неявного преобразования булева значения в числовое значение наподобие `0` или `1` и обратно. Необходимо
использовать явную инструкцию `if`, как показано ниже:
``` go
i := 0
if b {
    i = 1
}
```
При частой необходимости такой операции может иметь смысл написание специальной функции преобразования:
``` go
// btoi возвращает 1, если b равно true, и 0, если false.
func btoi(b bool) int {
    if b {
        return 1
    }
    return 0
}
```

Обратная операция настолько простая, что она не стоит написания отдельной функции, но для симметрии мы приведем ее ниже:
``` go
// itob указывает, имеет ли i ненулевое значение
func itob(i int) bool { return i!=0 }
```

