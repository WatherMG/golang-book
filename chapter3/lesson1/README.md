# 3.1 Целые числа

Числовые типы данных в Go включают целые числа нескольких размеров, числа с плавающей точкой и комплексные числа.
Каждый числовой тип определяет размер и знаковость своих значений.

Целые числа:

Go обеспечивает как знаковую, так и беззнаковую целочисленную арифметику:

* 8 бит - знаковый int8, беззнаковый uint8
* 16 бит - знаковый int16, беззнаковый uint16
* 32 бита - знаковый int32, беззнаковый uint32
* 64 бита - знаковый int64, беззнаковый uint64

Есть два типа, которые называются просто `int` и `uint` и имеют естественный или наиболее эффективный размер для
знаковых и беззнаковых целых чисел на конкретной платформе.
`int` - является наиболее широко используемым числовым типом. Оба этих типа имеют одинаковый размер (32 либо 64 бита).
Но не нужно делать никаких предположений о том, какой именной из них используется - различные компиляторы могут делать
разный выбор размера даже на одном и том же аппаратном обеспечении.

Тип `rune` является синонимом для типа `int32` и по соглашению указывает, что данное значение является символом
`unicode`. Эти два имени могут использоваться взаимозаменяемо.

Тип `byte` - синоним для типа uint8 и подчеркивает, что это значение является фрагментом неформатированных данных, а не
малым числом.

Имеется беззнаковый целочисленный тип `uintptr`, ширина которого не указана, но достаточна для хранения всех битов
значения указателя. Тип `uintptr`используется только для низкоуровневого программирования, такого, как стыковка
программы Go с библиотекой на C или с операционной системой.

Независимо от размера типы `int`, `uint`, `uintptr` отличаются от своих "братьев" с явно указанным размером.
Таким образом, `int` - это не тот же тим, что и `int32`, даже если на данной платформе естественный размер целых чисел
составляет 32 бита и там, где нужно использовать значение типа `int`, в то время как требуется значение типа `int32` (и
наоборот), необходимо явное преобразование типов.

Знаковые числа представлены в формате дополнения до 2 (в нем старший бит зарезервирован для знака числа: 0 для +, 1
для -). Границы диапазона значений для n-разрядного числа от $-2^{n-1}$ до $2^{n-1}-1$. Целые беззнаковые числа
используют для представления неотрицательных значений все биты и, таким образом, имеют диапазон значений от 0 до
$2^n-1$.
Например, границы диапазона значений для `int8` от -128 до 127, тогда как для `uint8` - от 0 до 255.

Основные бинарные операторы Go (арифметические, логические и операторы сравнения) в порядке уменьшения приоритета:

| Приоритет | Оператор | Описание                                                                                                                   | Пример                                       |
|:---------:|:--------:|----------------------------------------------------------------------------------------------------------------------------|----------------------------------------------|
|     1     |    *     | Умножение операндов                                                                                                        | a * b                                        |
|     1     |    /     | Деление                                                                                                                    | a / b                                        |
|     1     |    %     | Деление по модулю                                                                                                          | a % b                                        |
|     1     |    <<    | Оператор смещения влево – перемещает бит **влево** <br/>на количество позиций, заданное в правом операнде                  | 0011 1100 << 2 = 1111 0000                   |
|     1     |   \>>    | Оператор смещения вправо – перемещает бит **вправо** <br/>на количество позиций, заданное в правом операнде                | 0011 1100 >> 2 = 0000 1111                   |
|     1     |    &     | Оператор AND копирует бит в результат,<br/> **если он есть в обоих операндах**                                             | 0011 1100 &<br/> 0000 1101 =<br/> 0000 1100  |
|     1     |    &^    | Оператор AND NOT, копирует бит в результат,<br/> **если он присутствует в первом операнде,<br/> но отсутствует во втором** | 0011 1100 &^<br/> 0000 1101 =<br/> 0011 0000 |
|     2     |    +     | Сложение двух операндов                                                                                                    | a + b                                        |
|     2     |    -     | Вычитает правый операнд из левого                                                                                          | a - b                                        |
|     2     |    \|    | Оператор “ИЛИ” (OR) копирует бит в результат,<br/> **если бит задан в одном из операндов**                                 | 0011 1100 \|<br/> 0000 1101 =<br/> 0011 1101 |
|     2     |    ^     | Оператор “X-ИЛИ” (XOR) копирует бит в результат,<br/> **если бит задан в одном из операндов, но не в обоих**               | 0011 1100 ^<br/> 0000 1101 =<br/> 0011 0001  |
|     3     |    ==    | Сравнивает равны ли значения операндов,<br/> возвращает **true**, если **равны**                                           | a == b                                       |
|     3     |    !=    | Сравнивает равны ли значения операндов,<br/> возвращает **true**, если **не равны**                                        | a != b                                       |
|     3     |    <     | Проверяет, имеет ли левый операнд значение **меньшее**,<br/> чем правый, если да – возвращает true                         | a < b                                        |
|     3     |    <=    | Проверяет, имеет ли левый операнд значение **меньшее**<br/> или равное правому, если да – возвращает true                  | a <= b                                       |
|     3     |    \>    | Проверяет, имеет ли левый операнд значение **большее**,<br/> чем правый, если да – возвращает true                         | a > b                                        |
|     3     |   \>=    | Проверяет, имеет ли левый операнд значение **большее**<br/> или равное правому, если да – возвращает true                  | a >= b                                       |
|     4     |    &&    | Логический оператор “И” (AND). Если **оба** операнда<br/> **не содержат ноль**, то выражение истинно                       | a && b                                       |
|     5     |   \|\|   | Логический оператор “ИЛИ” (OR). Если **один** из операндов<br/> **не содержат ноль**, то выражение истинно                 | a \|\| b                                     |

Есть только 5 уровней приоритета для бинарных операторов. Операторы на одном и том же уровне **_левоассоциативны_**,
поэтому для ясности или для того, чтобы действия выполнялись в нужном порядке, могут быть необходимы
скобки - `mask & (1 << 28)`.

Каждый оператор, с приоритетом `1` и `2`, например `+` имеет соответствующий **_присваивающий оператор_**, такой
как `+=`, который может быть использован для сокращения записи инструкции присваивания.

Арифметические операторы `+, -, *, /` могут применяться к целым числам, числам с плавающей точкой и комплексным числам.
Оператор получения остатка при делении `%` применяется только к целым числам.
Поведение `%` для отрицательных чисел различно в разных ЯП. В Go знак остатка всегда такой же, как и знак делимого, так
что и `-5%3` и `5%-3` равны `-2`.

Поведение оператора `/` зависит от того, являются ли его операнды целыми числами, так что `5.0/4.0` равно `1.25`, но
`5/4` равно `1`, так как при целочисленном делении происходит усечение результата по направлению к нулю.

Если результат арифметической операции, как знаковой, так и беззнаковой, имеет больше битов, чем может быть представлено
типом результата, мы говорим о **_переполнение (overflow)_**. При этом старшие биты, которые не помещаются в результате
молча сбрасываются. Если исходное число имеет знаковый тип, результат может быть отрицательным, если левый бит (старший)
равен 1:

``` go
var u uint8 = 255
fmt.Println(u, u+1, u*u) // "255 0 1"
var i int8 = 127
fmt.Println(i, i+1, i*i) // "127 -128 1"
```

> Старший бит - это 1 или 0, которые самые левые и определяют знак - или + у числа.
> Например, в десятичной форме число 127 в двоичной форме выглядит так: 01111111. Старший бит равен 0, поэтому число
> является положительным. А число -128 в десятичной форме выглядит так: 10000000. Старший бит равен 1, поэтому число
> является отрицательным.
> Младший бит - остальные биты, которе и определяют само число.

Два целых числа одного и того же типа можно сравнить с использованием бинарных операторов сравнения. Результат выражения
сравнения является логическим (булевым) значением.

Фактически все значения фундаментальных типов - логические, числа и строки - являются **_сравниваемыми_**, а это
означает, что два значения одного и того же типа можно сравнивать с помощью операторов `==`, `!=`. Кроме того, целые
числа, числа с плавающей точкой и строки являются **_упорядочиваемыми_** с помощью операторов сравнения. Значения
многих других типов не являются сравниваемыми, а многие другие типы не являются упорядочиваемыми.

Имеются также унарные операторы `+` и `-`:

Для целых чисел запись `+x` является кратной формой записи для `0+x`, а `-x` - краткой формой для `0-x`. Для чисел с
плавающей точкой и комплексных чисел `+x` равно просто `x`,а `-x` является значением `x` с противоположным знаком.

Go так же предоставляет следующие побитовые бинарные операторы, первые четыре из которых рассматривают свои операнды как
**_битовые шаблоны_**, без понятий переноса или знака.

Оператор `^` представляет собой побитовое исключающее ИЛИ (XOR) при использовании в качестве бинарного оператора, но при
использовании в качестве **унарного префиксного оператора** он представляет собой **побитовое отрицание,
или дополнение**.
В таком случае оператор возвращает значение, в котором каждый бит равен инвертированному соответствующему биту его
операнда.

Оператор `&^` является оператором **_сброса бита_**: в выражении `z = x &^ y` каждый бит `z` равен `0`, если
соответствующий бит равен `1`. В противном случае он равен соответствующему биту `x`.

Приведенный ниже код показывает, как можно использовать битовые операции для интерпретации значения `uint8` в качестве
компактного и эффективного набора восьми независимых битов. Он использует символы преобразования `%b` в `Printf` для
вывода двоичных цифр числа.
`08` уточняет поведение `%b`, заставляя дополнять результат нулями так, чтобы выводилось ровно 8 цифр.

``` go
var x uint8 = 1 << 1 | 1 << 5
var y uint8 = 1 << 1 | 1 << 2

fmt.Printf("%08b\n", x) // "00100010", множество {1, 5}
fmt.Printf("%08b\n", y) // "00000110", множество {1, 2}
fmt.Printf("%08b\n", x&y) // "00000010", пересечение {1}
fmt.Printf("%08b\n", x|y) // "00100110", объединение {1, 2, 5}
fmt.Printf("%08b\n", x^y) // "00100100", симметричная разность {2, 5}
fmt.Printf("%08b\n", x&^y) // "00100000", разность {5}

for i := uint(0); i < 8; i++ {
    if x&(1<<i) != 0 { // проверка принадлежности множеству
        fmt.Println(i) // "1", "5"
    }
}

fmt.Printf("%08b\n", x<<1) // "01000100", множество {2, 6}
fmt.Printf("%08b\n", x>>1) // "00010001", множество {0, 4}
```

В операциях сдвига `x<<n` и `x>>n` операнд `n` определяет количество позиций сдвига и должен быть беззнаковым значением.
Операнд `x` может быть как беззнаковым, так и знаковым. Арифметически сдвиг влево `x<<n` эквивалентен умножению на
$2^n$,
а сдвиг вправо `x>>n` - делению на $2^n$.

Сдвиг влево заполняет освобождающиеся биты нулями, так же как и сдвиг вправо для беззнакового значения. Но сдвиг вправо
знаковых чисел заполняет освобождаемые биты копиями знакового бита. По этой причине, при рассмотрении целых чисел в
качестве битового шаблона важно использовать беззнаковую арифметику.

Пример:
> * Допустим, у нас есть число `5` в двоичной форме: `00000101`;
> * Если мы сдвинем это число вправо на 1 позицию (`x >> 1`), то получим число `00000010`, то есть `2`;
> * Теперь допустим, у нас есть знаковое число `-5` в двоичной форме: `10000101`;
> * Если мы сдвинем это число вправо на 1 позицию (`x >> 1`), то получим число `11000010`, то есть `-2`;

Хотя Go представляет беззнаковые числа и арифметику, мы склонны использовать знаковый тип `int` даже для чисел, которые
не могут быть отрицательными, например для таких, как длина массива, хотя `uint` может показаться более очевидным
выбором. В действительности встроенная функция `len` возвращает знаковый `int`, как в приведенном цикле, который
объявляет призовые медали в обратном порядке:

``` go
medals := []string{"золото", "серебро", "бронза"}
for i := len(medals) - 1; i > 0; i-- {
    fmt.Println(medals[i]) // "бронза", "золото", "серебро"
}
```

Альтернатива оказалась бы катастрофической. Если бы `len` возвращал беззнаковое число, то переменная `i` также имела бы
тип `uint`, и условие `i > 0` было бы всегда верно по определению. После третьей итерации, в которой `i == 0`,
инструкция `i--` привела бы к тому, что значение `i` стало бы равным не `-1`, а максимальному значению типа `uint`
($2^64-1$), и вычисление `medals[i]` при попытке получить доступ к элементу за пределами границ среза привело бы к сбою
времени выполнения, или к **_аварийной ситуации (panic)_**.

По этой причине беззнаковые числа, как правило, используются только тогда, когда в выражении используются побитовые или
необычные арифметические операторы, как например, при реализации битовых множеств, при проведении анализа форматов
бинарных файлов или для хеширования и криптографии. Как обычные неотрицательные значения они, как правило, не
используются.

В общем случае для преобразования значения из одного типа в другой требуется явное преобразование типа, а бинарные
арифметические и логические операторы (кроме сдвигов) должны иметь операнды одного и того же типа. Хотя это правило
иногда и приводит к более длинным выражениям, зато при этом устраняется целый класс проблем и облегчается понимание
программ.

Рассмотрим последовательность:

``` go
var apples int32 = 1
var oranges int16 = 2
var compote int = apples + oranges // Ошибка компиляции
```

Попытка компиляции этих трех объявлений приводит к сообщению об ошибке:
`invalid operation: apples+oranges (mismatched types int32 and int16)` - несоответствие типов

Это несоответствие типов можно разрешить несколькими способами, наиболее простой из которых - явное приведение к одному
типу:

``` go
var compote = int(apples) + int(oranges)
```

> Для каждого типа `T` операция преобразования `T(x)` преобразует значение `x` в тип `T`, если такое преобразование
> разрешено.

Многие преобразования целого значения в целое не влекут за собой каких-либо изменений значения. Они просто сообщают
компилятору, как тому следует интерпретировать данное значение. Однако преобразование, которое сужает целое число
большего размера до меньшего, или преобразование целого числа в число с плавающей точкой и обратно, может изменить
значение или привести к потере точности:

``` go
f := 3.141 // float64
i := int(f)
fmt.Println(f, i) // "3.141 3"
f = 1.99
fmt.Println(int(f)) // "1"
```

Преобразование значения с плавающей точкой в целое число приводит к отбрасыванию дробной части, т.е. к усечению по
направлению к нулю. Следует избегать преобразований, в которых операнд находится вне диапазона целевого типа, потому
что, при этом поведение зависит от реализации:

``` go
f := 1e100 // float64
i := int(f) // Результат зависит от реализации
```

Целочисленные литералы любого размера и типа могут быть записаны как обычные десятичные числа, как восьмеричные числа,
если они начинаются с `0` (как `0666`), или как шестнадцатеричные, если они начинаются с `0x` или `0X` (`0xdeadbeef`).
Шестнадцатеричные цифры могут быть как прописными, так и строчными. Восьмеричные числа в настоящее время, похоже,
используются для единственной цели - описания прав доступа к файлам в системах `POSIX`, зато шестнадцатеричные числа
широко используются для того, чтобы подчеркнуть, что используется не числовое значение, а битовый шаблон.

При выводе чисел с использованием пакета `fmt` мы можем управлять системой счисления и форматом вывода с помощью
символов преобразования `%d, %o, %x`:

``` go
o := 0666
fmt.Printf("%d %[1]o %#[1]o\n", o) // "438 666 0666"
x := int64(0xdeadbeef)
fmt.Printf("%d %[1]x %#[1]x %#[1]X\n", x) // 3735928559 deadbeef 0xdeadbeef 0XDEADBEEF
```

Использование двух трюков `fmt`. Обычно, форматная строка `Printf` содержит несколько символов преобразования `%`,
которые требуют того же количества дополнительных аргументов, но `[1]` после `%` говорит функции `Printf` о том, что ей
следует использовать **_первый операнд_** (`o` и `x` в примере в `Printf`) снова и снова. Во-вторых, наличие `#` при
символах преобразования `%o, %x, %X`
говорит функции `Printf` о том, что при выводе должен быть добавлен префикс, указывающий систему
счисления - `0, 0x или 0X`.

Литералы записываются как символ в одинарных кавычках. Простейший пример с использованием `ASCII-символва` - `a`, но так
можно записать любой символ `unicode` - либо непосредственно, либо с помощью числовых управляющих последовательностей.

Руны выводятся с помощью символов преобразования `%c` или `%q` - если требуются кавычки:

``` go
ascii := 'a'
unicode := '★'
newline := '\n'
fmt.Printf("%d %[1]c %[1]q\n", ascii) // "97 a 'a'"
fmt.Printf("%d %[1]c %[1]q\n", unicode) // "9733 ★ '★'"
fmt.Printf("%d %[1]q\n", newline) // "10 '\n'"
```
