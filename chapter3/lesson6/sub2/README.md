# 3.6.2 Нетипизированные константы

Константы в Go немного необычны. Хотя константа может иметь любой фундаментальный тип данных, такой как `int`
или `float64`, включая именованные фундаментальные типы, такие как `time.Duration`, многие константы не привязаны к
определенному типу.

Компилятор представляет эти не привязанные к типу константы с гораздо большей числовой точностью, чем значения
фундаментальных типов, а их арифметика является более точной, чем машинная (можно предположить по крайней мере
256-битную точность).

Имеется шесть вариантов таких несвязанных констант, именуемых:

* нетипизированным булевым значением,
* нетипизированным целым числом,
* нетипизированной руной,
* нетипизированным числом с плавающей точкой,
* нетипизированным комплексным числом,
* нетипизированной строкой

Откладывая привязку к типу, нетипизированные константы могут не только с**охранить высокую точность значений до более
позднего момента**, но и участвовать в гораздо большем количестве выражений **без необходимости преобразования**, чем
связанные константы.
Например, значения `ZiB` и `YiB` в приведенном примере (см. ex3.13.go) слишком велики, чтобы хранить их в любой
переменной целочисленного типа, но они являются корректными константами, которые могут быть использованы в выражениях
наподобие следующего:

``` go
fmt.Println(YiB/ZiB) // 1024
```

В качестве еще одного примера константа с плавающей точкой `math.Pi` может использоваться везде, где требуется значение
с плавающей точкой или комплексное значение:

``` go
var x float32 = math.Pi
var y float64 = math.Pi
var z complex128 = math.Pi
```

Если `math.Pi` будет связан с конкретным типом, таким как `float64`, результат будет не таким точным и будет требоваться
преобразование типа при использовании там, где нужно значение типа `float32` или `complex128`:

``` go
const Pi64 float64 = math.Pi

var x float32 = float32(Pi64)
var y float64 = Pi64
var z complex128 = complex128(Pi64)
```

В случае литералов вариант нетипизированной константы определяется синтаксисом. Литералы `0, 0.0, 0i, '\u0000'`
обозначают константы с одинаковыми значениями, но это разные варианты констант:

* нетипизированное целое значение
* нетипизированное число с плавающей точкой
* нетипизированное комплексное число
* нетипизированная руна, соответственно

Аналогично `true` и `false` представляют собой нетипизированные булевы значения, а строковые литералы являются
нетипизированными строками.

Оператор `/` может представлять в зависимости от операндов как целочисленное деление, так и деление с плавающей точкой.
Следовательно, выбор литерала может повлиять на результат выражения константного деления:

``` go 
var f float64 = 212
fmt.Println((f-32)*5/9) // "100"; (f-32)*5 - float64, 9 - int. Результат 100 - float64
fmt.Println(5/9*(f-32)) // "0"; 5/9 - нетипизированное целое (0). 0*(f-32) (int*float64) = 0 (int) || (f-32)*0 (float64*int) = 0 (float64)
fmt.Println(5.0/9.0*(f-32)) // "100" 5.0/9.0 - нетипизированное значение с плавающей точкой
```

Нетипизированными могут быть только константы. Когда нетипизированная константа находится в правой части объявления
переменной с явным указанием типа, как в первой инструкции приведенного ниже кода, или присваивается переменной, как в
следующих трех инструкциях, константа неявно преобразуется в тип этой переменной, если такое преобразование возможно:

``` go
var f float64 = 3 + 0i // Нетипизированное комплексное -> float64
f = 2  // Нетипизированное целое -> float64
f = 1e123 // Нетипизированное действительное -> float64
f = 'a' // Нетипизированная руна -> float64
```

Таким образом, приведенные выше инструкции эквивалентны:

``` go
var f float64 = float64(3 + 0i)
f = float64(2)
f = float64(1e123)
f = float64('a')
```

Явное или неявное, преобразование константы из одного типа в другой требует, чтобы целевой тип мог представлять исходное
значение. Округление допускается для действительных и комплексных чисел с плавающей точкой.

``` go
consts )
    deadbeef = 0xdeadbeef // Нетипизированный int = 3735928559
    a = uint32(deadbeef) // uint32 = 3735928559
    b = float32(deadbeef) // float32 = 3735928576 (округление)
    c = float64(deadbeef) // float64 = 3735928559 (точное)
    d = int32(deadbeef) // Ошибка: переполнение int
    e = float64(1e309) // Ошибка: переполнение float64
    f = uint(-1) // Ошибка: не представляет uint
)
```

В объявлении переменной без явно указанного типа (включая краткие объявления переменных) версия нетипизированной
константы неявно определяет тип переменной по умолчанию, как в примере ниже:

``` go
i := 0 // Нетипизированное целое. Неявное int(0)
r := '\000' // Нетипизированная руна. Неявная rune('\000')
f := 0.0 // Нетипизированное действительное. Неявное float64(0.0)
c := 0i // Нетипизированное комплексное. Неявное complex128(0i)
```

Тут нужно обратить внимание на **асимметрию**: нетипизированные целые значения преобразуются в тип `int`, размер
которого не гарантируется, но нетипизированные значения с плавающей точкой и комплексные значения преобразуются в типы
с явно указанным размером `float64`, `complex128`.
Язык не имеет "безразмерных" типов `float` и `complex`, аналогичных типу `int`, поскольку очень трудно писать корректные
 численные алгоритмы, не зная размер типов данных с плавающей точкой.

Чтобы придать переменной другой тип, необходимо явно преобразовать нетипизированную константу в требуемый тип
или указать требуемый тип в объявлении переменной:

``` go
var i = int8(0)
var i int8 = 0
```

Эти типы по умолчанию особенно важны при преобразовании нетипизированной константы в значение интерфейса, так как они
определяют его динамический тип.

``` go
fmt.Printf("%T\n", 0) // "int"
fmt.Printf("%T\n", 0.0) // "float64"
fmt.Printf("%T\n", 0i) // "complex128"
fmt.Printf("%T\n", '\000') // "int32 (rune)"
```

