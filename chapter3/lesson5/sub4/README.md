# 3.5.4 Строки и байтовые срезы

Пакет `strings` предоставляет множество функций для поиска, замены, сравнения, обрезки, разделения и объединения строк.

Пакет `bytes` содержит аналогичные функции для работы со срезами байтов `[]byte`, который имеет некоторые свойства,
общие со свойствами строк.
Так как строки неизменяемы (immutable), инкрементное построение строк может включать огромное количество выделений
памяти и копирований. В таких случаях более эффективным является использование типа `byte.Buffer`.

Пакет `strconv` предоставляет функции для преобразования булевых, целочисленных значений и чисел с плавающей точкой в
строковое представление и обратно.

Функции для классификации рун, такие как `IsDigit, IsLetter, IsUpper, IsLower` можно найти в пакете `unicode`.
Каждая из этих функций получает в качестве аргумента отдельную руну и возвращает булево значение. Функции преобразования
наподобие `ToUpper, ToLower` преобразуют руну в руну с указанным регистром, если эта руна является буквой.

Все эти функции используют категории стандарта `Unicode` для букв, цифр и т.д.

В пакете `strings` имеются подобные функции, также именуемые `ToLower, ToUpper`, которые возвращают новые строки с
указанными преобразованиями, примененными к каждому символу исходной строки.

Код ниже аналог `basename` из `Unix`-систем.

``` go
fmt.Println(basename("a/b/c.go")) // "c"
fmt.Println(basename("c.d.go"))  // "c.d"
fmt.Println(basename("abc")) // "abc"
```

Пакеты `path` и `path/filepath` предоставляют более общий набор функций для работы с иерархическими именами.
Пакет `path` работает с путями с косой чертой в качестве разделителя на любой платформе. Он не должен использоваться для
имен файлов, но подходит для других вещей, таких как компоненты пути в `URL`.
Пакет `path/filepath`, напротив, используя правила конкретной платформы, работает с именами файлов, такими как `foo/bar`
для `POSIX` или `c:\foo\bar` в Microsoft Windows.

> comma.go

Аргументом функции `comma` является строка. Если ее длина меньше или равна 3, запятая не нужна. Иначе, `comma`
рекурсивно вызывает саму себя с подстрокой, состоящей из всех символов, кроме трех последних, и прибавляет к результату
рекурсивного вызова запятую и эти последние три символа.

Строка содержит массив байтов, который будучи созданным, является неизменяемым. Элементы байтового среза, напротив,
можно свободно модифицировать.

Строки можно преобразовывать в байтовые срезы и обратно:

``` go
s := "abc"
b := []byte(s)
s2 := string(b)
```

Концептуально преобразование `[]byte(s)` выделяет память для нового массива байтов, хранящего копию байтов строки `s` и
дает срез, ссылающийся на весь этот массив. Оптимизирующий компилятор в некоторых случаях может избежать выделения
памяти и копирования, но в общем случае копирование необходимо для того, чтобы байты строки `s` оставались неизменными,
даже если байты массива `b` будут модифицированы. Преобразование из байтового среза в строку с помощью `string(s)` так
же создает копию, чтобы гарантировать неизменяемость результирующей строки `s2`.

Чтобы избежать преобразований и излишних выделений памяти, многие вспомогательные функции в пакете `bytes` являются
двойниками функции из пакета `strings`. Например, вот несколько функций из пакета `strings` и `bytes`:

| пакет strings                              | пакет bytes                                |
|--------------------------------------------|--------------------------------------------|
| `func Contains(s, substr string) bool`     | `func Contains (b, subslice []byte) bool`  |
| `func Count(s, sep string) int`            | `func Count(s, sep []byte) int`            |
| `func Fields(s string) []string`           | `func Fields(s []byte) [][]byte`           |
| `func HasPrefix(s, prefix string) bool`    | `func HasPrefix(s, prefix []byte) bool`    |
| `func Index(s, sep string) int`            | `func Index(s, sep []byte) int`            |
| `func Join(a []string, sep string) string` | `func Join(s [][]byte, sep []byte) []byte` |

Единственным различием является то, что строки в них заменены срезами байтов.

Пакет `bytes` предоставляет тип `Buffer` для эффективной работы со срезами байтов. Изначально `Buffer` пуст, но растет
по мере того, как в него записываются данные типов наподобие `string, byte или []byte`. Переменная `bytes.Buffer` не
требует инициализации, поскольку нулевое значение данного типа вполне используемо (см. printints.go)

Когда к `bytes.Buffer` добавляется произвольная руна в кодировке `UTF-8`, лучше использовать его метод `WriteRune`.
Метод `WriteByte` хорошо подходит для `ASCII-символов`, таких, как `[` и `]`

## Выводы:

* В пакете `strings` содержатся функции для работы со строками, такие как поиск, замена, сравнение, обрезка, разделение
  и объединение;
* Аналогично пакету `strings`, пакет `bytes` предоставляет функции для работы с байтовыми срезами `[]byte`, что
  позволяет эффективнее использовать память при работе со строками, которые могут быть изменены;
* Пакет `strconv` содержит функции для преобразования булевых, целочисленных и чисел с плавающей точкой в строковое
  представление и обратно, что упрощает работу с данными разных типов;
* Функции для классификации рун, такие как `IsDigit`, `IsLetter`, `IsUpper`, `IsLower` находятся в пакете `unicode`, а
  функции преобразования типа `ToUpper`, `ToLower` позволяют изменять регистр рун, если они являются буквами;
* Для работы с иерархическими именами файлов используются пакеты `path` и `path/filepath`, причём пакет `path` работает
  с путями с косой чертой на всех платформах, а пакет `path/filepath` учитывает специфику каждой платформы;
* Строки можно преобразовывать в байтовые срезы и обратно, однако стоит учесть, что такое преобразование может привести
  к выделению памяти для нового массива байтов и копированию данных;
* В пакете `bytes` имеются функции-двойники функций из пакета `strings`, которые работают с байтовыми срезами, что
  позволяет избежать излишних преобразований и выделений памяти;
* Пакет `bytes` предоставляет тип `Buffer` для эффективной работы со срезами байтов, который растет по мере записи
  данных и не требует инициализации, что повышает удобство использования;
* Если нужно работать только со строками, то лучше использовать `strings.Builder`. Если нужно работать с
  байтами или сочетать работу со строками и байтами, то лучше использовать `bytes.Buffer`.