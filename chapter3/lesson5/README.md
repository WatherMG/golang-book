# 3.5 Строки

Строка представляет собой **_неизменяемую_** последовательность байтов. Могут содержать произвольные данные, в том числе
байты со значением `0`, но обычно они содержат удобочитаемый для человека текст.
Текстовые строки интерпретируются как последовательности символов `Unicode` в кодировке `UTF-8`.

Встроенная функция `len` возвращает количество байтов (**_не символов!_**) в строке, а операция **_индексирования_**
`s[i]` возвращает `i-й` байт строки `s`, где `0 <= i <= len(s)`:

``` go
s := "hello, world"
fmt.Println(len(s)) // "12"
fmt.Println(s[0], s[7])) // "104 119" ('h' and 'w')
```

Попытка обращения к байту вне этого диапазона приводит к панике (panic):

``` go
c := s[len(s)] // panic: индекс вне диапазона
```

`i-й` байт строки необязательно является `i-м символом` строки, поскольку кодировка `UTF-8` символов, не являющихся
символами `ASCII`, требует двух или более байтов.

Операция получения подстроки `s[i:j]` дает новую строку, состоящую из байтов исходной строки, начиная с индекса `i` и до
(но не включая) байта с индексом `j`. Результирующая строка содержит `j-i` байтов.

`fmt.Println(s[0:5] // "hello"`

При выходе индексов за пределы строки или если `j` меньше `i` возникает паника (panic).

Каждый из операндов `i` и `j` может быть опущен, и в этом случае используются значения по умолчанию - `0` (начало
строки) и `len(s)` (ее конец):

``` go
fmt.Println(s[:5]) // "hello"
fmt.Println(s[7:]) // "world"
fmt.Println(s[:]) // "hello world"
```

Оператор `+` создает новую строку путем конкатенации двух строк:

``` go
fmt.Println("goodbye" + s[5:]) // "goodbye, world"
```

Строки можно сравнивать с помощью операторов сравнения наподобие `==`, `<`. Сравнение выполняется байт за байтом,
поэтому оно происходит в естественном лексикографическом порядке.

Строковые значения являются неизменяемыми (имутабельные\immutable): последовательность байтов, содержащихся в строковом
значении, не может быть изменена, хотя, конечно же, можно присвоить строковой переменной новое значение. Например, для
добавления одной строки к другой можно написать:

``` go
s := "левая нога"
t := s
s += ", правая нога"
```

Этот код не изменяет строку, изначально хранившуюся в `s`, но приводит к тому, что в `s` теперь хранится новая строка,
образованная инструкцией `+=`. В то же время в `t` хранится старая строка.

``` go
fmt.Println(s) // "левая нога, правая нога"
fmt.Println(t) // "левая нога"
```

Так как строки - неизменяемые (immutable), конструкции, которые пытаются изменить данные строки не допускаются:

``` go
s[0] = 'L' // Ошибка компиляции: нельзя присваивать s[0]
```

Неизменяемость (immutable) означает, что две копии строки могут вполне безопасно разделять одну и ту же память, что
делает копирование строки любой длины очень дешевой операцией. Аналогично строка `s` и подстроки, такие как `s[7:]`,
могут безопасно разделять одни и те же данные, поэтому операция получения подстроки также очень дешевая. В обоих случаях
не выделяется никакая новая память. На рисунке показано расположение строки и двух ее подстрок, использующих один и тот
же массив байтов.
![img.png](img.png)