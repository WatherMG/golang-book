# 3. Фундаментальные типы данных

В конечном счете вся память представляет собой биты. Go предлагает ряд способов организации данных с широким спектром
типов данных, на одном конце которого находятся типы, соответствующие возможностям аппаратного обеспечения, а на
другом - все, что нужно для того, чтобы программистам было удобно представлять сложные структуры данных.

Типы Go делятся на 4 категории:

* **Фундаментальные типы** - включают числа, строки и булевы значения;
* **Составные типы** - массивы и структуры - образуют более сложные типы данных путем объединения более простых.
* **Ссылочные типы** - разнородная группа, которая включает указатели, срезы, мапы, функции и каналы - общим у них
  является
  то, что все они обращаются к переменным или состояниям программы **_косвенно_**. Так что результат действия операции,
  примененной к одной ссылке, наблюдается всеми ее копиями.
* **Интерфейсы**.

# Выводы к главе:

<!-- TOC -->

* [3.1. Целые числа](#31-целые-числа)
* [3.2. Числа с плавающей точкой](#32-числа-с-плавающей-точкой)
* [3.3. Комплексные числа](#33-комплексные-числа)
* [3.4. Булевы значения](#34-булевы-значения)
* [3.5. Строки](#35-строки)
	* [3.5.1 Строковые литералы](#351-строковые-литералы)
	* [3.5.2 Unicode](#352-unicode)
	* [3.5.3 UTF-8](#353-utf-8)
	* [3.5.4 Строки и байтовые срезы](#354-строки-и-байтовые-срезы)
	* [3.5.5 Преобразования между строками и числами](#355-преобразования-между-строками-и-числами)
* [3.6. Константы](#36-константы)
	* [3.6.1 Генератор констант iota](#361-генератор-констант-iota)
	* [3.6.2 Нетипизированные константы](#362-нетипизированные-константы)

<!-- TOC -->
____

## 3.1. Целые числа

* Числовые типы данных в Go включают целые числа разных размеров, числа с плавающей точкой и комплексные числа, что
  позволяет использовать их для разнообразных задач и операций;
* Go предоставляет `знаковые` и `беззнаковые` целочисленные арифметические типы (int8, uint8, int16, uint16, int32,
  uint32, int64, uint64), что позволяет экономить память и оптимизировать работу программы;
* типы `int` и `uint` имеют естественный или наиболее эффективный размер для знаковых и беззнаковых целых чисел на
  `конкретной платформе`, что облегчает написание кода, не требуя указания размера;
* `rune` и `byte` являются синонимами для `int32` и `uint8` соответственно, и используются для работы с
  символами `Unicode` и фрагментами неформатированных данных;
* `uintptr` - беззнаковый целочисленный тип, используется для низкоуровневого программирования, например, при работе с
  библиотеками на C;
* Для явного преобразования типов при наложении значений разных типов требуется использовать преобразование
  типов `T(x)`;
* Знаковые целые числа используют формат дополнения до `2` (`знак: 1:"-", 0:"+"`), беззнаковые числа хранят только
  неотрицательные значения, что нужно учитывать при выполнении операций и выбора диапазона значений;
* Бинарные операторы Go включают арифметические, логические и операторы сравнения, они имеют различные приоритеты, что
  может потребовать использования скобок для ясности или корректного выполнения операций;
* Арифметические операторы `+, -, *, /` могут применяться ко всем числовым типам данных в Go, оператор получения
  остатка `%` работает только с целыми числами;
* Поведение оператора деления `/` зависит от того, являются ли его операнды целыми числами или числами с плавающей
  точкой. Если хотя бы один из операндов является числом с плавающей точкой - результат будет числом с плавающей точкой.
  Если оба целочисленные - остаток будет отброшен;
* В случае `переполнения (overflow) типа` результат арифметической операции может быть некорректным, старшие биты,
  которые не помещаются в результате, сбрасываются без предупреждения;
* В Go для работы с целыми числами можно использовать знаковую и беззнаковую арифметику, что позволяет выбирать
  подходящий тип данных в зависимости от задачи;
* Старший бит определяет знак числа, младшие биты определяют само число, что позволяет точно представлять положительные
  и отрицательные числа;
* Целые числа и числа с плавающей точкой в Go являются сравниваемыми и упорядочиваемыми, что облегчает работу с ними;
* Унарные операторы `+` и `-` применяются для упрощения работы с целыми числами и числами с плавающей точкой;
* Битовые операции позволяют работать с числами на уровне битов, что может быть полезным для определенных задач, таких
  как анализ форматов бинарных файлов или для хеширования и криптографии;
* Важно использовать беззнаковую арифметику при работе с битовыми шаблонами для корректной работы сдвигов влево и
  вправо;
* Хотя иногда использование беззнаковых чисел кажется более логичным, в Go часто используют знаковые числа, так как они
  предотвращают ошибки, которые могут возникнуть из-за особенностей беззнаковой арифметики;
* Беззнаковые числа наиболее подходят для решения специализированных задач, где требуется побитовая или нестандартная
  арифметическая обработка данных;
* В Go для преобразования значения из одного типа в другой требуется явное преобразование типа, это облегчает понимание
  программ и устраняет целый класс проблем (например, при неявном преобразовании `float64` в `int`, будет теряться
  дробная часть);
* Для преобразования типа используют операцию `T(x)`, где `T` - тип, а `x` - значение для преобразования;
* Многие преобразования из целого значения в целое не влекут за собой изменений значения, однако преобразование,
  сужающее целое число или преобразование целого числа в число с плавающей точкой и обратно, может изменить значение или
  привести
  к потере точности;
* При преобразовании значения с плавающей точкой в целое число дробная часть отбрасывается, к усечению по направлению к
  нулю;
* Следует избегать преобразований, в которых операнд находится вне диапазона целевого типа, так как это может привести к
  нежелательным результатам;
* Целочисленные литералы могут быть записаны в разных системах счисления: десятичная, восьмеричная (начинается с `0`) и
  шестнадцатеричная (начинается с `0x` или `0X`);
* Для вывода чисел с использованием пакета `fmt` можно управлять системой счисления и форматом вывода с помощью символов
  преобразования `%d`, `%o`, `%x` и других;
* Литералы рун записываются как символ в одинарных кавычках, это могут быть символы `ASCII`, `Unicode` или управляющие
  последовательности;
* Руны выводятся с помощью символов преобразования `%c` или `%q` в пакете `fmt` для вывода соответствующего символа или
  символа в кавычках.

____

## 3.2. Числа с плавающей точкой

* В Go существует 2 варианта чисел с плавающей точкой: `float32` и `float64`, их арифметические свойства регулируются
  стандартом `IEEE 754`;
* Значения числовых типов с плавающей точкой находятся в диапазоне от очень малых до очень больших и имеют предельные
  значения, которые можно найти в пакете `math`;
* `float32` обеспечивает приблизительно `6` десятичных цифр точности, тип `float64` - около `15` цифр. Рекомендуется
  использовать `float64`, так как при использовании типа `float32` быстро накапливается ошибка (потеря точности);
* Числа с плавающей точкой могут быть записаны буквально с использованием десятичной записи (`.90000001`,`1.`), а для
  очень малых и очень больших чисел лучше использовать научный формат записи (с буквой `e` или `E`);
* Для вывода значений с плавающей точкой удобно использовать символ преобразования `%g` функции `Printf`. Также можно
  использовать символы преобразования `%e` (с показателем степени) или `%f` (без показателя степени);
* Стандарт `IEEE 754` определяет специальные значения, такие как положительная и отрицательная бесконечность, а также
  значение `NaN (not a number)`. Они могут быть получены при некоторых вычислениях, и с ними можно работать с помощью
  функций пакета `math`;
* Если в результате вычислений с плавающей точкой может возникнуть ошибка, лучше сообщать об этом отдельным возвращаемым
  значением в функции.

____

## 3.3. Комплексные числа

* Go имеет поддержку комплексных чисел с двумя размерами - `complex64` и `complex128`, основанными на `float32`
  и `float64` соответственно;
* Встроенные функции `complex`, `real` и `imag` позволяют создавать комплексные числа и извлекать их действительную и
  мнимую части;
* Мнимые литералы, например `3.141592i` или `2i`, обозначают комплексное число с нулевым действительным компонентом;
* Комплексные числа можно сравнивать на равенство с помощью операторов `==` и  `!=`;
* Пакет `math/cmplx` предоставляет функции для работы с комплексными числами, такие как квадратный корень или возведение
  в степень;
* Арифметика `complex128` может быть использована для генерации множества Мандельброта, что позволяет создавать
  визуализации математических объектов.

____

## 3.4. Булевы значения

* Булев тип `bool` имеет только два возможных значения: `true` и `false`, используются для управления условными
  конструкциями и сравнениями;
* Унарный оператор `!` используется для логического отрицания: `!true` будет равно `false`;
* Чтобы упростить излишние булевы выражения, рекомендуется использовать `x` вместо `x == true`;
* Операторы `&& (И)` и `|| (ИЛИ)` используются для объединения булевых значений, при этом применяется сокращенное
  вычисление: правый операнд не вычисляется, если ответ определяется значением левого операнда;
* Булевы значения не преобразуются неявно в числовые значения или обратно, для этого нужно использовать явные инструкции
  или функции преобразования (в Go нет встроенных, придется писать самому, например):
	* ``` go
    func Btoi(b bool) int {
      if b {
        return 1
      }
      return 0
    }
    
    func Itob(i int) bool {
	     b := i != 0
	     return b
    }
    ```
* Использование булевых операторов и выражений позволяет создавать логические условия для управления потоком выполнения
  программы и обработки различных ситуаций.

____

## 3.5. Строки

* Строки в Go являются `неизменяемыми последовательностями байтов` и обычно содержат текстовые символы `Unicode`,
  закодированные в `UTF-8`;
* Для получения `длины строки в байтах` используется встроенная функция `len`, и нужно помнить, что она возвращает
  количество байтов, а не символов;
* Индексирование строк в Go происходит по байтам, а не по символам, и обращение к байту с помощью операции `s[i]`, где
  `0 <= i <= len(s)` позволяет получить `i-й` байт строки;
* Необходимо избегать индексации за пределами строки, так как это приведет к панике `(panic)`;
* Чтобы получить подстроку из строки можно использовать операцию среза `s[i:j]`, где `i` и `j` указывают на начальный и
  конечный `(не включительно)` индексы байтов;
* Конкатенация строк происходит с помощью оператора `+`, что позволяет склеивать строки, создавая новую строку;
* При конкатенации, создается новый объект строки в памяти, содержащий объединение исходных строк. Исходные строки
  остаются неизменными и удаляются из памяти только при выполнении сборки мусора. рекомендуется использовать другие
  методы работы со строками, которые не требуют создания новых объектов в памяти, например, метод `Join`;
* Сравнение строк возможно с использованием операторов `==`, `<`, что делает их удобными для работы в условиях и циклах;
* Из-за `неизменяемости` строк в Go, нельзя изменять значения их байтов напрямую, при этом копирование строк и получение
  подстрок требуют минимальных затрат по памяти, так как они могут разделять одни и те же данные;
* Например, при `копировании` строки в новую переменную, никакие `данные не копируются`, а лишь `создается новая ссылка`
  на уже существующий кусок памяти со строкой. Таким образом, копирование строк не вызывает дополнительных затрат по
  памяти. То же самое актуально для `получения подстроки`;
* Работа со строками в Go позволяет эффективно оперировать текстовыми данными, избегая частых выделений памяти и
  операций изменения строк.

____

### 3.5.1 Строковые литералы

* Строковые литералы в Go - это последовательность байтов, заключенная в двойные кавычки, позволяют записывать текстовые
  значения, включая символы `Unicode`;
* Управляющие последовательности, начинающиеся с обратной косой черты `'\'`, используются для вставки произвольных
  значений байтов в строке, обрабатывают управляющие коды ASCII и специальные символы;
* Шестнадцатеричные управляющие последовательности записываются как `\xhh` и представляют один байт с указанным
  значением, ровно с двумя шестнадцатеричными цифрами `h` (в верхнем или нижнем регистре);
* Восьмеричные управляющие последовательности записываются как `\ooo` и тоже представляют один байт с указанным
  значением, с ровно тремя восьмеричными цифрами (от 0 до 7), не превышающими значение `\377`;
* Неформатированные строковые литералы (`raw string literal`) используют обратные одинарные кавычки `` и позволяют
  записывать многострочный текст, в котором управляющие последовательности не обрабатываются;
* При использовании неформатированных строковых литералов символы возврата каретки `(\r)` удаляются, чтобы значение
  строки было одинаковым на всех платформах;
* Неформатированные строковые литералы удобно использовать для записи регулярных выражений, шаблонов HTML, литералов
  JSON, сообщений об использовании программы и других текстов, занимающих несколько строк.

____

### 3.5.2 Unicode

* `ASCII` использует `7 бит` для кодирования `128` символов, включая английские буквы, цифры, знаки пунктуации и
  управляющие символы устройств;
* `Unicode` собирает символы всех мировых систем письменности, диакритические знаки, управляющие коды и многое другое
  для обеспечения совместимости между различными языками и алфавитами;
* код символа `Unicode (Unicode code point)` или `руна (rune)` в Go представляет собой стандартный номер, назначенный
  каждому символу;
* для хранения `рун` в Go используется тип данных `int32`, являющийся синонимом типа `rune`;
* последовательность рун может быть представлена в виде последовательности значений `int32`, такое представление
  называется `UTF-32` или `UCS-4`;
* `UTF-32` использует `32 бита на символ`, что обеспечивает универсальность кодирования, но требует больше памяти, чем
  обычно необходимо;
* `UTF-8` обеспечивает оптимальное использование памяти, кодирование только символов `ASCII` в `8 битах` или `1 байте`,
  а более широко используемые символы вписываются в `16 битов` (`W - 1 бит, Ц - 2 бита`).

____

### 3.5.3 UTF-8

* `UTF-8` - это кодировка переменной длины символов `Unicode` в виде байтов, изобретенная Кеном Томпсоном и Робом
  Пайком, является стандартом `Unicode`;
* Руны в `UTF-8` могут использовать `от 1 до 4 байтов`, но символы `ASCII` занимают только `1 байт`, большинство
  распространенных рун используют `2` или `3 байта`;
* `UTF-8` обладает свойством самосинхронизации (можно найти начало символа, просмотрев не более 3 байт) и совместимости
  с `ASCII`, что упрощает работу с текстом;
* Для работы с отдельными рунами в Go можно использовать пакеты `unicode` и `unicode/utf8`, которые предоставляют
  функции для кодирования, декодирования и обработки рун;
* Управляющие последовательности `Unicode` в строковых литералах Go позволяют указывать символы с помощью их числового
  кода: `'\uhhhh'` для 16-разрядных значений и `'\uhhhhhhhh'` для 32-разрядных;
* `UTF-8` позволяет проводить некоторые строковые операции без декодирования, например, проверить является ли одна
  строка префиксом, суффиксом или содержит ли подстроку другой строки;
* Если необходимо работать с отдельными символами `Unicode`, нужно использовать другие механизмы, такие как функция
  `utf8.RuneCountInString()` для определения количества рун в строке;
* Для работы с символами `Unicode` в Go необходимо декодирование `UTF-8`, для этого можно использовать
  пакет `unicode/utf8`;
* При декодировании с помощью функции `utf8.DecodeRuneInString()` возвращается руна и количество байтов, занятых её
  кодом `UTF-8`;
* Цикл по диапазону Go, применённый к строке, выполняет декодирование `UTF-8` неявно (каждый элемент строки,
  рассматривается как `rune`);
* Чтобы посчитать количество рун в строке, можно использовать простой цикл `range` или
  функцию `utf8.RuneCountInString(s)`;
* Тексты строк в Go интерпретируются как последовательности символов `Unicode` в кодировке `UTF-8`, это необходимо для
  правильного использования циклов по диапазону;
* Если в строке содержатся ошибки кодировки, то при декодировании генерируется специальный замещающий символ Unicode  
  `'\uFFFD'`;
* Преобразование `[]rune` примененное к строке с кодировкой `UTF-8` возвращает последовательность символов `Unicode`,
  закодированных в этой строке;
* Преобразование целочисленного значения в строку рассматривает это число как значение руны и даёт её представление в
  кодировке UTF-8;
* Если руна некорректна, вместо неё подставляется замещающий символ `�`.

____

### 3.5.4 Строки и байтовые срезы

* В пакете `strings` содержатся функции для работы со строками, такие как поиск, замена, сравнение, обрезка, разделение
  и объединение;
* Аналогично пакету `strings`, пакет `bytes` предоставляет функции для работы с байтовыми срезами `[]byte`, что
  позволяет эффективнее использовать память при работе со строками, которые могут быть изменены;
* Пакет `strconv` содержит функции для преобразования булевых, целочисленных и чисел с плавающей точкой в строковое
  представление и обратно, что упрощает работу с данными разных типов;
* Функции для классификации рун, такие как `IsDigit`, `IsLetter`, `IsUpper`, `IsLower` находятся в пакете `unicode`, а
  функции преобразования типа `ToUpper`, `ToLower` позволяют изменять регистр рун, если они являются буквами;
* Для работы с иерархическими именами файлов используются пакеты `path` и `path/filepath`, причём пакет `path` работает
  с путями с косой чертой на всех платформах, а пакет `path/filepath` учитывает специфику каждой платформы;
* Строки можно преобразовывать в байтовые срезы и обратно, однако стоит учесть, что такое преобразование может привести
  к выделению памяти для нового массива байтов и копированию данных;
* В пакете `bytes` имеются функции-двойники функций из пакета `strings`, которые работают с байтовыми срезами, что
  позволяет избежать излишних преобразований и выделений памяти;
* Пакет `bytes` предоставляет тип `Buffer` для эффективной работы со срезами байтов, который растет по мере записи
  данных и не требует инициализации, что повышает удобство использования;
* Если нужно работать только со строками, то лучше использовать `strings.Builder`. Если нужно работать с
  байтами или сочетать работу со строками и байтами, то лучше использовать `bytes.Buffer`.

____

### 3.5.5 Преобразования между строками и числами

* Для преобразования между строками и числами в Go используется пакет `strconv`;
* Чтобы преобразовать целое число в строку, можно использовать функцию `fmt.Sprintf` или функцию `strconv.Itoa`, что
  позволит получить строковое представление числа;
* Для форматирования чисел в другие системы счисления применяются функции `strconv.FormatInt` и `strconv.FormatUint`,
  что облегчает работу с числами в разных форматах;
* Функции `fmt.Printf` с символами преобразования, такими как `%b`, `%d`, `%o`, `%x`, удобны при добавлении информации к
  числам в строковом представлении;
* Чтобы преобразовать строку в целое число, можно использовать функции `strconv.Atoi` и `strconv.ParseInt`, что
  обеспечивает
  гибкость для работы с числами разных размеров;
* Функция `fmt.Scanf` может быть использована для анализа входной информации, состоящей из комбинации строк и чисел, но
  может быть негибкой при обработке неполного или неправильного ввода.

____

## 3.6. Константы

* Константы в Go - это выражения с известными значениями `на этапе компиляции`, что позволяет компилятору выполнять
  оптимизации и уменьшать нагрузку на выполнение программы;
* Объявление констант начинается с ключевого слова `const`, их значения могут быть строками, числами и логическими
  значениями;
* Инициализация константы может быть `опущена`, в таком случае будут использованы значения и тип предыдущей константы;
* Константы обеспечивают защиту от случайного или ошибочного `изменения значения во время выполнения программы`, что
  повышает надежность кода;
* Константные выражения могут использоваться в качестве значений длины массива и других типах данных, что облегчает
  работу с этими типами данных;
* Использование констант позволяет компилятору обнаруживать ошибки, обычно идентифицируемые во время выполнения
  программы, уже на стадии компиляции;
* `iota` - это `генератор последовательных констант` в Go. При объявлении группы констант с использованием `iota`, его
  значение начинается с `0` и увеличивается на `1` для каждой последующей константы. Это позволяет удобно создавать
  группы
  констант с последовательными значениями, при этом значением каждой константы можно управлять независимо. Также можно
  использовать `iota` для создания констант с увеличивающимися значениями в определенную арифметическую прогрессию:
	* ``` go
    var Flags uint
    const (
	     FlagUp Flags = 1 << iota // 1
	     FlagBroadcast            // 2
	     FlagLoopback             // 4
	     FlagPointToPoint         // 8
	     FlagMulticast            // 16
    )
    ```

____

### 3.6.1 Генератор констант iota

* Генератор констант `iota` в Go используется для создания последовательности связанных значений без явного указания их,
  начиная с нуля и увеличиваясь на единицу для каждого элемента;
* Iota может использоваться для объявления имен для степеней значения 1024, позволяя оперировать с КиБ, МиБ, ГиБ и
  дальше;
* Однако механизм `iota` имеет свои пределы, например, невозможно генерировать степени 1000 (КБ, МБ и т.д.), так как
  отсутствует оператор возведения в степень.

____

### 3.6.2 Нетипизированные константы

* `Константы` в Go могут иметь любой фундаментальный тип данных, но многие из них не привязаны к определенному типу, что
  позволяет сохранить высокую точность значений и участвовать в большем количестве выражений без необходимости
  преобразования;
* В Go существует шесть вариантов нетипизированных констант: нетипизированное булево значение, нетипизированное целое
  число, нетипизированная руна, нетипизированное число с плавающей точкой, нетипизированное комплексное число,
  нетипизированная строка;
* Нетипизированная константа в языке программирования Go - это значение, которое не имеет явного типа, но может быть
  автоматически преобразовано в любой тип данных;
* Нетипизированные константы могут преобразовываться в определенный тип при назначении переменной с явным указанием типа
  или при использовании в выражениях, что обеспечивает большую гибкость и точность;
* В случае литералов, вариант нетипизированной константы определяется синтаксисом: литералы `0`, `0.0`, `0i`, `'\u0000'`
  обозначают различные варианты констант, такие как нетипизированное целое значение, нетипизированное число с плавающей
  точкой, нетипизированное комплексное число и нетипизированная руна;
* Оператор `/` может представлять как целочисленное деление, так и деление с плавающей точкой в зависимости от
  операндов, поэтому выбор литерала может повлиять на результат выражения константного деления;
* Нетипизированными могут быть только константы, и их преобразование в другой тип, явное или неявное, требует, чтобы
  целевой тип мог представлять исходное значение, при этом допускается округление для действительных и комплексных чисел
  с плавающей точкой;
* Если переменной не указан явный тип, нетипизированная константа определит его неявно, а при преобразовании
  нетипизированной константы в значение интерфейса, ее динамический тип будет определен по умолчанию, что особенно важно
  для работы с типами данных в Go.

____