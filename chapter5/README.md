# 5. Функции

Функция позволяет "завернуть" последовательность операторов в единое целое, которое может вызываться из других мест в
программе, возможно, многократно. Функции позволяют разбить большую работу на более мелкие фрагменты, которые могут быть
написаны разными программистами, разделенными во времени и пространстве. По всем этим причинам функции являются важной
частью любого языка программирования.

Было рассмотрено много функций. Теперь пришло время обсудить их более подробно. Основным примером в этой главе является
поисковый агент, т.е. компонент поисковых систем, ответственный за извлечение веб-страниц, выявление ссылок внутри них,
извлечение веб-страниц по этим ссылкам и т.д. Поисковый агент обеспечивает широкие возможности для изучения рекурсии,
анонимных функций, обработки ошибок и прочих аспектов функций, уникальных для Go.

# Выводы к главе:

<!-- TOC -->

* [5.1. Объявления функций](#51-объявления-функций)
* [5.2. Рекурсия](#52-рекурсия)
* [5.3. Множественные возвращаемые значения](#53-множественные-возвращаемые-значения)
* [5.4. Ошибки](#54-ошибки)
	* [5.4.1 Стратегии обработки ошибок](#541-стратегии-обработки-ошибок)
	* [5.4.2 Конец файла (EOF)](#542-конец-файла-eof)
* [5.5. Значения-функции](#55-значения-функции)
* [5.6. Анонимные функции](#56-анонимные-функции)
	* [5.6.1 Предупреждение о захвате переменных итераций](#561-предупреждение-о-захвате-переменных-итераций)
* [5.7. Вариативные функции](#57-вариативные-функции)
* [5.8. Отложенные вызовы функций](#58-отложенные-вызовы-функций)
* [5.9. Аварийная ситуация](#59-аварийная-ситуация)
* [5.10. Восстановление](#510-восстановление)

<!-- TOC -->
____

## 5.1. Объявления функций

* Функции в Go определяются с помощью ключевого слова `func`, имени функции, списка параметров, списка результатов и
  тела функции;  
  Пример объявления функции с двумя параметрами типа `int` и одним результатом типа `int`:
  ``` go
  func add(x int, y int) int {
    return x + y
  }
  ```
* Список параметров функции содержит имена и типы параметров, которые являются локальными переменными функции и
  инициализируются значениями аргументов, переданными при вызове функции;
* Список результатов функции указывает типы значений, возвращаемых функцией; если функция возвращает одно значение,
  скобки необязательны и опускаются;
* Функции с именованными результатами автоматически инициализирует локальные переменные с соответствующими типами и
  начальными значениями;
  Пример функции с именованным результатом:
  ``` go
  func sum(x int, y int) (result int) {
    result = x + y
    return
  }
  ```
* Аргументы функции `передаются по значению`, поэтому изменения аргументов внутри функции не влияют на исходные значения
  вызывающей стороны; однако, если аргумент содержит `ссылку на объект` (указатель, срез, map, функцию, канал), то
  функция может влиять на его состояние;
* Тип функции определяется `сигнатурой`, состоящей из последовательности типов параметров и результатов; имена
  параметров и результатов не влияют на тип функции;
* В Go `отсутствуют` параметры по умолчанию и передача аргументов по имени, что упрощает вызов функции и делает его
  более предсказуемым;
* Возврат значений из функции осуществляется с помощью оператора `return`; если функция имеет список результатов, она
  должна заканчиваться оператором `return`, если только исполнение явно не может дойти до конца функции (например, из-за
  вызова `panic` или бесконечного цикла без `break`).

____

## 5.2. Рекурсия

* Рекурсия - это возможность функции вызывать саму себя, что является мощным инструментом для решения многих задач.
* В Go рекурсия используется для обработки деревьев, в том числе для сортировки и обработки HTML-документов.
* Пакет golang.org/x/net/html предоставляет синтаксический анализатор HTML для Go и используется для извлечения
  информации
  из HTML-документов.
* Проблему переполнения стека в рекурсии в Go решается использованием стека переменной длины, который позволяет выделять
  дополнительную память по мере необходимости.

____

## 5.3. Множественные возвращаемые значения

* Функции могут возвращать несколько значений, что полезно для возврата результата и информации об ошибке или статуса
  выполнения;  
  Пример: `func Size(rect image.Rectangle) (width, height int)`;
* Сборщик мусора Go освобождает память, но не освобождает ресурсы операционной системы, такие как открытые файлы и
  сетевые подключения. Они должны быть закрыты явным образом, например `file.Close()`, `resp.Body.Close()`;
* Результат вызова функции с несколькими возвращаемыми значениями представляет собой кортеж значений. При вызове такой
  функции необходимо явно присваивать ее значения переменным или использовать `_` для игнорирования ненужных значений;
  Пример: `links, err := findLinks(url)`, `links, _ := findLinks(url)`;
* Результат многозначного вызова может быть использован в качестве аргумента для другой функции с несколькими
  параметрами, что может быть полезно при отладке;
  Пример: `log.Println(findLinks(url))`;
* Нужно использовать осознанные имена для возвращаемых значений, особенно если они одного типа, чтобы облегчить
  понимание функции;
  Пример: `func Split(path string) (dir, file string)`;
* Если последнее возвращаемое значение функции типа `bool`, `по соглашению` оно указывает на успешное или неуспешное
  выполнение функции;
* В функции с именованными результатами можно использовать `пустой возврат (bare return)` - оператор `return` без
  операндов. Это может уменьшить дублирование кода, но иногда усложняет понимание функции;
  Пример:
  ``` go
  func CountWordsAndImages(url string) (words, images int, err error) {
      //...
      if err != nil {
          return
      }
      //...
  }
  ```

____

## 5.4. Ошибки

* Функции, которые возвращают булево значение (`false`, `true`), могут выдать ошибки в случае, например, переполнения
  стека и нехватки памяти. Такие ошибки необходимо обрабатывать, чтобы избежать непредсказуемого поведения программы.
* Обрабатывать ошибки нужно, так как даже в "надежных" программах они могут появиться там, где не ожидаешь. Это связано
  с несколькими факторами, такими как внешние условия, состояние системы и взаимодействие с другими программами.
* Обработка ошибок важна, для предоставления информации о том, что конкретно пошло не так и было проще разобраться с
  возникшей проблемой. Это упрощает поиск и исправление ошибок в коде.
* Когда функция возвращает тип `error`, в нее, обычно, передается информация с последней вызванной функции, которая
  также возвращала тип `error`. Это позволяет отслеживать цепочку ошибок и определять их причины.
* Тип `error` является интерфейсом, что позволяет определять собственные типы ошибок и использовать их в своих
  программах.  
  Пример:
  ``` go
  type MyError struct {
      ErrMsg string
      ErrCode int
  }
  
  func (e *MyError) Error() string {
      return fmt.Sprintf("Error %d: %s", e.ErrCode, e.ErrMsg)
  }
  
  func myFunction() error {
      // ...
      if err != nil {
          return &MyError{ErrMsg: "Something went wrong", ErrCode: 404} // возвращаем экземпляр MyError вместо обычного error
      }
      // ...
      return nil
  }
  ```
* Ошибка может быть нулевой или ненулевой. Нулевая ошибка (`nil`) обозначает успешное завершение функции, а ненулевая
  ошибка содержит информацию о проблеме, которая возникла в процессе выполнения функции.
* В Go используются конструкции `if` и `return` для обработки ошибок вместо исключений. Это обеспечивает более точный
  контроль над обработкой ошибок и предотвращает неопределенное поведение, которое может возникнуть при использовании
  исключений.
* В Go исключения не используются, потому что они могут приводить к неопределенному поведению и усложнять отладку.
  Вместо этого используется механизм возврата ошибок через тип `error`. Это позволяет более точно контролировать
  обработку ошибок и сделать код более понятным и предсказуемым.
* Пример работы с ошибками в Go:
  ``` go 
  func main() { 
    file, err := os.Open("file.txt")
    defer file.Close()
    if err != nil { 
      log.Fatal(err) 
    }
  }
  ```

____

### 5.4.1 Стратегии обработки ошибок

* В случае возникновения ошибки, ее нужно обрабатывать в вызывающей функции;
* Функция `fmt.Errorf` форматирует сообщение об ошибке, используя `fmt.Sprintf`, и возвращает новое значение `error`;
* При обработке ошибок в функции main необходимо строить четкую цепочку ошибок от источника до конечного вызова;
* Сообщение об ошибке должно быть осмысленным и подробным, следует избегать начала строки сообщения с прописных букв и
  символов новой строки;
* Сообщение об ошибке должно быть осмысленным и достаточно подробным (последовательным и согласованным, с другими
  ошибками цепочки\пакета);
* Для ошибок, которые представляют переходящие или непредсказуемые проблемы (проблемы с сетевым соединением, проблемы с
  доступностью внешних сервисов, ошибка доступа к диску), имеет смысл **_повторить_** сбойную операцию, с задержкой и
  ограничениями на количество попыток или время.
* Все функции пакета `log`, по умолчанию добавляет в начало сообщения об ошибке текущее время и дату. Такой формат
  полезен при работе "долгоиграющего" сервера, но менее удобен в интерактивном режиме. Так же, все функции добавляют
  символ новой строки `\n`.
* Все функции пакета `log` добавляют в начало сообщения об ошибке текущее время и дату, для изменения этого поведения
  можно использовать методы `log.SetPrefix` и `log.SetFlags`.
* После проверки ошибки сначала обычно обрабатывается ошибка, а затем - код, который следует выполнить, если ошибок нет.
  Если ошибка приводит к выходу из функции, успешное продолжение работы выполняется не в блоке `else`, а в теле функции.
* Игнорирование ошибок допустимо в случае, если возвращаемое значение ошибки не важно и мы уверены в успешном выполнении
  операции, а также если мы обрабатываем ошибку в другом месте кода или в другой функции. При этом необходимо
  сопроводить игнорирование ошибок комментарием, объясняющим причину игнорирования.

____

### 5.4.2 Конец файла (EOF)

* Пакет `io` гарантирует, что ошибка достижения конца файла всегда будет сообщаться, как об отдельной ошибке `io.EOF`;
* Вызывающая функция может обнаружить условие конца файла с помощью простого сравнения `==`;
* Ошибка `io.EOF` имеет фиксированное сообщение, так как условие конца файла не содержит дополнительной информации.

____

## 5.5. Значения-функции

* Функции - значения первого класса. Они могут быть присвоены переменным или переданы в функцию, а так же возвращены из
  нее;
* Нулевым значением типа функции является `nil`, и вызов такой функции приводит к `panic`;  
  Пример:
  ``` go
  var f func(int) int
    f(3) // panic: вызов nil-функции
  ```
* Значения-функции имеют свой тип;  
  Пример:
  ``` go
  func square(n int) int { return n * n }
    var f func(int) int
    f = square // Допустимо, так как типы функции square и переменной f совпадают
  }
  ```
* Значения-функции можно сравнить с `nil`, но нельзя сравнивать их между собой напрямую, так как каждая функция в Go
  имеет уникальный адрес в памяти;
  Пример:
  ``` go
  var f func(int) int
  if f != nil {
    f(3)
  } // нет ошибки, так как f не вызывается, если она равна nil
  ```
* Значения-функции нельзя использовать в качестве ключей в карте map из-за уникальности их адресов в памяти;
* Значения-функции позволяют параметризовать функции не только данными, но и поведением;
* С помощью значения функции можно разделить логику на модули;
* У `fmt.Printf` есть "трюк", который позволяет добавить переменное количество отступов в строке. С помощью символа `*`
  в `%*s` - принимает два аргумента, первый - переменное количество пробелов (ширина вывода, тип `int`), второй -
  выводимая строка;
* Значения-функции облегчают написание более обобщенных и абстрактных функций, что упрощает их использование и улучшает
  читаемость кода.

____

## 5.6. Анонимные функции

* **_Детерминированность_** - это свойство программного кода, при котором он всегда будет давать одинаковый результат
  при одинаковых входных данных и в одинаковых условиях выполнения. Это означает, что поведение кода предсказуемо и
  можно точно определить результат его выполнения;
* **_Инкапсуляция_** - сокрытие деталей внутренней реализации объекта от других частей программы;
* Функция `append(list, f(item)...)` добавляет все элементы, возвращаемые `f(item)`, в `list`;
* Анонимные функции используются для обозначения значений-функций в выражениях без явного имени и могут быть определены
  внутри других функций (`strings.Map(func(r rune) rune { return r + 1}, "HAL9000")`);
* Можно использовать **литерал функции**, чтобы обозначить **значение-функцию** в любом выражении. Такая запись
  называется **_анонимной функцией_**.
  Пример:
  ``` go
      // Создаем анонимную функцию, которая принимает два числа и возвращает их сумму
      sum := func(a, b int) int {
          return a + b
      }
  
      // Вызываем анонимную функцию и сохраняем результат в переменную
      result := sum(3, 4)
  ```
* Анонимная функция в Go имеет доступ **ко всему лексическому выражению**, включая **переменные** их охватывающей
  функции. Такая функция называется **замыканием**.
  Пример:
  ``` go
  func squares() func() int {
        x := 0
        return func() int {
            x++
            return x * x
        }
    }
  ```
* Анонимные функции могут возвращать другие функции;
* Значения-функции могут иметь **состояние** и **обновлять** локальные переменные охватывающей функции. Поэтому они
  являются **ссылочными типами и не сравниваются**;
* **_Замыкание_** - это комбинация анонимной функции и ее окружения. Замыкание “запоминает” значения переменных из
  своего окружения и может использовать их даже после того, как охватывающая функция завершила свое выполнение;
* Время жизни переменной не определяется ее областью видимости. Область видимости определяет, где переменная может быть
  использована в коде. Время жизни переменной **определяется тем**, когда память для нее **выделена и освобождена**;
* Когда анонимная функция требует рекурсии, сначала нужно объявить переменную и присвоить ей анонимную функцию. Затем
  можно использовать эту переменную внутри анонимной функции для рекурсивного вызова.

____

### 5.6.1 Предупреждение о захвате переменных итераций

* Лексическая область видимости Go может привести к неожиданным результатам при работе с переменными итерации в циклах;
* Все значения-функции (анонимных функций (замыканий)), созданные в цикле, захватывают и совместно используют одну и ту
  же переменную, а именно, адресуемое место в памяти, а не ее значение в конкретный момент. В результате переменная
  может быть обновлена несколько раз и сохранить последнее значение в конце цикла;
* Для решения этой проблемы, создается внутренняя переменная с тем же именем, что и у внешней переменной, копией которой
  она является.
  Пример:
  ``` go
  for _, dir := range tempDirs() {
        dir := dir // Объявление внутренней переменной dir, инициализированной значением внешней переменной dir
        //...
    }
  ```
* Проблема захвата переменной итерации может возникнуть при использовании инструкции `go` или `defer`, поскольку обе
  могут задержать выполнение функции до момента после завершения цикла;
* Проблема не является уникальной для Go и может возникнуть в других языках программирования.

____

## 5.7. Вариативные функции

* Вариативные функции - это функции, которые могут быть вызваны с разным количеством аргументов; это удобно, например,
  для функций форматирования строк, таких как `fmt.Printf` в Go.
  Пример использования вариативной функции:
  ``` go
  func sum(nums ...int) int {
        total := 0
        for _, num := range nums {
            total += num
        }
        return total
    }
    fmt.Println(sum(1, 2, 3, 4)) // 10
  ```
* Чтобы объявить вариативную функцию, перед типом последнего параметра указывается троеточие `...`, которое говорит о
  том, что функция может быть вызвана с любым количеством аргументов данного типа. Это позволяет создавать более гибкие
  и универсальные функции;
* Вызывающая функция, `неявно` выделяет память для массива, копирует в него аргументы и передает в функцию срез,
  который представляет весь массив.
* Чтобы вызвать вариативную функцию с аргументами, уже находящимися в срезе, следует добавить троеточие после последнего
  аргумента. Это удобно для обработки наборов данных, которые уже представлены в виде срезов:
  ``` go
  values := []int{1, 2, 3, 4}
  fmt.Println(sum(values...)) // 10
  ```
* Внутри функции параметр `...int` ведет себя как `срез (slice)`. Однако тип вариативной функции отличается от типа
  функции с параметром типа среза.
  Пример:
  ``` go
  func f(...int) {}
  func g([]int) {}
  fmt.Printf("%T\n", f) // func(...int)
  fmt.Printf("%T\n", g) // func([]int)
  ```
* Вариативные функции часто используются для форматирования строк;
* Тип `interface{}` может быть использован для создания вариативных функций, которые принимают любые значения в качестве
  последних аргументов. Это обеспечивает максимальную гибкость и универсальность функций.

____

## 5.8. Отложенные вызовы функций

* В Go есть механизм отложенного вызова функции или метода `defer`;
* Он используется, чтобы избежать дублирования логики очистки и гарантировать освобождение ресурсов.;
* Функция и выражения аргументов вычисляются при выполнении инструкции, но фактический вызов откладывается до завершения
  функции, причем независимо от того, как она завершается: обычным способом (void), с помощью оператора `return` или в
  результате `panic`;
* Любое количество вызовов может быть отложено, и они выполняются в обратном порядке;
* Инструкция `defer` часто используется с парными операциями: открытие\закрытие, подключение\отключение,
  блокировка\разблокировка - для гарантии освобождения ресурсов во всех случаях;
* Правильное место инструкции `defer`, которая освобождает ресурс - сразу же после того, как ресурс был успешно захвачен
  в случае, если "захват" возвращает ошибку - сразу после `if err != nil`;
* `defer` может использоваться для отладочных записей о входе и выходе из функции;
* Анонимная функция в отложенной функции имеет доступ к переменным охватывающей функции, включая **именованные**
  результаты;
* Отложенные функции выполняются после того, как инструкция возврата обновляет переменные результатов функции, и могут
  изменять их значения;
* Отложенные функции не выполняются до конца выполнения функции, поэтому при работе в цикле может возникнуть проблема.
  Одним из решений может быть перенос тела цикла, включая инструкцию `defer` в другую функцию, которая
  вызывается на каждой итерации;
* При использовании отложенного вызова для закрытия файлов, следует учитывать особенности работы файловых систем и
  предпочитать отчет об ошибке операции чтения/записи файла перед отчетом об ошибке закрытия файла, чтобы более точно
  определить причину возникновения проблем.

____

## 5.9. Аварийная ситуация

* Такие ошибки как, обращение к элементу за границами массива или разыменовывание нулевого указателя требуют проверок в
  `runtime`. Когда среда выполнения Go обнаруживает эти ошибки, возникает `паника` (`panic`);
* Во время паники выполнение программы останавливается, выполняются все отложенные вызовы функций в текущей горутине и
  программа аварийно завершает работу с записью соответствующего сообщения;
* Журнальное сообщение `паники` содержит `значение паники` (обычно это сообщение об ошибке) и `трассировку стека` для
  каждой горутины. Трассировка стека показывает состояние стека вызовов функций, которые были активны во время паники;
* Журнальное сообщение паники содержит много информации о возникшей ошибке, и его следует включать в отчет об ошибке,
  чтобы разработчик мог проанализировать и исправить ошибку;
* Не все `паники` возникают в `runtime`. Встроенная функция `panic` может вызываться в коде, и это не обязательно
  связано с ошибками во время выполнения программы. В этом случае паника также приводит к аварийному завершению
  программы.
* В качестве аргумента `паника` принимает любое значение;
* Не всегда лучшее решение вызывать `panic`, когда происходит "невозможная" ситуация. В некоторых случаях более
  целесообразно использовать другие механизмы обработки ошибок, например, возвращать ошибку или использовать специальный
  тип, который позволяет обрабатывать ошибки;
* Если нельзя предоставить более информативное сообщение или обнаружить ошибку заранее, нет смысла в проверке, например,
  значения на `nil` и вызове `panic`, так как среда выполнения все осуществит сама;
* Механизм `паник` существенно различается с исключениями из других ЯП. Он используется для грубых ошибок, таких как
  логическая несогласованность в программе, при этом происходит аварийное завершение программы;
* Если ошибка, возникает по причине некорректного ввода, неверной конфигурации или сбоя ввода-вывода, лучше обработать
  их с использованием типа `error`;
* Префикс `Must` является распространенным соглашением именования для функции такого рода
  как `template.Must`, `regexp.MustCompile` - такие функции не возвращают ошибки и они должны выполниться обязательно;
* Когда программа сталкивается с `паникой`, все отложенные функции выполняются в порядке, обратном их появлению в коде,
  начиная с функции на вершине стека и опускаясь до функции `main`;
* Функция может восстановиться после паники так, что программа при этом не будет аварийно завершена;
* Если в Go функция вызывает `panic`, а затем восстанавливается с помощью функции `recover`, то эта функция возвращает
  значение, переданное в `panic`;
* Для диагностических целей пакет `runtime` позволяет вывести дамп стека;
* Функция `runtime.Stack` позволяет вывести информацию о функциях. Однако механизм `паники` в Go запускает отложенные
  функции **до** разворачивания стека (вывода его в стандартный поток).

____

## 5.10. Восстановление

* В некоторых случаях, после возникновения ошибки, может потребоваться восстановление, например, чтобы очистить ресурсы
  перед выходом из программы. В этом случае можно использовать функцию `recover`;
* Функция recover должна использоваться только внутри отложенной функции, которая вызывается с помощью
  оператора `defer`;
* Она завершает текущую панику и возвращает ее значение. Функция, которая столкнулась с паникой, продолжается там, где
  была прервана и выход из нее осуществляется в обычном режиме;
* Если `recover` вызвать `вне отложенной функции` или вне функции, которая `не столкнулась с паникой`, то она ничего не
  будет делать и вернет `nil`;
* С помощью функции recover можно восстановить функцию после паники и использовать ее (паники) значение для создания
  сообщения об ошибке и возврата обычной ошибки;
* Не рекомендуется всегда восстанавливаться после паники (особенно необдуманно), потому что состояние переменных в
  программе после паники может быть неизвестно или не задокументировано. Например, может быть неполное обновление данных
  или открытый файл, который не закрылся. Если не обрабатывать панику правильно, то можно пропустить ошибку;
* Восстановление из паники в том же пакете может помочь упростить обработку сложных или неожиданных ошибок, но не
  рекомендуется выполнять восстановление после паники в другом пакете;
* Общедоступные API должны сообщать об ошибках с помощью `error`;
* Пример: пакет `net/http` предоставляет веб-сервер. Вместо того чтобы позволить панике в одном из своих обработчиков
  завершить весь процесс, сервер вызывает функцию `recover`, выводит трассировку стека и продолжает обслуживание. Это
  может быть удобным, но есть риск утечки ресурсов или возникнуть ситуация, когда паника будет в неопределенном
  состоянии;
* Чтобы восстановление после ошибки было безопасным, необходимо использовать выборочное восстановление только в крайне
  редких случаях. Для этого можно создать не экспортируемый тип для значения ошибки и проверять, имеет ли значение,
  возвращенное из `recover`, этот тип. Если да - то о панике сообщается как об ошибке, если нет - вызываем панику с тем
  же значением для восстановления паники;
* Из некоторых ситуаций восстановление невозможно. Например, исчерпание памяти приводит к завершению программы с
  фатальной ошибкой.

____