# 5.10 Восстановление

Все, что описано в уроке 9 (см. lesson9) - это обычно правильная реакция на панику, но не всегда. Может возникнуть
ситуация, когда возможно некоторое восстановление после ошибки, или по крайней мере возможно "уборка беспорядка" перед
выходом из программы. Например, веб-сервер, который сталкивается с неожиданной проблемой, может аккуратно закрыть
подключения, а не оставлять клиентов "зависшими", а во время разработки сообщать клиентам об ошибке.

Если в отложенной функции вызывается встроенная функция `recover` и функция, содержащая инструкцию `defer`,
сбоит, `recover` завершает текущее аварийное состояние и возвращает соответствующее значение панике. Функция, которая
столкнулась с паникой, продолжается с того места, где она была прервана, и выход из нее осуществляется в штатном режиме.
Если `recover` вызывается в любой другой момент, она ничего не делает и возвращает значение `nil`.

Для иллюстрации рассмотрим разработку синтаксического анализатора языка. Даже если нам кажется, что он отлично работает,
в нем по-прежнему могут быть ошибки, в особенности если учесть сложность его работы. Мы могли бы предпочесть, чтобы
вместо аварийного завершения работы анализатор превращал аварийные ситуации в обычные ошибки синтаксического анализа,
возможно с дополнительным сообщением, предлагающим пользователям сообщить об этой ошибке разработчикам:

``` go
func Parse(input string) (s *Syntax, err error) {
    defer func() {
        if p := recover; err != nil {
            err = fmt.Errorf("внутренняя ошибка: %v", p)
        }   
    }()
    //... Синтаксический анализатор...
}
```

Отложенная функция в `Parse` выполняет восстановление после аварийной ситуации, используя значение аварийной ситуации
для создания сообщения об ошибке. Более мощная версия может включать весь стек вызовов, полученный с
помощью `runtime.Stack`. Затем отложенная функция выполняет присваивание результата переменной `err`, которая
возвращается вызывающей функции.

Огульное (это качество чего-либо, что сделано без должной осторожности, бездумно, поверхностно, без учета всех
возможных последствий) восстановление после аварийной ситуации представляется сомнительным, потому что состояния
переменных пакета после паники редко точно определены или документированы. Возможно, было неполным критическое
обновление структуры данных, файл (или сетевое подключение) был открыт, но не закрылся и блокировка была захвачена, но
не освобождена. Кроме того, замена аварийного завершения, например, строкой в файле журнала может привести к тому, что
ошибка останется попросту незамеченной.

Восстановление из аварийного состояния в том же пакете может помочь упростить обработку сложных или неожиданных ошибок,
но, как правило, не следует пытаться осуществлять восстановление при панике в другом пакете. Общедоступные `API` должны
сообщать о неудачах с помощью error. Аналогично мы не должны осуществлять восстановление в случае паники, которая может
пройти через не поддерживаемую нами функцию (например, в случае применения функция обратного вызова), так как при этом
мы не сможем оценить безопасность этого действия.

Например, пакет `net/http` предоставляет веб-сервер, который диспетчеризует входящие запросы, передавая их
функциям-обработчикам (handler), предоставляемым пользователям. Вместо того чтобы позволить панике в одном из этих
обработчиков завершить весь процесс, сервер вызывает функцию `recover`, выводит трассировку стека и продолжает
обслуживание. На практике это удобно, но при таком подходе имеется риск утечки ресурсов или возникновение ситуации,
когда аварийный обработчик остается в неопределенном состоянии, что позже может привести к другим проблемам.

По всем указанным выше причинам наиболее безопасным является выборочное восстановление (если оно вообще используется).
Другими словами, восстановление может выполняться только в (крайне редких!) паниках, предназначенных для восстановления.
Это предназначение может быть закодировано с использованием специального не экспортируемого типа для значения паники и
проверки, имеет ли возвращенное `recover` значение этот тип. (Один из способов, как это сделать представлен в примере
см. title3.go). Если это так, то об панике мы сообщаем как об обычной ошибке. Если нет, то вызываем `panic` с тем же
значением для восстановления аварийного состояния.

Приведенный ниже пример является вариацией программы `title`, которая сообщает об ошибке, если `HTML-документ` содержит
несколько элементов `<title>`. В этом случае программа прерывает рекурсию, вызывая функцию `panic` со значением
специального типа `bailout`.

Отложенная функция-обработчик вызывает `recover`, проверяет значение паники и сообщает об обычной ошибке, если это
значение - `bailout{}`. Все прочие значения, не являющиеся `nil`, указывают на неожиданную панику, и в этом случае
обработчик вызывает функцию `panic` с данным значением. Тем самым действие `recover` отменяется и восстанавливается
исходная паника. (В этом примере несколько нарушены советы не использовать паники для "ожидаемых" ошибок, но это сделано
для того, чтобы компактно проиллюстрировать данный механизм).

Из некоторых ситуаций восстановление невозможно. Например, исчерпание памяти приводит к завершению программы с фатальной
ошибкой.

## Выводы:

* В некоторых случаях, после возникновения ошибки, может потребоваться восстановление, например, чтобы очистить ресурсы
  перед выходом из программы. В этом случае можно использовать функцию `recover`;
* Функция recover должна использоваться только внутри отложенной функции, которая вызывается с помощью
  оператора `defer`;
* Она завершает текущую панику и возвращает ее значение. Функция, которая столкнулась с паникой, продолжается там, где
  была прервана и выход из нее осуществляется в обычном режиме;
* Если `recover` вызвать `вне отложенной функции` или вне функции, которая `не столкнулась с паникой`, то она ничего не
  будет делать и вернет `nil`;
* С помощью функции recover можно восстановить функцию после паники и использовать ее (паники) значение для создания
  сообщения об ошибке и возврата обычной ошибки;
* Не рекомендуется всегда восстанавливаться после паники (особенно необдуманно), потому что состояние переменных в
  программе после паники может быть неизвестно или не задокументировано. Например, может быть неполное обновление данных
  или открытый файл, который не закрылся. Если не обрабатывать панику правильно, то можно пропустить ошибку;
* Восстановление из паники в том же пакете может помочь упростить обработку сложных или неожиданных ошибок, но не
  рекомендуется выполнять восстановление после паники в другом пакете;
* Общедоступные API должны сообщать об ошибках с помощью `error`;
* Пример: пакет `net/http` предоставляет веб-сервер. Вместо того чтобы позволить панике в одном из своих обработчиков
  завершить весь процесс, сервер вызывает функцию `recover`, выводит трассировку стека и продолжает обслуживание. Это
  может быть удобным, но есть риск утечки ресурсов или возникнуть ситуация, когда паника будет в неопределенном
  состоянии;
* Чтобы восстановление после ошибки было безопасным, необходимо использовать выборочное восстановление только в крайне
  редких случаях. Для этого можно создать не экспортируемый тип для значения ошибки и проверять, имеет ли значение,
  возвращенное из `recover`, этот тип. Если да - то о панике сообщается как об ошибке, если нет - вызываем панику с тем
  же значением для восстановления паники;
* Из некоторых ситуаций восстановление невозможно. Например, исчерпание памяти приводит к завершению программы с
  фатальной ошибкой.







































