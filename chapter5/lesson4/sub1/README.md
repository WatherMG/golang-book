# 5.4.1 Стратегия обработки ошибок

Когда вызов функции возвращает ошибку, вызывающая функция должна проверить ее и принять соответствующие меры. В
зависимости от ситуации может быть ряд возможных действий вызывающей функции. Рассмотрим 5 из них:

1. Первый и наиболее распространенный случай - **распространение ошибки**, так, что сбой в подпрограмме становиться
   сбоем
   вызывающей функции. (Такой пример можно увидеть в функции `findlinks` из раздела 5.3). Если вызов `http.Get`
   неудачен,
   `findlinks` передает ошибку HTTP вызывающей функции без дальнейших церемоний:

``` go
resp, err := http.Get(url)
if err != nil {
    return nil, err
} 
```

В противоположность этому, если неудачен вызов `html.Parse`, функция `findlinks` не возвращает ошибку HTML-анализатора
непосредственно, потому что в ней не хватает двух важнейших частей информации:

* Того, что ошибка произошла в синтаксическом анализаторе;
* и URL документа, анализ которого выполнялся.

В этом случае функция `findlinks` создает новое сообщение об ошибке, которое включает в себя эту информацию, а так же
базовую ошибку синтаксического анализатора:

``` go
doc, err := html.Parse(resp.Body)
resp.Body.Close()
if err != nil {
    return, nil, fmt.Errorf("анализ %s как HTML: %v", url, err)
}
```

Функция `fmt.Errorf` форматирует сообщение об ошибке, используя функцию `fmt.Sprintf`, и возвращает новое
значение `error`. Мы используем ее для создания описательной ошибки с помощью добавления информации о контексте к
исходному сообщению об ошибке. Когда ошибка в конечном итоге обрабатывается в функции `main` программы, должна быть
предоставлена четкая причинно-следственная цепочка от источника, чем-то напоминающая расследование несчастного случая в
NASA:

```
Источник: авария: нет парашюта: ошибка переключателя: сбой реле
```

Поскольку сообщения об ошибках часто соединены в одну цепочку, строки сообщения не стоит начинать с прописных букв, а
также следует избегать символов новой строки. Получаемые сообщения могут быть длинными, зато будут самодостаточны при
поиске с помощью таких инструментов, как `grep`.

При разработке сообщений об ошибках нужно быть осмотрительным, чтобы каждое из них было осмысленным и достаточно
подробным описанием проблемы. Они должны быть последовательными и согласованными, чтобы ошибка, возвращаемые одной и той
же функцией или группой функций в одном пакете, были похожи по форме и могли рассматриваться одним и тем же способом.

Например, пакет `os` гарантирует, что каждая ошибка, возвращенная файловой операцией, такой как `os.Open`, или методами
`Read`, `Write` или `Close` открытого файла, не только описывает характер сбоя (отсутствие прав доступа, нет такого
каталога и т.д), но и содержит имя файла, так что вызывающей функции не нужно включать эту информацию в сообщение об
ошибке, которое она создает.

В общем случае вызов `f(x)` несет ответственность за предоставление информации о предпринятой операции `f` и значении
аргумента `x`, если они относятся к контексту ошибки. Вызывающая функция отвечает за добавление дальнейшей информации,
которой обладает она, но не функция `f(x)`, например URL в вызове `html.Parse` их приведенного выше кода.

2. Для ошибок, которые представляют переходящие или непредсказуемые проблемы, может иметь смысл **_повторить_** сбойную
   операцию. Возможно, с задержкой между попытками, и, вероятно, с ограничением, накладываемым на количество попыток или
   на
   время, которое можно затратить на выполнение (см. wait.go)

Далее, если прогресс невозможен, вызывающая функция может вывести сообщение об ошибке и элегантно завершить выполнение
программы, но этот способ действий, как правило, зарезервирован для основного пакета программы. Библиотечные функции,
обычно, должны передавать ошибки вызывающей функции, кроме случаев, когда ошибка является признаком внутренней
несогласованности.

``` go
// (В функции main)

if err := WaitFor Server(url); err != nil {
   fmt.Fprintf(os.Stderr, "Сервер не работает: %v\n", err)
   os.Exit(1)
}
```

Более удобным способом достижения того же эффекта является вызов `log.Fatalf`. Как и все функции пакета `log`, по
умолчанию она предваряет сообщение об ошибке текущими временем и датой.

``` go
if err := WaitForServer(url); err != nil {
   log.Fatalf("Сервер не работает: %v\n", err)
}
```

Формат по умолчанию полезен при работе "долгоиграющего" сервера и менее удобен для интерактивного инструмента:

`2006/01/02 15:04:05 Сервер не работает: неверный домен: bad.golp.io`

Более привлекательный вывод можно получить, задав префикс, используемый в пакете `log`, и подавив отображение даты и
времени:

``` go
log.SetPrefix("wait: ")
log.SetFlags(0)
```

В некоторых случаях достаточно просто записать ошибку в журнал и продолжить работу, возможно, с уменьшенной
функциональностью. При этом вновь можно выбирать между использованием пакета `log`, который добавляет обычный префикс:

``` go
if err := Ping(); err != nil {
   log.Printf("ошибка ping: %v; сеть отключена", err)
}
```

и выводом непосредственно в стандартный поток ошибок:

``` go
if err := Ping(); err != nil {
   fmt.Fprintf(os.Stderr, "ошибка ping: %v; сеть отключена", err)
}
```

Все функции пакета `log` добавляют символ новой строки, если таковой отсутствует.

3. Последняя стратегия - в редких случаях можно безопасно полностью игнорировать ошибку:

``` go
dir, err := ioutil.TempDir("", "scratch")
if err != nil {
   return fmt.Errorf("ошибка создания временного каталога: %v\n", err)
}

//... используем временный каталог...
os.RemoveAll(dir) // Игнорируем ошибки; $TMPDIR периодически очищается
```

Вызов `os.RemoveAll` может завершиться неудачно, но программа это игнорирует, потому что операционная система сама
периодически очищает временный каталог. В этом случае игнорирование ошибки было преднамеренным, но логика программы
выглядит так, как будто мы просто забыли обработать ошибку.

Нужно выработать привычку проверять ошибки после каждого вызова функции, а если их преднамеренно игнорируем в каком-то
месте, нужно явно документировать свои намерения.

Обработка ошибок в Go имеет свой "ритм". После проверки сначала обычно обрабатывается ошибка, а уже затем - успешное
выполнение. Если сбой приводит к выходу из функции, успешное продолжение работы выполняется не в блоке `else`, а на
более высоком уровне, с меньшим отступом. Функции, как правило, демонстрируют общую структуру с рядом предварительных
проверок, чтобы избежать ошибок, после чего следует основной код функции с минимальным отступом.

## Выводы:

* В случае возникновения ошибки, ее нужно обрабатывать в вызывающей функции.;
* Функция `fmt.Errorf` форматирует сообщение об ошибке, используя `fmt.Sprintf`, и возвращает новое значение `error`;
* При обработке ошибок в функции main необходимо строить четкую цепочку ошибок от источника до конечного вызова;
* Сообщение об ошибке должно быть осмысленным и подробным, следует избегать начала строки сообщения с прописных букв и
  символов новой строки;
* Сообщение об ошибке должно быть осмысленным и достаточно подробным (последовательным и согласованным, с другими
  ошибками цепочки\пакета);
* Для ошибок, которые представляют переходящие или непредсказуемые проблемы (проблемы с сетевым соединением, проблемы с
  доступностью внешних сервисов, ошибка доступа к диску), имеет смысл **_повторить_** сбойную операцию, с задержкой и
  ограничениями на количество попыток или время.
* Все функции пакета `log`, по умолчанию добавляет в начало сообщения об ошибке текущее время и дату. Такой формат
  полезен при работе "долгоиграющего" сервера, но менее удобен в интерактивном режиме. Так же, все функции добавляют
  символ новой строки `\n`.
* Все функции пакета `log` добавляют в начало сообщения об ошибке текущее время и дату, для изменения этого поведения
  можно использовать методы `log.SetPrefix` и `log.SetFlags`.

* После проверки ошибки сначала обычно обрабатывается ошибка, а затем - код, который следует выполнить, если ошибок нет.
  Если ошибка приводит к выходу из функции, успешное продолжение работы выполняется не в блоке `else`, а в теле функции.
* Игнорирование ошибок допустимо в случае, если возвращаемое значение ошибки не важно и мы уверены в успешном выполнении
  операции, а также если мы обрабатываем ошибку в другом месте кода или в другой функции. При этом необходимо
  сопроводить игнорирование ошибок комментарием, объясняющим причину игнорирования.