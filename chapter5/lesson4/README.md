# 5.4 Ошибки

Одни функции всегда успешно решают свои задачи. Например, `strings.Contains` и `strconv.FormatBool` имеют четко
определенные результаты для всех возможных аргументов и не могут завершиться неудачно - за исключением непредсказуемых
и катастрофических сценариев наподобие нехватки памяти, когда симптом проявляется далеко от причины и практически нет
надежд на восстановление.

Другие функции всегда успешны, пока выполняются их предусловия. Например, функция `time.Date` всегда создает `time.Time`
из его компонентов (год, месяц, день и т.д.), если только последний аргумент (часовой пояс) не равен `nil`. В этом
случае возникает `panic`. Такая аварийная ситуация - верный признак ошибки в вызывающем коде и никогда не должна
возникать в хорошо написанной программе.

Для многих других функций, даже в хорошо написанных программах, успех не гарантируется, потому что он зависит от
факторов, находящихся вне контроля программы. Например, любая функция, выполняющая ввод-вывод, должна учитывать
возможность ошибки, и только наивный программист верит в то, что простое чтение или запись никогда не сбоит. Когда
наиболее надежные операции неожиданно оказываются неудачными, обязательно необходимо знать, в чем дело. Таким образом,
ошибки являются важной частью API пакета или пользовательского интерфейса приложения, и сбой является лишь одним из
нескольких ожидаемых поведений программы. В этом заключается подход Go к обработке ошибок.

Функция, для которой отказ является ожидаемым поведением, возвращает дополнительный результат, обычно последний. Если
сбой имеет только одну возможную причину, результат представляет собой булево значение, обычно с именем `ok`, как в
приведенном ниже примере поиска в кеше, который всегда выполняется успешно, если только в кеше имеется запись искомого
ключа.

``` go
value, ok := cache.Lookup(key)
if !ok {
// ...cache[key] не существует
} 
```

Чаще всего, и в особенности для ввода-вывода, неудачи могут иметь множество разнообразных причин, так что вызывающая
функция должна знать, что именно произошло. В таких случаях тип дополнительного результата - `error`.

Встроенный тип `error` является типом интерфейса. Ошибка может быть нулевой и ненулевой. Нулевая ошибка означает
успешное завершение, ненулевая - ошибка содержит строку сообщения об ошибке, которую мы можем получить путем вызова ее
метода `Error` или путем вывода с помощью `fmt.Println(err)` или `fmt.Printf("%v\n", err)`.

Обычно, когда функция возвращает ненулевую ошибку, ее результаты не определены и должны быть проигнорированы. Однако,
некоторые функции при ошибке могут возвращать частичные результаты. Например, если произошла ошибка во время чтения из
файла, вызов `Read` возвращает количество байтов, которые функция смогла прочитать, и **ошибку**, описывающую возникшую
проблему. Для обеспечения правильного поведения некоторым вызывающим функциям может потребоваться обработать неполные
данные до обработки ошибки, поэтому важно, чтобы такие функции точно документировали свои результаты.

Подход Go отличает его от многих других языков программирования, в которых об отказах сообщается с помощью механизма
**_исключений_**, а не обычных значений. Хотя в Go имеется определенный механизм исключений, он используется только для
действительно неожиданных неприятностей, указывающих на наличие серьезной ошибки, а не на обычные ошибки подпрограмм,
которые надежная программа должна ожидать и обрабатывать.

Причина такого подхода заключается в том, что исключения, как правило, смешивают описание ошибки с обрабатывающим ее
потоком управления, что часто приводит к нежелательным результатам:
Обычные ошибки подпрограмм предоставляются конечному пользователю в виде малопонятного состояния стека с полной
информацией о структуре программы, но, при с этом недостаточно четкой информацией о том, что именно пошло не так.

Go же, напротив, для реакции на ошибки использует обычные механизмы потока управления наподобие инструкции `if`
или `return`. Этот стиль, несомненно, требует уделять больше внимания логике обработки ошибок, но ясность и точность
обработки ошибок того стоят.

## Выводы:

* Функции, которые возвращают булево значение (`false`, `true`), могут выдать ошибки в случае, например, переполнения
  стека и нехватки памяти. Такие ошибки необходимо обрабатывать, чтобы избежать непредсказуемого поведения программы.
* Обрабатывать ошибки нужно, так как даже в "надежных" программах они могут появиться там, где не ожидаешь. Это связано
  с несколькими факторами, такими как внешние условия, состояние системы и взаимодействие с другими программами.
* Обработка ошибок важна, для предоставления информации о том, что конкретно пошло не так и было проще разобраться с
  возникшей проблемой. Это упрощает поиск и исправление ошибок в коде.
* Когда функция возвращает тип error, в нее, обычно, передается информация с последней вызванной функции, которая также
  возвращала тип error. Это позволяет отслеживать цепочку ошибок и определять их причины.
* Тип error является интерфейсом, что позволяет определять собственные типы ошибок и использовать их в своих программах.
* Ошибка может быть нулевой или ненулевой. Нулевая ошибка (`nil`) обозначает успешное завершение функции, а ненулевая
  ошибка содержит информацию о проблеме, которая возникла в процессе выполнения функции.
* В Go используются конструкции `if` и `return` для обработки ошибок вместо исключений. Это обеспечивает более точный
  контроль над обработкой ошибок и предотвращает неопределенное поведение, которое может возникнуть при использовании
  исключений.
* В Go исключения не используются, потому что они могут приводить к неопределенному поведению и усложнять отладку.
  Вместо этого используется механизм возврата ошибок через тип `error`. Это позволяет более точно контролировать
  обработку ошибок и сделать код более понятным и предсказуемым.
