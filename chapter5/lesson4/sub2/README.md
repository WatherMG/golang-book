# 5.4.2 Конец файла (EOF)

Обычно, различные ошибки, которые может возвращать функция, интересны конечному пользователю, но не для промежуточной
логики программы. Однако, иногда, программы должны предпринимать различные действия в зависимости от типа произошедшей
ошибки. Рассмотрим попытки чтения `n` байтов данных из файла.

Если `n` - длина файла, любой сбой представляет собой ошибку. С другой стороны, если вызывающая функция пытается
многократно читать блоки фиксированного размера до конца файла, то она должна реагировать на ошибку достижения конца
файла иначе, чем на все прочие ошибки. По этой причине пакет `io` гарантирует, что о невозможности чтения, вызванной
достижением конца файла, всегда сообщается как об отдельной ошибке `io.EOF`, которая определена следующим образом:

```go
package io

import "errors"

// EOF - это ошибка, возвращаемая функцией Read, когда больше нет данных для чтения.
var EOF = errors.New("EOF")
```

Вызывающая функция может обнаружить это условие с помощью простого сравнения, как ниже показано в цикле, который читает
руны из стандартного ввода (см. charcount.go из раздела 4.3).

```go
in := bufio.NewReader(os.Stdin)
for {
r, _, err := in.ReadRune()
if err == io.EOF {
break // Чтение завершено
}
if err != nil {
return fmt.Errorf("сбой чтения: %v", err)
}
// ...использование r...
}
```

Поскольку условие конца файла не содержит никакой информации, о которой могло бы сообщить, `io.EOF` имеет фиксированное
сообщение об ошибке - `"EOF"`. Для других ошибок может потребоваться более полный отчет, так сказать, более качественная
и количественная информация, поэтому у них нет фиксированного значения ошибок.

## Выводы:
* Пакет `io` гарантирует, что ошибка достижения конца файла всегда будет сообщаться, как об отдельной ошибке `io.EOF`;
* Вызывающая функция может обнаружить условие конца файла с помощью простого сравнения `==`;
* Ошибка `io.EOF` имеет фиксированное сообщение, так как условие конца файла не содержит дополнительной информации.