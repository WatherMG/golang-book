# 5.5 Значения-функции

Функции являются **_значениями первого класса_** в Go - подобно другим значениям, значения-функции имеют типы, и они
могут быть присвоены переменным или, например, переданы в функцию или возвращены из нее. Значение-функция может быть
вызвано подобно любой другой функции, например:

``` go
func square(n int) int { return n * n }
func negative(n int) int { return -n }
func product(m, n int) int { return  m * n }

f := square
fmt.Println(f(3)) // 9

f = negative
fmt.Println(f(3)) // -3
fmt.Printf("%T\n", f) // func(int) int

f = product // Ошибка компиляции: нельзя присваивать func(int, int) int переменной func(int) int
```

Нулевым значением типа функции является `nil`. Вызов нулевой функции приводит к `panic`:

``` go
var f func(int) int
f(3) // panic: вызов nil-функции
```

Значение-функцию можно сравнить с `nil`:

``` go
var f func(int) int
if f != nil {
    f(3)
}
```

Значения-функции в Go не могут быть сравнены друг с другом напрямую, так как каждая функция в Go имеет уникальный адрес
в памяти. Это означает, что значения-функции нельзя использовать в качестве ключей в карте map.

Значения-функции позволяют параметризовать наши функции не только данными, но и поведением. Стандартные библиотеки
содержат много примеров тому. Например, `strings.Map` применяет функцию к каждому символу строки, объединяя результаты в
другую строку:

``` go
func add1(r rune) rune { return r + 1 }

fmt.Println(strings.Map(add1, "HAL-9000")) // "IBM.:111"
fmt.Println(strings.Map(add1, "VMS"))      // "WNT"
fmt.Println(strings.Map(add1, "Admix"))    // "Benjy"
```

Функция `findlinks` из раздела 5.2 использует вспомогательную функцию `visit`, чтобы посетить все узлы в документе HTML
и применить действие к каждому из них. С помощью значения-функции мы можем отделить логику обхода дерева от логики
действия, применяемого к каждому узлу, что позволит нам выполнять обход с различными действиями (см. outline2.go)

Функция forEachNode принимает два аргумента-функции: один - для вызова перед посещением дочерних узлов, а второй - для
вызова после такого посещения. Это обеспечивает высокую степень гибкости для вызывающей функции. Например,
функции `startElement` и `endElement` выводят открывающий и закрывающий дескрипторы HTML-элемента
наподобие `<b>...</b>`.

Эти функции также обеспечивают отступы с помощью еще одного трюка функции `fmt.Printf`. Символ `*` в `%*s` выводит
строку, дополненную переменным количеством пробелов. Ширина вывода и выводимая строка переданы как аргументы `depth*2`
и `""`.

При вызове `forEachNode` с HTML-документом следующим образом `forEachNode(doc, startElement, endElement)` мы получим
более красивый вывод нашей рассмотренной ранее программы `outline`:

```
$ go build .\outline2.go
$ .\outline2
<html>
  <head>
    <meta>
    </meta>
    <title>
    </title>
    <style>
    </style>
  </head>
  <body>
    <table>
      <tbody>
        <tr>
          <td>
            <a>
              <img>
              </img>
...
```

## Выводы:

* Функции - значения первого класса. Они могут быть присвоены переменным или переданы в функцию, а так же возвращены из
  нее;
* Нулевым значением типа функции является `nil`;
* Значение-функцию можно сравнивать с `nil`, но нельзя сравнивать их друг с другом напрямую, так как каждая функция
  имеет уникальный адрес в памяти;
* Значения-функции нельзя использовать в качестве ключей в `map`;
* Значения-функции позволяют параметризовать функции не только данными, но и поведением;
* С помощью значения функции можно разделить логику на модули;
* У `fmt.Printf` есть "трюк", который позволяет добавить переменное количество отступов в строке. С помощью символа `*`
  в `%*s` - принимает два аргумента, первый - переменное количество пробелов (ширина вывода, тип `int`), второй -
  выводимая строка.