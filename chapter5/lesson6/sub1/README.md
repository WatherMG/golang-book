# 5.6.1 Предупреждение о захвате переменных итераций

В этом разделе мы рассмотрим ловушку правил лексической области видимости Go, которая может привести к неожиданным
результатам. Очень важно разобраться в этой проблеме, прежде, чем продолжить работу, потому что в эту ловушку попадают
даже опытные программисты.

Рассмотрим программу, которая должна создать набор каталогов, а затем удалить их. Мы можем использовать срез
значений-функций для хранения операций по очистке. (Для краткости в этом примере опущена любая обработка ошибок):

``` go
var rmdirs []func()
for _, d := range tempDirs() {
    dir := d // Примечание: необходимо!
    os.MkdirAll(dir, 0755) // Создание родительских каталогов
    rmdirs =  append(rmdirs, func() {
        os.RemoveAll(dir)
    })
}

// ... do some work ...

for _, rmdir := range rmdirs {
    rmdir() // Очистка
}
```

Может появиться вопрос, почему мы присваиваем переменную цикла `d` новой локальной переменной `dir` в теле цикла, вместо
того, чтобы просто дать имя `dir` переменной цикла, но это будет некорректным решением:

``` go
var rmdirs []func()
for _, dir := range tempDirs() {
    os.MkdirAll(dir, 0755)
    rmdirs = append(rmdirs, func () {
        os.RemoveAll(dir) // примечание: неверно!
    })
}
```

Причина заключается в следствии из правил области видимости для переменных цикла. В приведенном выше коде цикл `for`
вводит новый лексический блок, в котором объявлена переменная `dir`. Все значения-функции, созданные этим циклом,
"захватывают" и совместно используют одну и ту же переменную - адресуемое место в памяти, а не его значение в этот
конкретный момент. Поэтому к тому моменту, когда во время очистки вызываются соответствующие функции, переменная `dir`
несколько раз оказывается обновленной завершенным к этому моменту циклом `for`. Таким образом, `dir` хранит значение из
последней итерации, а следовательно все вызовы `os.RemoveAll(dir)` попытаются удалить один и тот же каталог.

Зачастую, для решения этой проблемы создается внутренняя переменная (в нашем примере - `dir`) с тем же именем, что и у
внешней переменной, копией которой она является. Это приводит к странно выглядящему, но ключевому объявлению переменной
наподобие следующего:

``` go
for _, dir := range tempDirs() {
    dir := dir // Объявление внутренней dir, инициализированной значением внешней dir
    //...
}
```

Этот риск не является чем-то уникальным, характерным только для цикла по диапазону. Цикл в примере ниже сталкивается с
той же проблемой из-за непреднамеренного захвата индексной переменной `i`:

``` go
var rmdirs []func()
dirs := tempDirs()
for i := 0; i < len(dirs); i++ {
    os.MkdirAll(dirs[i], 0755) // OK
    rmdirs = append(rmdirs, func() {
        os.RemoveAll(dirs[i]) // Примечание: неверно!    
    })
}
```

Проблема захвата переменной итерации чаще всего встречается при использовании инструкции go (`Горутины и каналы`) или
defer, поскольку обе они могут задержать выполнение значения-функции до момента после завершения цикла. Но эта проблема
не является проблемой, свойственной именно go или defer.

## Выводы:

* Проблема заключается в неожиданном захвате переменных цикла. Это может привести к неожиданным результатам;
* Все значения-функции (анонимных функций (замыканий)), созданные в цикле, захватывают и совместно используют одну и ту
  же переменную, а именно, адресуемое место в памяти, а не ее значение в конкретный момент. В результате переменная
  может быть обновлена несколько раз и сохранить последнее значение в конце цикла;
* Для решения этой проблемы, создается внутренняя переменная с тем же именем, что и у внешней переменной, копией которой
  она является;
* Проблема захвата переменной итерации может возникнуть при использовании инструкции `go` или `defer`, поскольку обе
  могут задержать выполнение функции до момента после завершения цикла;
* Проблема не является уникальной для Go и может возникнуть в других языках программирования.