# 5.6 Анонимные функции

Именованные функции могут быть объявлены только на уровне пакета, но мы можем использовать **_литерал функции_** для
обозначения значения-функции в любом выражении. Литерал функции записывается как объявление функции, но без имени после
ключевого слова `func`. Это выражение, и его значение называется **_анонимной функцией_**.

``` go
func addl(r rune) rune { return r + 1 }

fmt.Println(strings.Map(addl, "HAL-9000")) // "IBM.:111"
fmt.Println(strings.Map(addl, "VMS")) // "WNT"
fmt.Println(strings.Map(addl, "Admix")) // "Benjy"
```

Литерал функции позволяет определить функцию в точке использования. В качестве примера приведенный выше
вызов `strings.Map` можно переписать следующим образом:

``` go
strings.Map(func(r rune) rune { return r + 1}, "HAL9000")
```

Что более важно, определенная таким образом функция имеет доступ ко всему лексическому выражению, так что внутренняя
функция может обращаться к переменным их охватывающей функции, как показано в примере см. squares.go:

Функция `squares` возвращает другую функцию, типа `func() int`. Вызов `squares` создает локальную переменную `x` и
возвращает анонимную функцию, которая при каждом вызове увеличивает `x` и возвращает ее квадрат. Второй вызов `squares`
создаст вторую переменную `x` и вернет новую анонимную функцию, которая будет увеличивать эту переменную.

В примере `squares` продемонстрировано, что значения-функции не только являются кодом, но могут иметь и состояние.
Внутренняя анонимная функция может обращаться к локальным переменным охватывающей функции `squares` и обновлять их. Эти
скрытые ссылки на переменные являются причиной, по которой мы классифицируем функции как ссылочные типы и из-за чего,
значения-функции не являются сравниваемыми. Значения-функции, подобные приведенной, реализуются с помощью технологии под
названием **_замыкания_**, и программисты Go часто используют этот термин для значений-функций.

Здесь мы опять видим пример того, что время жизни переменной не определяется ее областью видимости: переменная `x`
существует после того, как функция `squares` возвращает управление функции `main`, несмотря на то, что `x` скрыта
внутри `f()`.

В качестве несколько академического примера анонимных функций рассмотрим проблему вычисления последовательности курсов
информатики, которая удовлетворяет требованиям каждого из них, заключающимся в том, что определенный курс опирается на
другие курсы, которые должны быть изучены до него. Условия приведены в таблице `prereqs` ниже, которая представляет
собой карту `map` каждого курса на список курсов, которые должны быть пройдены до данного курса (см. toposort.go)

Такого рода задача известна как топологическая сортировка. Концептуально информация о необходимых курсах формирует
ориентированный граф с узлом для каждого курса и ребрами от него к курсам, от которых он зависит. Этот граф ацикличен:
не существует пути от курса, который вел бы обратно к этому курсу. Вычислить допустимую последовательность курсов можно
с помощью поиска в графе в губину с использованием следующего кода (см. main() в toposort.go)

Когда анонимная функция требует рекурсию, как показано в данном примере, мы должны сначала объявить переменную, а затем
присвоить ей анонимную функцию. Если эти два шага объединить в один в объявлении, литерал функции не будет находиться в
области видимости переменной `visitAll`, так что он не будет иметь возможности вызывать себя рекурсивно:

``` go
visitAll := func(items []string) {
    // ...
    visitAll(m[item]) // Ошибка компиляции: не определена visitAll
    // ...
}
```

Ниже приведен вывод программы `toposort`. Он **детерминирован** - это часто требуемое свойство, которое не всегда
удается получить бесплатно. Здесь значениями `map` `prereqs` являются _срезы_, а не `map`, так что порядок их итераций
детерминирован, и мы _сортируем_ ключи `prereqs` до первого вызова `visitAll`:

```
 1: intro to programming
 2: discrete math
 3: data structures
 4: algorithms
 5: linear algebra
 6: calculus
 7: formal languages
 8: computer organization
 9: compilers
10: databases
11: operating systems
12: networks
13: programming languages
```

Вернемся к примеру `findLinks`. Мы перенесли функцию извлечения ссылок `links.Extract` в собственный пакет, поскольку мы
вновь будем использовать ее в дальнейших главах. Так же, заменили функцию `visit` анонимной функцией, которая выполняет
добавление в срез `links` непосредственно и использует `forEachNode` для обработки обхода. Поскольку функция `Extract`
нуждается только в функции `pre`, в качестве аргумента `post` он передает значение `nil` (см. links.go).

Вместо добавления необработанного значения атрибута `href` в срез `links` данная версия анализирует его как `URL-адрес`
относительно базового URL документа, `resp.Request.URL`. Результирующая ссылка `link` получается в абсолютной форме,
пригодная для использования в вызове `http.Get`.

Обход веб - по сути своей задача обхода графа. В примере `topoSort` показан обход в глубину; Для нашего веб-сканера мы
будем использовать обход в ширину, по крайней мере сначала. В главе 8, "Горутины и каналы", мы рассмотрим параллельный
обход.

Приведенная функция (см. findlinks3.go) **_инкапсулирует_** суть обхода в ширину. Вызывающая функция предоставляет
исходный
список элементов для посещения `worklist` и значение-функцию `f`, вызываемую для каждого элемента. Каждый элемент
идентифицируется строкой. Функция `f` возвращает список новых элементов для добавления в рабочий список.
Функция `breadthFirst` возвращает управление после посещения всех элементов. Она поддерживает множество строк для
гарантии того, что ни один элемент не будет посещен дважды.

Аргумент `f(item)...` приводит к тому, что все элементы в списке, возвращенные `f`, добавляются в список `worklist`.

В нашем сканере элементы являются URL. Функция `crawl`, которую мы передаем `breadthFirst`, выводит `URL`, извлекает из
него ссылки и возвращает их так, что они тоже оказываются посещенными.

Процесс завершится, когда все доступные веб-страницы будут отсканированы или при исчерпании памяти компьютера.

## Выводы:

* **_Детерминированность_** - это свойство программного кода, при котором он всегда будет давать одинаковый результат
  при одинаковых входных данных и в одинаковых условиях выполнения. Это означает, что поведение кода предсказуемо и
  можно точно определить результат его выполнения;
* **_Инкапсуляция_** - сокрытие деталей внутренней реализации объекта от других частей программы;
* Функция `append(list, f(item)...)` добавляет все элементы, возвращаемые `f(item)`, в `list`;
* Анонимные функции используются для обозначения значений-функций в выражениях без явного имени и могут быть определены
  внутри других функций (`strings.Map(func(r rune) rune { return r + 1}, "HAL9000")`);
* Можно использовать **литерал функции**, чтобы обозначить **значение-функцию** в любом выражении. Такая запись
  называется **_анонимной функцией_**.
  Пример:
  ``` go
      // Создаем анонимную функцию, которая принимает два числа и возвращает их сумму
      sum := func(a, b int) int {
          return a + b
      }
  
      // Вызываем анонимную функцию и сохраняем результат в переменную
      result := sum(3, 4)
  ```
* Анонимная функция в Go имеет доступ **ко всему лексическому выражению**, включая **переменные** их охватывающей
  функции. Такая функция называется **замыканием**.
  Пример:
  ``` go
  func squares() func() int {
        x := 0
        return func() int {
            x++
            return x * x
        }
    }
  ```
* Анонимные функции могут возвращать другие функции;
* Значения-функции могут иметь **состояние** и **обновлять** локальные переменные охватывающей функции. Поэтому они
  являются **ссылочными типами и не сравниваются**;
* **_Замыкание_** - это комбинация анонимной функции и ее окружения. Замыкание “запоминает” значения переменных из
  своего окружения и может использовать их даже после того, как охватывающая функция завершила свое выполнение;
* Время жизни переменной не определяется ее областью видимости. Область видимости определяет, где переменная может быть
  использована в коде. Время жизни переменной **определяется тем**, когда память для нее **выделена и освобождена**;
* Когда анонимная функция требует рекурсии, сначала нужно объявить переменную и присвоить ей анонимную функцию. Затем
  можно использовать эту переменную внутри анонимной функции для рекурсивного вызова.