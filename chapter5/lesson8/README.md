# 5.8 Отложенные вызовы функций

Наши примеры `findLinks` использовали выходные данные `http.Get` как входные данные `html.Parse`. Это хорошо работает,
если содержание запрашиваемого `URL` действительно представляет собой HTML, но многие страницы содержат изображения,
текст и другие форматы файлов. Передача таких файлов `HTML-анализатору` может иметь нежелательные последствия.

Приведенная программа (см. title1.go) извлекает документ HTML и выводит его название. Функция `title` проверяет
заголовок `Content-Type` ответа сервера и возвращает ошибку, если документ не является документом `HTML`.

Обратите внимание на дублированный вызов `resp.Body.Close()`, который гарантирует, что `titile` закрывает сетевое
подключение на всех путях выполнения, в том числе при сбоях. По мере того как функции становятся более сложными и
должны обрабатывать больше ошибок, такое дублирование логики очистки может стать проблемой при поддержке программы.
Упростить решение этой проблемы позволяет механизм Go `defer`.

Синтаксически инструкция `defer` является обычным вызовом функции или метода, которому предшествует ключевое
слово `defer`. Функция и выражения аргументов вычисляются при выполнении инструкции, но фактический вызов
**_откладывается_** до завершения функции, содержащей инструкцию `defer`, независимо от того, как она завершается:
обычным способом, с помощью оператора `return` или в результате `panic`. Может быть отложено любое количество вызовов.
Они выполняются в порядке, обратном тому, в котором они были отложены.

Инструкция `defer` часто используется с такими парными операциями, как открытие и закрытие, подключение и отключение или
блокировка и разблокирование - для гарантии освобождения ресурсов во всех случаях, независимо от того, насколько сложен
поток управления. Правильное место инструкции `defer`, которая освобождает ресурс, — сразу же после того, как ресурс был
успешно захвачен. В функции `title`, один отложенный вызов заменяет оба предыдущих вызова `resp.Body.Close()`
(см. title2.go).

Тот же шаблон может быть использоваться для других ресурсов, помимо сетевых подключений, например, чтобы закрыть
открытый файл (пример работы `io/ioutil`):

``` go
package ioutil

import (
	"io"
	"os"
)

func ReadFile(filename string) ([]byte, error) {
	f, err := os.Open(filename)
	if err != nil {
		return nil, err
	}
	defer f.Close()
	return ReadAll(f)
}
```

Или для разблокирования мьютекса:

``` go
var mu sync.Mutex
var m = make(map[string]int)

func lookup(key string) int {
    mu.Lock()
    defer mu.Unlock()
    return m[key]
}
```

Инструкция `defer` может также использоваться для пары отладочных записей о входе в некоторую функцию и выходе из нее.
Показанная далее функция `BigSlowOperation` немедленно вызывает функцию `trace`, она выполняет запись о входе в
функцию и возвращает анонимную функцию (значение-функцию), которая при вызове выполняет запись о выходе из функции.
Таким образом, с помощью отложенного вызова возвращаемой функции мы можем выполнять запись о входе в функцию и выходе из
нее в одной инструкции и даже передавать между этими двумя действиями значения, например время начала работы функции. Но
не забывайте о завершающей паре скобок в инструкции `defer`, иначе `входное` действие будет выполнено на выходе из
функции, а `выходное` не будет выполнено вовсе (см. trace.go)!

Отложенные функции выполняются **после** того, как инструкция возврата обновляет переменные результатов функции.
Поскольку анонимная функция может обращаться к переменным охватывающей функции, включая именованные результаты,
отложенная анонимная функция имеет доступ к результатам функции, в которой вызвана.

Рассмотрим функцию `double`:

``` go
func double(x int) int {
    return x + x
}
```

Присвоив имя ее результирующей переменной и добавив инструкцию `defer`, мы можем заставить функцию выводить свои
аргументы и результаты при каждом вызове:

``` go
func double(x int) (result int) {
    defer func() { fmt.Printf("double(%d) = %d\n", x, result)}()
    return x + x
}

_ = double(4) // "double(4) = 8"
```

Этот трюк является излишеством для такой простой функции, как `double`, но может быть полезен в функции со многими
операторами `return`.

Отложенная анонимная функция может даже изменять значения, которые возвращает охватывающая функция:

``` go
func triple(x int) (result int) {
    defer func() { result += x}()
    return double(x)
}

fmt.Println(triple(4)) // 12
```

Поскольку отложенные функции не выполняются до самого конца выполнения функции, инструкция `defer` в цикле заслуживает
дополнительного изучения. У приведенного ниже кода могут возникнуть проблемы из-за исчерпания доступных файловых
дескрипторов, поскольку ни один файл не будет закрыт, пока не будут обработаны все файлы:

``` go
for _, filename := range filenames {
    f, err := os.Open(filename)
    if err != nil {
        return err
    }
    defer f.Close() // Примечание: рискованно; может привести к исчерпанию файловых дескрипторов
    // ... работа с f...
}
```

Одним из решений может быть перенос тела цикла, включая инструкцию `defer`, в другую функцию, которая вызывается на
каждой итерации:

``` go
for _, filename := range filenames {
    if err := doFile(filename); err != nil {
        return err
    }
}

func doFile(filename string) error {
    f, err := os.Open(filename)
    if err != nil {
        return err
    }
    defer f.close()
    // ... работа с f...
}
```

Приведенный пример (см. fetch.go) представляет собой усовершенствованную программу `fetch` (раздел 1.5), которая
записывает HTTP-ответ в локальный файл, а не в стандартный вывод. Она выводит имя файла из последнего компонента пути
URL, который получает с помощью функции `path.Base`.

Отложенный вызов `resp.Body.Close` уже должен быть нам знаком. Есть большой соблазн использовать второй отложенный
вызов, `f.Close`, чтобы закрыть локальный файл, но это будет неправильно, потому что `os.Create` открывает файл для
записи, создавая его при необходимости. Но во многих файловых системах, в особенности `NTFS`, ошибки записи не
фиксируются немедленно и могут быть отложены до тех пор, пока файл не будет закрыт. Невозможность проверить результат
операции закрытия может привести к тому, что потеря данных останется незамеченной. Однако, если и `io.Copy`, и `f.Close`
завершаются неудачно, следует предпочесть отчет об ошибке `io.Copy`, поскольку она произошла первой и скорее всего,
сообщит главную причину неисправности.

## Выводы:

* В Go есть механизм отложенного вызова функции или метода `defer`;
* Он используется, чтобы избежать дублирования логики очистки и гарантировать освобождение ресурсов.;
* Функция и выражения аргументов вычисляются при выполнении инструкции, но фактический вызов откладывается до завершения
  функции, причем независимо от того, как она завершается: обычным способом (void), с помощью оператора `return` или в
  результате `panic`;
* Любое количество вызовов может быть отложено, и они выполняются в обратном порядке;
* Инструкция `defer` часто используется с парными операциями: открытие\закрытие, подключение\отключение,
  блокировка\разблокировка - для гарантии освобождения ресурсов во всех случаях;
* Правильное место инструкции `defer`, которая освобождает ресурс - сразу же после того, как ресурс был успешно захвачен
  в случае, если "захват" возвращает ошибку - сразу после `if err != nil`;
* `defer` может использоваться для отладочных записей о входе и выходе из функции;
* Анонимная функция в отложенной функции имеет доступ к переменным охватывающей функции, включая **именованные**
  результаты;
* Отложенные функции выполняются после того, как инструкция возврата обновляет переменные результатов функции, и могут
  изменять их значения;
* Отложенные функции не выполняются до конца выполнения функции, поэтому при работе в цикле может возникнуть проблема.
  Одним из решений может быть перенос тела цикла, включая инструкцию `defer` в другую функцию, которая
  вызывается на каждой итерации;
* При использовании отложенного вызова для закрытия файлов, следует учитывать особенности работы файловых систем и
  предпочитать отчет об ошибке операции чтения/записи файла перед отчетом об ошибке закрытия файла, чтобы более точно
  определить причину возникновения проблем.