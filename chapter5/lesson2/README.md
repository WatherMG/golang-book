# 5.2 Рекурсия

Функции могут быть рекурсивными, т.е. могут вызывать сами себя прямо или косвенно. Рекурсия является мощным инструментом
для решения множества задач и, конечно, необходима для обработки рекурсивных структур данных. В разделе 4.4
использовалась рекурсия по дереву для реализации простой сортировки вставкой. В этом разделе она используется для
обработки HTML-документов.

В примере (см. комментарии к findlinks1.go) используется нестандартный пакет `golang.org/x/net/html`, который
предоставляет синтаксический анализатор HTML. Репозитории `golang.org/x/...` хранят пакеты, разработанные и
поддерживаемые командой Go для приложений, таких как сети, обработка текста на разных языках, мобильные платформы,
манипуляции с изображениями, криптография и инструменты разработчика. Эти пакеты не входят в стандартную библиотеку,
потому что они все еще находятся в стадии разработки и оказываются редко нужными большинству программистов на Go.

Необходимые нас части API golang.org/x/net/html показаны ниже. Функция `html.Parse` считывает последовательность байтов,
выполняет ее синтаксический анализ и возвращает корень дерева документа HTML, который имеет тип `html`.
`Node.HTML` имеет узлы нескольких разновидностей - текст, комментарии и т.д., - но сейчас мы сосредоточим внимание
только
на узлах **_элементов_** вида `<name key='value'>`

Функция `main` (см. findlinks1.go) выполняет синтаксический анализ данных со стандартного входа как HTML, извлекая
ссылки с использованием рекурсивной функции `visit`, и выводит каждую найденную ссылку.

Функция `visit` обходит дерево узлов HTML, извлекает ссылки из атрибута `href` каждого элемента `<a href='...'`,
добавляет ссылки в срез строк и возвращает результирующий срез.

Для спуска по дереву для узла `n` функция `visit` рекурсивно вызывает себя для каждого из дочерних узлов `n`, которые
хранятся в связанном списке `FirstChild`.

Запустим `findLinks1` для начальной страницы Go, передав выход программы `fetch` (раздел 1.5) на вход findlinks.

Пример вывода функции `findlinks1`:

``` 
$ go build ..\..\chapter1\lesson5\fetch.go
$ go build .\findlinks1.go
$ .\fetch https://golang.org | .\findlinks1
#
/doc/
/pkg/
/help/
/blog/
http://play.golang.org/
//tour.golang.org/
https://golang.org/dl/
//blog.golang.org/
/LICENSE
/doc/tos.html
http://www.google.com/intl/en/policies/privacy/
```

Внимание на разнообразие видов ссылок, которые появляются на странице. Позже мы увидим, как разрешать их относительно
базового URL, https://golang.org, чтобы получать абсолютные URL.

Приведенная программа (см. outline.go) использует рекурсию по дереву узлов HTML для вывода наброска структуры дерева.
Когда программа встречает каждый элемент, она помещает дескриптор элемента в стек, а затем выводит стек.

Хотя `outline` "заталкивает" элемент в `stack`, соответствующей функции для снятия элемента со стека нет. Когда функция
` outline` рекурсивно вызывает саму себя, вызываемая функция получает **_копию `stack`_**. Хотя вызываемая функция может
добавлять элементы в этот срез, изменяя базовый массив, и, возможно, даже выделяет новый массив, она не изменяет
исходные элементы, видимые вызывающей функции. Поэтому при возврате из функции `stack` вызывающей функции остается таким
же, как и до вызова.

Пример вывода функции `outline`:

```
$ go build .\outline.go
$ ./fetch https://golang.org | ./outline
[html]
[html head]
[html head meta]
[html head title]
[html head link]
[html body]
[html body div]
[html body div]
[html body div div]
[html body div div form]
[html body div div form div]
[html body div div form div a]
```

Как можно увидеть, экспериментируя с функцией `outline`, большинство документов HTML могут быть обработаны только с
несколькими уровнями рекурсии. Однако, не так уж трудно создать патологические веб-страницы, которые потребуют
чрезвычайно глубокой рекурсии.

Многие реализации языка программирования используют стек вызовов функций фиксированного размера. Типичные размеры
колеблются от 64 Кбайт до 2 Мбайт.

Фиксированный размер стека ограничивает глубину рекурсии, так что надо быть осторожным, чтобы избежать
**_переполнения стека_** при рекурсивном обходе больших структур данных. Фиксированный размер стека может даже создать
угрозу безопасности. К счастью, типичные реализации Go используют стеки переменного размера, которые, начинаясь с малого
размера, могут вырастать по мере необходимости до гигабайтных величин.

Это позволяет безопасно использовать рекурсию и не беспокоится о переполнении стека.

## Выводы:

* Рекурсия - это возможность функции вызывать саму себя, что является мощным инструментом для решения многих задач.
* В Go рекурсия используется для обработки деревьев, в том числе для сортировки и обработки HTML-документов.
* Пакет golang.org/x/net/html предоставляет синтаксический анализатор HTML для Go и используется для извлечения информации
из HTML-документов.
* Проблему переполнения стека в рекурсии в Go решается использованием стека переменной длины, который позволяет выделять
дополнительную память по мере необходимости.