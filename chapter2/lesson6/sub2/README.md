# 2.6.2 Инициализация пакетов

Инициализация пакета начинается с инициализации переменных уровня пакета в том порядке, в котором они объявлены, за
исключением того, что сначала разрешаются зависимости:

``` go
var a = b + c // a инициализируется третьей, значением 3
var b = f() // b инициализируется второй, значением 2 из вызова f
var c = 1 // c инициализируется первой, значением 1

func f() int { return c + 1 }
```

Если пакет имеет несколько `.go` файлов, они инициализируются в том порядке, в котором файлы были переданы компилятору;
инструмент `go` сортирует `.go` файлы по имени перед вызовом компилятора.

Каждая переменная, объявленная на уровне пакета, начинает существование со значением, равным значению инициализирующего
выражения(если таковое имеется). Но для некоторых переменных, таких как таблицы данных, инициализирующие выражение может
быть не самым простым средством задания начального значения. В этом случае проще может оказаться механизм
функции `init`.
Любой файл может содержать любое количество функций, объявление которых имеет вид:

``` go
func init() { /*...*/ }
```

Такие функции `init` нельзя вызывать или обратиться к ним, но во всех прочих отношениях они являются нормальными
функциями. В каждом файле функции `init` выполняются автоматически при запуске программы в том порядке, в котором они
объявлены.

Инициализация выполняется по одному пакету за раз в порядке объявлений импорта в программе. Первыми обрабатываются
зависимости, поэтому пакет `p`, импортирующий пакет `q`, может быть уверен, что `q` будет полностью инициализирован до
начала инициализации пакета `p`. **_Инициализация выполняется снизу вверх_**. Последним инициализируется пакет `main`.
Таким образом все пакеты оказываются полностью инициализированными до начала выполнения функции `main` приложения.

Приведенный пакет (см. popcount.go) определяет функцию `PopCount()`, она возвращает число установленных битов (т.е. битов,
значение которых = 1) в значение типа `uint64`.
Она использует функцию `init` для предварительного вычисления таблицы результатов `pc` для всех возможных 8-битовых
значений, так что функции `PopCount` нужно не выполнять 64 шага, а просто вернуть сумму восьми значений из таблицы. (Это
не самый быстрый алгоритм подсчета битов, нужен для демонстрации).

> Цикл `range` в функции `init` использует только индекс: значение не является необходимым и потому не включено. Этот
> цикл можно записать следующим образом:
``` go
for i, _ := range pc {
    //...
}
```