# 2.6 Пакеты и файлы

Пакеты в Go служат тем же целям, что и библиотеки или модули в других языках программирования, поддерживая модульность,
инкапсуляцию, раздельную компиляцию и повторное использование.
Исходный текст пакета располагается в одном или нескольких файлах `.go`, обычно в каталоге, имя которого является
окончанием пути импорта. Например, файлы пакета `golp.io/ch1/helloworld` располагаются в
каталоге `$GOPATH/src/gopl.io/ch1/helloworld`.

Каждый пакет служит в качестве отдельного **_пространства имен_** для своих объявлений.

В пакете `image`, например, идентификатор `Decode` относится к функции, отличной от той, на которую указывает
идентификатор в пакете `unicode/utf16`. Чтобы обратиться к функции за пределами ее пакета, следует **_квалифицировать_**
идентификатор, явно указав, что имеется ввиду: `image.Decode()` или `utf16.Decode()`.

Пакеты также позволяют скрывать информацию, управляя тем, какие имена видны за пределами пакета (**_экспортированы_**).
В Go тем, какие идентификаторы экспортируются, а какие - нет, управляет очень простое правило:
> Экспортируются идентификаторы, которые начинаются с прописной буквы.

Далее создадим пакет `tempconv` (см. lesson6/conv.go и lesson6/tempconv.go)

В файле `tempconv.go` хранятся объявления типов, констант и методов.
В файле `conv.go` хранятся функции преобразования.

Каждый файл начинается с объявления `package`, которе определяет имя пакета. При импорте пакета к его членам следует
обращаться как к `tempconv.CToF()`, и т.д. Имена уровня пакета, такие как типы и константы, объявленные в одном файле
пакета, являются видимыми для всех других файлов пакета, как если бы весь исходный код располагался в единственном
файле.
> `tempconv.go` импортирует пакет `fmt`, но `conv.go` этого не делает, так как не использует ничего из пакета `fmt`.

Поскольку имена констант уровня пакета начинаются с прописных букв, они доступны и с помощью **_квалифицированных
имен_**, такими как `tempconv.AbsoluteZeroC`:

``` go
fmt.Printf("Брррр! %v\n", tempconv.AbsoluteZeroC) // "Брррр! -273.15°C"
```

Чтобы преобразовать температуру по Цельсию в температуру по Фаренгейту в пакете, который
импортирует `../lesson6/tempconv.go`, можно написать следующий код:

``` go
fmt.Println(tempconv.CToF(tempconv.BoilingC)) // "212°F"
```

Комментарий, предшествующий объявлению `package`, документирует пакет в целом. По соглашению он должен начинаться с
резюмирующего предложения в стиле, показанном в примере `tempconv.go`. В каждом пакете только один файл должен иметь
такой **_документирующий комментарий_**. Обширные документирующие комментарии часто помещаются в отдельный файл, по
соглашению именуемый `doc.go`.

## Выводы:

* Пакеты в Go поддерживают модульность, инкапсуляцию, раздельную компиляцию и повторное использование;
	* `Модульность` - это подход к созданию программных систем, в котором каждая функциональность реализуется в
	  отдельных модулях, связанных между собой через определенные интерфейсы;
	* `Инкапсуляция` - это механизм, который позволяет скрыть детали реализации модуля от других компонентов системы,
	  обеспечивая доступ только к определенным элементам модуля;
	* `Раздельная компиляция` - это процесс, при котором каждый модуль может редактироваться и компилироваться отдельно,
	  минимизируя время компиляции и облегчая обновление системы;
	* `Повторное использование` - это возможность использовать уже написанные и отлаженные модули в новых приложениях,
	  что ускоряет их разработку и повышает надежность.
* Исходный текст пакета располагается в одном или нескольких файлах `.go`, обычно в каталоге с соответствующим именем;
* Каждый пакет служит в качестве отдельного пространства имен для своих объявлений;
* Чтобы обратиться к функции за пределами ее пакета, следует квалифицировать идентификатор, например `image.Decode()`
  или `utf16.Decode()`;
* В Go экспортируются идентификаторы, которые начинаются с прописной буквы;
* Каждый файл пакета начинается с объявления `package`, которое определяет имя пакета;
* Имена уровня пакета, объявленные в одном файле пакета, являются видимыми для всех других файлов пакета;
* Пакеты могут иметь документирующий комментарий, который предшествует объявлению `package` и начинается с резюмирующего
  предложения. Обычно только один файл пакета имеет такой комментарий, иногда помещают его в отдельный файл `doc.go`.