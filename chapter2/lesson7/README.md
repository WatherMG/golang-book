# 2.7 область видимости

Объявление связывает имя с сущностью в программе, такой как функция или переменная. **_Область видимости_** является
частью исходного кода, в которой использование объявленного имени ссылается на сущность из этого объявления.

> Область видимости - это область исходного кода программы, оно является свойством времени **_компиляции_**.
>
> Временем жизни переменной называют диапазон времени выполнения, когда к переменной можно обращаться из других частей
> программы. Время жизни - свойство времени **_выполнения_**.

**_Синтаксический блок_** представляет собой последовательность инструкций, заключенных в фигурные скобки, подобные тем,
которые окружают тело функции или цикла.
Имя, объявленное внутри синтаксического блока, не видимо вне блока. Блок охватывает свои объявления и определяет их
область видимости. Можно обобщить это понятие блоков, включив в него другие группы объявлений, которые не охватываются
фигурными скобками в исходном тексте явно. Будем называть их **_лексическими блоками_**.
Существуют **_лексические блоки_**:

* для всего исходного кода - именуется **_всеобщий блок (universe block)_**;
* блок для каждого пакета;
* для каждого файла;
* для каждой инструкции `for`, `if`, `switch`
* для каждого `case` в конструкции `switch` или `select`
* для каждого явного синтаксического блока.

Лексический блок объявления определяет его область видимости, которая может быть большой или малой:

* Объявления встроенных типов, функций и констант наподобие `int`, `len`, `true` находятся во **_всеобщем блоке_**, и
  обратиться к ним можно на протяжении всей работы программы.
* К объявлениям **_вне любой функции_**, т.е. на **_уровне пакета_**, можно обратиться из любого файла в том же самом
  пакете.
* Импортированные пакеты, такие как `fmt` и др., объявляются на **_уровне файлов_**, так что к ним можно обращаться из
  того же файла, но не из другого файла в том же пакете без отдельной директивы `import`. (То есть нужно, в любом
  случае, импортировать в каждый файл).
* Многие объявления, подобно объявлению переменной `c` в функции `tempconv.CToF`, являются локальными, а потому
  обращаться к ним можно только в пределах той же функции (или, возможно, только ее части).
  https://github.com/WatherMG/golang-book/blob/edc5ccd4729b5a7ebbc35bfe57550dbf0cbe0780/chapter2/lesson6/tempconv/conv.go#L7-L10
* Область видимости метки управления потоком, используемой инструкциями `break`, `continue`, `goto` - является вся
  охватывающая функция.

Программа может содержать несколько объявлений одного и того же имени при условии, что все объявления находятся в
различных лексических блоках.
Например, можно объявить локальную переменную с тем же именем, что и переменная уровня пакета или можно объявить
параметр функции с именем `new`, даже несмотря на то, что функция с этим именем является объявленной во всеобщем блоке.
Тут главное не переусердствовать - чем больше область видимости переопределения, тем больше шансов запутать других
людей, которые будут читать код.

Компилятор, встретив ссылку на имя, ищет объявление, начиная с наиболее глубоко вложенного внутреннего лексического
блока и продолжая до всеобщего блока.
Если компилятор не обнаруживает объявление, он сообщает об ошибке `undeclared name`. Если имя объявлено и в наружном, и
во внутреннем блоках, первым будет обнаружено внутреннее объявление. В этом случае говорят, что внутреннее объявление
**_затеняет (shadow)_** или **_скрывает (hide)_** внешнее, делая его недоступным:

``` go
func f () {}

var g = "g"

func main() {
    f := "f"
    fmt.Println(f) // "f"; локальная переменная f затеняет функицю f уровня пакета
    fmt.Println(g) // "g"; переменная уровня пакета
    fmt.Println(h) // Compilation error; undeclared name `h`
}
```

Внутри функции лексические блоки могут быть вложенными с произвольной глубиной вложения, поэтому одно локальное
объявление может затенять другое.
Большинство блоков создаются конструкциями управления потоком, такими как инструкции `if` и циклы `for`. Приведенная
ниже программа имеет три различных переменных `x`, так как все объявления появляются в различных лексических блоках.
(Этот пример иллюстрирует правила областей видимости, но не хороший стиль программирования!)

``` go
func main () {
    x := "hello!"
    for i := 0; i < len(x); i++ {
        x := x[i]
        if x != '!' {
            x := x + 'A' - 'a'
            fmt.Printf("%c", x) // "HELLO" (по букве за итерацию)
        }
    }
}
```

выражения `x[i]` и `x + 'A' - 'a'` - ссылаются на объявления `x` из внешнего блока (второе выражение **_не_**
эквивалентно вызову `unicode.ToUpper()`).

Как упоминалось выше, не все лексические блоки соответствуют последовательностям операторов, помещенным в фигурные
скобки. Некоторые из них просто подразумеваются.
Цикл `for` в коде выше создает два лексических блока:

* явный блок для тела цикла
* неявный блок, который дополнительно охватывает переменные, объявленные в инициализации цикла (переменная `i`).

Областью видимости переменной `i` являются условие `i < len(x)`, последействие `i++` и тело цикла `for`.

В коде ниже имеется три переменные `x`, каждая из которых объявлена в своем блоке (только два из этих блоков указаны
явно):

* в теле функции
* в блоке цикла `for`
* в теле цикла

``` go
func main() {
    x := "hello" // явное объявление
    for _, x := range x { // неявное объявление
        x := x + 'A' - 'a' // явное объявление
        fmt.Printf("%c", x) // "HELLO" (по букве за итерацию)
  }
}
```

Подобно циклам `for`, инструкции `if` и `switch` также создают неявные блоки в дополнение к блокам их тел.
Следующий код показывает области видимости `x` и `y` в цепочке `if-else`:

``` go
if x:= f(); x == 0 {
    fmt.Println(x)
} else if y := g(x); x == y {
    fmt.Println(x, y)
} else {
    fmt.Println(x, y)
}
fmt.Println(x, y) // Compile error: x, y - Unresolved reference
```

Вторая инструкция `if` (`else if`) вложена в первую, так что переменные, объявленные внутри инициализатора первой
инструкции, видимы внутри второй инструкции. Аналогичные правила применяются и для каждого `case` инструкции `switch`:
имеется блок для условия и блок для каждого тела `case`.

На уровне пакета порядок, в котором появляются объявления, не влияет на их область видимости. Поэтому объявление может
ссылаться само на себя или на другое объявление, которое следует за ним. Это позволяет нам объявлять рекурсивные или
взаимно рекурсивные типы и функции. Однако компилятор сообщит об ошибке, если объявление константы или переменной
ссылается само на себя:

``` go
if f, err := os.Open(fname); err != nil { // Ошибка компиляции: неиспользуемая переменная `f`
    return err
}
f.Stat() // Ошибка компиляции: неопределенная переменная `f`
f.Close() // Ошибка компиляции: неопределенная переменная `f`
```

В коде выше, областью видимости `f` является только инструкция `if`, так что переменная `f` недоступна для инструкций,
следующих далее, что приводит к ошибке компиляции.
В зависимости от используемого компилятора можно получить дополнительное сообщение об ошибке, говорящее о том, что
переменная `f` нигде не используется.

Таким образом, часто приходится объявлять переменную `f` до условия, чтобы она была доступна после него:

``` go
f, err := os.Open(fname)
if err != nil {
    return err
}
f.Stat()
f.Close()
```

> Может показаться соблазнительной возможность избежать объявления `f` и `err` во внешнем блоке, перемещая вызовы
> методов `Stat()` и `Close()` внутрь блока `else`:

``` go
if f, err := os.Open(fname); err != nil {
    return err
} else {
    // f и err видимы здесь
    f.Stat()
    f.Close()
}
```

> Однако, практика программирования в Go заключается в работе с ошибкой в конструкции `if` с последующим
> выходом из функции так, чтобы успешный путь выполнения не сопровождался отступом.

Краткие объявления переменных требуют понимания области видимости.

Код ниже - начинается с получения текущего рабочего каталога и его сохранения в переменную уровня пакета. Это может быть
сделано с помощью вызова `os.Getwd()` в функции `main`, но может быть лучше отделить это действие от основной логики
программы, в особенности если невозможность получить рабочий каталог является фатальной ошибкой.
Функция `log.Fatalf()` выводит соответствующее сообщение и вызывает `os.Exit(1)`.

``` go
var cwd string
func init() {
    cwd, err :=  os.Getwd() // Ошибка компиляции: cwd не используется (эти переменные локальные)
    if err != nil {
        log.Fatalf("Ошибка os.Getwd(): %v", err)
    }
}
```

Так как ни `cwd`, ни `err` не объявлены в блоке функции `init`, оператор `:=` объявляет обе эти переменные как
локальные. Внутреннее объявление `cwd` делает внешнее недоступным, поэтому данная инструкция не обновляет значение
переменной уровня пакета `cwd`, как предполагалось.

Нынешние компиляторы Go обнаруживают, что локальная переменная `cwd` никогда не используется и сообщают об этом как об
ошибке. Но они не обязаны выполнять эту проверку в обязательном порядке. Кроме того, незначительные изменения, такие как
добавление инструкции вывода в консоль значения локальной переменной `cwd` лишили бы это проверку смысла.

``` go
var cwd string
func init() {
    cwd, err := os.Getwd() // Примечание: неверно!
    if err != nil {
        log.Fatalf("Ошибка os.Getwd(): %v", err)
    }
    log.Printf("Рабочий каталог = %s", cwd)
}
```

Глобальная переменная `cwd` остается неинициализированной, и кажущийся корректным вывод в журнал только скрывает ошибку.

Существует ряд способов справиться с этой потенциальной проблемой. Самый простой из них - избежать оператора `:=`,
объявив `err` в отдельном объявлении `var`:

``` go
var cwd string
func init() {
    var err error
    cwd, err = os.Getwd()
    if err != nil {
        log.Fatalf("Ошибка os.Getwd(): %v", err)
    }
}
```

## Выводы:

* Область видимости - часть исходного кода, где объявленное имя ссылается на сущность из этого объявления. Является
  свойством времени компиляции;
* Время жизни переменной - диапазон времени выполнения, когда к переменной можно обращаться из других частей программы.
  Является свойством времени **_выполнения_**;
* Синтаксический блок - последовательность инструкций, заключенных в фигурные скобки (тело функции, цикла и т.д.);
* Лексические блоки - группы объявлений, определяющие область видимости имени (всеобщий блок, уровень пакета, уровень
  файла, блоки конструкций `for`, `if` и `switch`, `case` в `switch` или `select`, явные синтаксические блоки);
* `Всеобщий блок` - область видимости встроенных типов, функций и констант (`int`, `len`, `true` и т.д.), доступны на
  протяжении всей работы программы;
* `Уровень пакета` - область видимости объявлений вне любой функции, доступны из любого файла в том же пакете;
* `Уровень файла` - область видимости импортированных пакетов, доступны только в том же файле;
* `Локальные объявления` - область видимости ограничена пределами функции или ее части;
* Область видимости `метки` управления потоком - вся охватывающая функция;
* Внутреннее объявление затеняет или `скрывает` внешнее, если имя объявлено и во внутреннем, и во внешнем блоках;
* Внутри функции лексические блоки могут быть вложенными с произвольной глубиной вложения, одно локальное объявление
  может затенять другое;
* Цикл `for` создает два лексических блока: `явный блок для тела цикла` и `неявный блок, охватывающий переменные,
  объявленные в инициализации цикла`;
* В Go порядок объявления переменных не влияет на их область видимости на уровне пакета, что позволяет создавать
  рекурсивные и взаимно рекурсивные типы и функции;
* Область видимости переменных, объявленных в циклах `for`, инструкциях `if` и `switch`, ограничивается только их
  блоками, что может привести к ошибкам компиляции при обращении к ним вне этих блоков;
* Часто требуется объявлять переменные до условия, чтобы они были доступны после него, что предотвращает ошибки
  компиляции из-за использования неправильной области видимости;
* Чтобы избежать ошибок из-за использования краткого объявления переменных, можно объявлять переменные в отдельном блоке
  `var`, что позволяет правильно настроить их область видимости;
* Понимание области видимости переменных в Go позволяет избегать ошибок и создавать корректно работающие программы.

