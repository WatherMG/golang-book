# 2.3.2 Указатели

Переменная - небольшой блок памяти, который содержит значение. Переменные, созданные с помощью объявлений,
идентифицируются по имени, например `x`, но, многие переменные идентифицируются только с помощью
выражений: `x[i]`, `x.f`. Эти выражения считывают значение переменной, если находятся в правой части, от оператора
присваивания. В случае, если выражение находится в левой части - переменной присваивается новое значение.

Значение **_указателя_** представляет собой адрес переменной. Таким образом, указатель - это местоположение в памяти,
где хранится значение. Не всякое значение имеет адрес, но его имеет любая переменная. С помощью указателя можно
считывать или изменять значение переменной _косвенно_, не используя (и даже не зная) ее имя, если оно у нее есть.

Если переменная объявлена как `var x int`, выражение `&x`("адрес х") дает указатель на целочисленную переменную, т.е.
значение типа `*int`, который произносится как **_"указатель на int"_**.
Если это значение называется `p`, принято говорить - **_"p указывает на x"_**, или, **_"p содержит адрес x"_**.
Переменная, на которую указывает `p`, записывается как `*p`. Выражение `*p` дает значение этой переменной `int`, но
поскольку выражение `*p` обозначает переменную, оно может использоваться и в левой части присваивания, и, в этом случае,
присваивание обновляет данную переменную.

```go
package main

import "fmt"

func main() {
	x := 1
	p := &x         // p имеет тип *int и указывает на x
	fmt.Println(*p) // "1"
	*p = 2          // Эквивалентно присваиванию x = 2
	fmt.Println(x)  // "2"
}
```

Каждый компонент переменной составного типа - поле структуры или элемент массива - также является переменной, а значит,
имеет свой адрес.

Переменные иногда описываются как **_адресуемые_** значения. Оператор **_получения адреса `&`_** может быть применен
только к переменным. Выражения описывающие переменные, являются единственными выражениями, к которым может быть применен
оператор получения адреса `&`.

Нулевое значение указателя любого типа равно `nil`. Проверка `p != nil` - истина, если `p` указывает на переменную.
Указатели можно сравнивать; два указателя равны тогда и только тогда, **_когда они указывают на одну и ту же переменную
или когда они оба равны `nil`._**

```go
package main

import "fmt"

func main() {
	var x, y int
	fmt.Println(&x == &x, &x == &y, &x == nil) // true, false, false
}
```

Функция совершенно безопасно может вернуть адрес локальной переменной. Например, в приведенном ниже коде, локальная
переменная `v`, созданная этим конкретным вызовом `f()`, будет существовать даже после возврата из функции, и
указатель `p` будет по прежнему указывать на нее:

``` go
package main

func main() {
	var p = f()
}

func f() *int {
	v := 1
	return &v
}
```

Все вызовы `f()` возвращают различные значения:
`fmt.Println(f() == f()) // "false"`

Поскольку указатель содержит адрес переменной, передача указателя в функцию в качестве аргумента делает возможным
обновление переменной, косвенно переданной в функцию.
Например, код ниже увеличивает переменную, на которую указывает ее аргумент и возвращает новое значение переменной, так,
что оно может использоваться в выражении:

``` go
package main

import "fmt"

func incr(p *int) int {
	*p++ // Увеличивает значение, на которое указывает p
	// при этом не изменяет значение p
	return *p
}

func main() {
	v := 1
	incr(&v)              // v теперь равно 2
	fmt.Println(incr(&v)) // "3" (и v становится равным 3)
}
```

Каждый раз, получая адрес переменной или копируя указатель, мы создаем новые **_псевдонимы_**, или способы идентификации
одной и той же переменной. Например `*p` - это псевдоним для `v`. Псевдонимы-указатели полезны, т.к. позволяют получить
доступ к переменной без использования ее имени, но это палка о двух концах: чтобы найти все инструкции, которые
обращаются к переменной, необходимо знать все ее псевдонимы. Это не просто указатели, которые создают псевдонимы.
Псевдонимы также создаются, когда мы копируем значения других ссылочных типов (наподобие срезов, карт и каналов), а
также структуры, массивы и интерфейсы, которые содержат эти типы.

Указатели являются ключом к пакету `flag`, который использует аргументы командной строки программы для установки
значений некоторых переменных, распределенных по всей программе. Для иллюстрации код (см echo4.go) принимает два
необязательных флага: - `-n` заставляет `echo` пропустить завершающий символ новой строки `\n`, который обычно
выводится, а `-s sep` - заставляет программу разделять выводимые аргументы содержимым строки `sep` вместо используемого
по-умолчанию одного символа пробела.

Функция `flag.Bool()` создает новую переменную-флаг типа bool. Она принимает три аргумента: **имя флага (`"n"`),
значение переменной по умолчанию (`false`) и сообщение**, которое выводится, если пользователь предоставит неверный
аргумент, некорректный флаг или флаг `h` или `help`. Аналогично функция `flag.String()` получает имя, значение по
умолчанию и сообщение, и создаем переменную типа `string`.
Переменные `sep` и `n` являются указателями на переменные-флаги, доступ к которым осуществляется косвенно, как к `*sep`
и `*n.

Запускаемая программа должна вызвать `flag.Parse` до использования флагов, чтобы переменные-флаги получили новые
значения, отличные от дефолтных значений. Аргументы, не являющиеся флагами, доступны через `flag.Args()` как срез строк.
Если функция `flag.Parse()` сталкивается с ошибкой, она выводит сообщение об использовании программы и
вызывает `os.Exit(2)`для ее завершения.

Оператор `&` - позволяет получить адрес переменной. Оператор `*` позволяет получить значение из адреса переменной.

## Выводы:

* Переменные в Go представляют собой небольшие блоки памяти, хранящие значение;
* Указатели в Go - это переменные, `хранящие адрес` другой переменной;
* Оператор `&` позволяет получить адрес переменной, а оператор `*` позволяет получить значение из адреса переменной;
* Значение указателя может быть равно `nil`, если указатель `не указывает ни на одну переменную`;
* Указатели могут быть использованы для косвенного изменения значений переменных (через
  указатель `s := 1; w := &s; *w = 10; fmt.Println(s==10) // true`);
* Передача указателя в функцию позволяет `обновить значение переменной`, косвенно переданной в функцию;
* Указатели могут создавать псевдонимы переменных, что делает доступ к переменной возможным без использования её имени;
* Использование указателей является ключом к пакету `flag`, который позволяет управлять аргументами командной строки
  программы;
* Чтобы использовать переменные-флаги, необходимо вызвать функцию `flag.Parse` перед их использованием, доступ к
  значению происходит по `*flag`.