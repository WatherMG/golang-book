# 2.3.3 Функция new

Еще одним способом создания переменной является применение встроенной функции new. Выражение `new(T)` создает
**_неименованную переменную_** с типом `Т`, инициализирует ее нулевым значением типа `Т` и возвращает ее адрес, который
представляет собой значение с типом `*Т`.

``` go
package main

import "fmt"

func main() {
	p := new(int) // p, имеющий тип *int, указывает на неименованную переменную типа int

	fmt.Println(*p) // "0"
	*p = 2          // устанавливает значение этой переменной равным 2
	fmt.Println(*p) // "2"
}
```

Переменная, созданная с помощью `new`, ничем не отличается от обычной локальной переменной, у которой берется адрес, за
исключением того, что нет необходимости придумывать (и объявлять) ее имя и можно использовать в выражении `new(T)`.
Таким образом, `new` является только лишь синтаксическим удобством, но не фундаментальным понятием: две приведенные ниже
функции имеют идентичное поведение:

``` go
package main

func newInt() *int {
	return new(int)
}

func newInt() *int {
	var dummy int
	return &dummy
}
```

Каждый вызов `new` возвращает переменную, отличную от предыдущих, с уникальным адресом:

``` go
package main

import "fmt"

func main() {
	p := new(int)
	q := new(int)
	fmt.Println(p == q) // false
}
```

Существует одно исключение из этого правила: **_две переменные, тип которых не несет никакой информации_**, а потому
имеющие нулевой размер, такие как `struct{}` или `[0]int`, могут, в зависимости от реализации, иметь один и тот же
адрес.

Функция `new` используется относительно редко, поскольку наиболее распространены неименованные переменные структурных
типов, для которых имеется более гибкий литеральный синтаксис.

Поскольку `new` является предопределенной функцией, а не ключевым словом, это имя можно переопределить для чего-то
другого в функции, например:

``` go
package main

func delta(old, new int) int {
	return new - old // внутри delta встроенная функция `new` недоступна
}

```

