# 2.4.2 Присваиваемость

Операторы присваивания представляют собой явную форму присваивания, но в программе есть много мест, в которых
присваивание происходит **_неявно_**:

* вызов функции неявно присваивает значения аргументов соответствующим переменным параметров;
* инструкция `return` **_неявно_** присваивает операнды `return` соответствующим результирующим переменным;
* литеральное выражение для составного типа, такое как срез

``` go
medals := []string{"gold", "silver", "bronze"} 
```

**_Неявно_** присваивает каждый элемент, как если бы оно было записано как:

``` go
medals[0] = "gold"
medals[1] = "silver"
medals[2] = "bronze"
```

Элементы карт и каналы, хотя и не являются обычными переменным, также оказываются субъектами подобных неявных
присваиваний.

Присваивание, **_явное или неявное_**, всегда корректно, если левая части (переменная) и правая часть (значение) имеют
один и тот же тип. В целом, присваивание разрешено, только если значение **_присваиваемо (assignable)_** типу
переменной.

Правило **_присваиваемости_** имеет свои частные случаи для каждого типа.
Для типов, которые рассматривались до сих пор, правило простое:

> Типы должны точно соответствовать (переменной и значения), но значение `nil` может быть присвоено любой переменной
> типа `интерфейса` или `ссылочного типа`.

Константы имеют более гибкие правила присваиваемости, которые позволяют избежать большинства явных преобразований.

Вопрос о том, можно ли **сравнивать** два значения с помощью операторов `==` и `!=` связан с присваиваемостью:
в любых сравнениях первый операнд должен быть присваиваемым типу второго операнда, и наоборот. **_(Чтобы сравнить два
значения, они должны иметь одинаковый тип)_**

## Выводы:

* Присваивание в программировании может быть явным и неявным, но в любом случае значение должно быть присваиваемо типу
  переменной;
* Неявное присваивание происходит, например, при вызове функции, инструкции `return` или литеральных выражениях для
  составных типов;
* Присваивание считается корректным, когда типы переменной и значения точно соответствуют, однако значение `nil` может
  быть присвоено любой переменной интерфейсного или ссылочного типа;
* Правила присваиваемости для констант более гибкие, что позволяет избежать большинства явных преобразований типов;
* Вопрос о возможности сравнения двух значений с помощью операторов `==` и `!=` также связан с присваиваемостью: оба
  операнда должны быть присваиваемы друг другу, то есть иметь одинаковый тип;
* Понимание правил присваиваемости помогает писать корректный код и избегать ошибок, связанных с несоответствием типов.