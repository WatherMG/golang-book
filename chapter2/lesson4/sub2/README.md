# 2.4.2 Присваиваемость

Операторы присваивания представляют собой явную форму присваивания, но в программе есть много мест, в которых
присваивание происходит **_неявно_**:

* вызов функции неявно присваивает значения аргументов соответствующим переменным параметров;
* инструкция `return` **_неявно_** присваивает операнды `return` соответствующим результирующим переменным;
* литеральное выражение для составного типа, такое как срез

``` go
medals := []string{"gold", "silver", "bronze"} 
```

**_Неявно_** присваивает каждый элемент, как если бы оно было записано как:

``` go
medals[0] = "gold"
medals[1] = "silver"
medals[2] = "bronze"
```

Элементы карт и каналы, хотя и не являются обычными переменным, также оказываются субъектами подобных неявных
присваиваний.

Присваивание, **_явное или неявное_**, всегда корректно, если левая части (переменная) и правая часть (значение) имеют
один и тот же тип. В целом, присваивание разрешено, только если значение **_присваиваемо (assignable)_** типу
переменной.

Правило **_присваиваемости_** имеет свои частные случаи для каждого типа.
Для типов, которые рассматривались до сих пор, правило простое:

> Типы должны точно соответствовать (переменной и значения), но значение `nil` может быть присвоено любой переменной
> типа `интерфейса` или `ссылочного типа`.

Константы имеют более гибкие правила присваиваемости, которые позволяют избежать большинства явных преобразований.

Вопрос о том, можно ли **сравнивать** два значения с помощью операторов `==` и `!=` связан с присваиваемостью:
в любых сравнениях первый операнд должен быть присваиваемым типу второго операнда, и наоборот. **_(Чтобы сравнить два
значения, они должны иметь одинаковый тип)_**