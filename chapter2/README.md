# Структура программы

В Go, как и в любом другом языке программирования, большие программы строятся из небольшого набора базовых конструкций.
Переменные хранят значения. Простые выражения объединяются в более сложные с помощью операций, таких как сложение или
вычитание. Базовые типы собираются в агрегаты, такие как массивы и структуры. Выражения используются в инструкциях,
порядок выполнения которых определяется инструкциями управления потоком выполнения, такими как `if` или `for`.
Инструкции сгруппированы в функции дл изоляции от прочего кода и повторного использования. Функции собираются в исходные
файлы и пакеты.

В этой главе рассматриваются основные структурные элементы программы Go.

# Выводы к главе:

<!-- TOC -->

* [2.1. Имена](#21-имена)
* [2.2. Объявления](#22-объявления)
* [2.3. Переменные](#23-переменные)
	* [2.3.1 Краткое объявление переменной](#231-краткое-объявление-переменной)
	* [2.3.2 Указатели](#232-указатели)
	* [2.3.3 Функция new](#233-функция-new)
	* [2.3.4 Время жизни переменных](#234-время-жизни-переменных)
* [2.4. Присваивания](#24-присваивания)
	* [2.4.1 Присваивание кортежу](#241-присваивание-кортежу)
	* [2.4.2 Присваиваемость](#242-присваиваемость)
* [2.5. Объявления типов](#25-объявления-типов)
* [2.6. Пакеты и файлы](#26-пакеты-и-файлы)
	* [2.6.1 Импорт](#261-импорт)
	* [2.6.2 Инициализация пакетов](#262-инициализация-пакетов)
* [2.7. Область видимости](#27-область-видимости)

<!-- TOC -->
____

## 2.1. Имена

* Имена функций, переменных, констант, типов, меток инструкций и пакетов в Go должны начинаться с буквы (считается
  буквой в `Unicode`) или с подчеркивания и могут содержать любое количество дополнительных букв, цифр и подчеркиваний;
* Имена чувствительны к регистру: `heapSort` и `Heapsort` - разные имена;
* В Go есть 25 ключевых слов, которые могут использоваться только согласно синтаксису языка и 30 предопределенных имен
  для встроенных констант, типов и функций;
* Имена предопределенных сущностей не являются зарезервированными и могут использоваться в объявлениях;
* Сущности, объявленные внутри функции, являются `локальными`, а объявленные вне функции - `глобальными` для пакета;
* `Регистр первой буквы` имени определяет видимость сущности за пределами пакета: имена, начинающиеся с заглавной буквы,
  `экспортируются`;
* Имена пакетов состоят только из строчных букв;
* В Go принято выбирать короткие имена, особенно для локальных переменных с небольшой областью видимости, но чем больше
  область видимости, тем длиннее и значимее имя должно быть;
* Стилистически в Go используется `camelCase`, а сокращения, такие как `ASCII` и `HTML`, должны быть в одном регистре.

____

## 2.2. Объявления

* В Go есть 4 основные разновидности объявлений: `var`, `const`, `type` и `func`, которые помогают именовать и
  определять свойства программных сущностей;
* Программа на языке Go хранится в файлах с расширением `.go`, состоящих из объявления `package`, объявлений `import` и
  последовательности типов, переменных, констант и функций уровня пакета;
* Объявления уровня пакета видимы во всех файлах пакета, в то время как локальные объявления видны только в пределах
  функции, в которой они объявлены;
* Объявление функции содержит имя, список передаваемых параметров, необязательный список результатов и тело функции с
  операторами, определяющими ее действия;
* Функции могут инкапсулировать логику и быть использованы в нескольких местах программы, что упрощает разработку,
  сопровождение и повторное использование кода.

____

## 2.3. Переменные

* Объявление переменных в Go осуществляется с помощью ключевого слова `var`, после которого указывается имя переменной,
  тип и начальное значение;
* Тип и начальное значение переменной могут быть `опущены, но не одновременно`. При опущенном типе он определяется из
  инициализирующего выражения, при опущенном значении - присваивается нулевое значение для данного
  типа (`var s := 1; var s int`, соответственно);
* Нулевые значения для разных типов: `0` для чисел, `false` для булевых переменных, `""` для строк и `nil` для
  интерфейсов и ссылочных типов. Это гарантирует, что переменные в Go всегда хранят определенные значения своего типа,
  упрощая код и обеспечивая разумное поведение в граничных условиях;
* В одном объявлении можно объявить и инициализировать несколько переменных разных типов (`s, v := 1, "hello"`);
* Инициализаторы переменных могут быть литеральными значениями или произвольными выражениями. Литералы - это
  фиксированные значения, которые не могут быть изменены;
* Переменные уровня пакета инициализируются до начала выполнения функции `main`, а локальные переменные инициализируются
  при встрече их объявления в процессе выполнения функции;
* Множество переменных может быть инициализировано с помощью вызова функции, возвращающей несколько значений. Например,
  функция `os.Open(name)` возвращает файл и ошибку (`var f, err = os.Open(name)`).

____

### 2.3.1 Краткое объявление переменной

* Краткое объявление переменной использует оператор `:=` и позволяет объявить и инициализировать локальные переменные
  без явного указания их типа (`s := i`);
* Краткое объявление переменной определяет тип переменной на основе типа выражения справа от оператора `:=`;
* Можно использовать краткое объявление переменной для нескольких переменных одновременно, например `i, j := 0, 1`;
* Присваивание значений переменным осуществляется через оператор `=`, например, `i, j = j, i` для обмена значений
  переменных `i` и `j`;
* Если переменная уже была объявлена в том же лексическом блоке, то краткое объявление переменной действует как
  присваивание;
* Краткое объявление переменной должно объявлять хотя бы одну новую переменную, иначе код не будет компилироваться;
* Краткое объявление переменной упрощает работу с локальными переменными, делает код более читабельным и понятным.

____

### 2.3.2 Указатели

* Переменные в Go представляют собой небольшие блоки памяти, хранящие значение;
* Указатели в Go - это переменные, `хранящие адрес` другой переменной;
* Оператор `&` позволяет получить адрес переменной, а оператор `*` позволяет получить значение из адреса переменной;
* Значение указателя может быть равно `nil`, если указатель `не указывает ни на одну переменную`;
* Указатели могут быть использованы для косвенного изменения значений переменных (через
  указатель `s := 1; w := &s; *w = 10; fmt.Println(s==10) // true`);
* Передача указателя в функцию позволяет `обновить значение переменной`, косвенно переданной в функцию;
* Указатели могут создавать псевдонимы переменных, что делает доступ к переменной возможным без использования её имени;
* Использование указателей является ключом к пакету `flag`, который позволяет управлять аргументами командной строки
  программы;
* Чтобы использовать переменные-флаги, необходимо вызвать функцию `flag.Parse` перед их использованием, доступ к
  значению происходит по `*flag`.

____

### 2.3.3 Функция new

* Встроенная функция `new(T)` в Go позволяет создать неименованную переменную с типом `T`, инициализировать ее нулевым
  значением и вернуть адрес этой переменной в виде указателя типа `*T`;
* Использование функции `new` удобно, когда нужно создать переменную без необходимости объявлять её имя;
* Неименованная переменная, созданная с помощью функции `new`, ничем не отличается от обычной локальной переменной, у
  которой берется адрес;
* После создания неименованной переменной с помощью функции `new`, её значение можно изменять косвенно через указатель;
* Возвращаемые значения функции `new` имеют уникальные адреса, за исключением переменных с нулевым размером, которые
  могут иметь одинаковые адреса в зависимости от реализации;
* Функция `new` используется относительно редко, так как часто предпочитают использовать литеральный синтаксис для
  создания и инициализации структурных типов (`person := Person{name: "John", age: 30}`);
* Так как `new` является предопределенной функцией, а не ключевым словом, её имя можно переопределить для других целей в
  рамках области видимости пакета.

____

### 2.3.4 Время жизни переменных

* Время жизни переменной - это период, в течение которого она существует в программе;
* Переменные уровня пакета имеют время жизни, равное времени работы всей программы;
* Локальные переменные имеют `динамическое время жизни` и создаются каждый раз при выполнении оператора объявления;
* Параметры и результаты функций являются `локальными переменными` и создаются при каждом вызове функции;
* Go использует алгоритм сборки мусора, основанный на отслеживании `ссылок на переменные`, что позволяет освободить
  память, выделенную для ненужных переменных;
* Локальная переменная может продолжать существовать даже после возврата значения из охватывающей функции:
  ``` go
  func f() *int {
	  i := 10
	  return &i // возвращаем ссылку на локальную переменную i
  }
  ```
* Компилятор может выбрать, где разместить локальные переменные `(в стеке или куче)`, независимо от того, была ли
  переменная объявлена с помощью `var` или `new`;
* Необходимо учитывать время жизни переменных для написания эффективных программ, избегая утечек памяти и ненужного
  использования ресурсов;
* Сборка мусора облегчает написание корректных программ, но не освобождает от бремени размышлений о памяти и времени
  жизни переменных.

____

## 2.4. Присваивания

* Значение переменной обновляется с помощью оператора присваивания `=`;
* Оператор присваивания может быть использован для именованных переменных, косвенных переменных, полей структур и
  элементов массива, среза или карты;
* Арифметические и побитовые бинарные операторы имеют соответствующие присваивающие операторы, которые позволяют
  упростить запись и избежать повторения выражений;
* Числовые переменные могут быть увеличены или уменьшены с помощью инструкций `++` и `--`, которые представляют собой
  краткую форму операции сложения или вычитания единицы.

____

### 2.4.1 Присваивание кортежу

* Присваивание кортежу - это метод, который позволяет присваивать значения нескольким переменным одновременно, делая код
  более компактным и понятным;
* Все выражения справа вычисляются перед присваиванием значений переменным слева, что позволяет обменивать значения
  переменных, например, вычислять наибольший общий делитель или числа Фибоначчи:
	* ``` go
      func fib(n int) int {
        x, y, := 0, 1
        for i := 0; i < n; i++ {
            x, y = y, x+y
        }
        return x
      }
      ```
* Присваивание кортежу удобно для обмена значений между переменными, такими как `x, y = y, x` или `a[i], a[j] = a[j],
  a[i]`;
* Для функций с несколькими результатами присваивание кортежу используется для того, чтобы присвоить значения каждому из
  результатов, например: `f, err = os.Open("foo.txt")`;
* Дополнительные результаты функций часто используются для указания на ошибки, возвращая значение `error` или булево
  значение `ok`;
* В присваивании кортежу можно использовать пустой идентификатор `_`, чтобы игнорировать ненужные значения,
  например:  `_, err = io.Copy(dst, src)`;
* Присваивание кортежу повышает читаемость и понятность кода, но нужно избегать его использования при наличии сложных
  выражений, так как последовательность отдельных инструкций может быть легче для чтения.

____

### 2.4.2 Присваиваемость

* Присваивание в программировании может быть явным и неявным, но в любом случае значение должно быть присваиваемо типу
  переменной;
* Неявное присваивание происходит, например, при вызове функции, инструкции `return` или литеральных выражениях для
  составных типов;
* Присваивание считается корректным, когда типы переменной и значения точно соответствуют, однако значение `nil` может
  быть присвоено любой переменной интерфейсного или ссылочного типа;
* Правила присваиваемости для констант более гибкие, что позволяет избежать большинства явных преобразований типов;
* Вопрос о возможности сравнения двух значений с помощью операторов `==` и `!=` также связан с присваиваемостью: оба
  операнда должны быть присваиваемы друг другу, то есть иметь одинаковый тип;
* Понимание правил присваиваемости помогает писать корректный код и избегать ошибок, связанных с несоответствием типов.

____

## 2.5. Объявления типов

* Тип переменной или выражения определяет характеристики значений: размер, внутреннее представление, возможные операции
  и связанные методы;
* Разные переменные могут использовать одно и то же внутреннее представление, но быть разными по
  смыслу (`var index, count int`);
* Объявление `type` определяет новый именованный тип с тем же базовым типом, что и существующий, что обеспечивает
  возможность различать и контролировать их использование, избегая ошибок;
* Именованные типы определенные на уровне пакета видны всему пакету и доступны в других пакетах, если экспортируются;
* Несмотря на связь с одним базовым типом, именованные типы считаются разными типами и для их использования вместе
  требуется явное преобразование типа (`Celsius(f)`);
* Преобразование типа не изменяет значение и его представление, но меняет его смысл (тип);
* Преобразование значений разрешено, если они имеют один и тот же базовый тип или являются неименованными указателями на
  переменные с одним базовым типом;
* Именованный тип позволяет определить новое поведение значений этого типа через методы типа, такие как
  метод `String()`, который управляет видом значений данного типа при выводе строк.

____

## 2.6. Пакеты и файлы

* Пакеты в Go поддерживают модульность, инкапсуляцию, раздельную компиляцию и повторное использование;
	* `Модульность` - это подход к созданию программных систем, в котором каждая функциональность реализуется в
	  отдельных модулях, связанных между собой через определенные интерфейсы;
	* `Инкапсуляция` - это механизм, который позволяет скрыть детали реализации модуля от других компонентов системы,
	  обеспечивая доступ только к определенным элементам модуля;
	* `Раздельная компиляция` - это процесс, при котором каждый модуль может редактироваться и компилироваться отдельно,
	  минимизируя время компиляции и облегчая обновление системы;
	* `Повторное использование` - это возможность использовать уже написанные и отлаженные модули в новых приложениях,
	  что ускоряет их разработку и повышает надежность.
* Исходный текст пакета располагается в одном или нескольких файлах `.go`, обычно в каталоге с соответствующим именем;
* Каждый пакет служит в качестве отдельного пространства имен для своих объявлений;
* Чтобы обратиться к функции за пределами ее пакета, следует квалифицировать идентификатор, например `image.Decode()`
  или `utf16.Decode()`;
* В Go экспортируются идентификаторы, которые начинаются с прописной буквы;
* Каждый файл пакета начинается с объявления `package`, которое определяет имя пакета;
* Имена уровня пакета, объявленные в одном файле пакета, являются видимыми для всех других файлов пакета;
* Пакеты могут иметь документирующий комментарий, который предшествует объявлению `package` и начинается с резюмирующего
  предложения. Обычно только один файл пакета имеет такой комментарий, иногда помещают его в отдельный файл `doc.go`.

____

### 2.6.1 Импорт

* Импорт пакетов в Go происходит с помощью уникального пути импорта, который идентифицирует пакет, и объявления импорта;
* Путь импорта обозначает каталог, содержащий исходные файлы `.go`, которые совместно образуют пакет;
* Имя пакета - это краткое (необязательно уникальное) имя, которое соответствует последней части пути импорта;
* Объявление импорта связывает краткое имя импортируемого пакета, которое может использоваться для обращения к его
  содержимому в данном файле (`import m "math"`);
* Импорт пакета без последующего использования является ошибкой, что позволяет избежать ненужных зависимостей;
* Чтобы автоматически добавлять или удалять пакеты из объявлений импорта, рекомендуется использовать инструмент
  `golang.org/x/tools/cmd/goimports`;
* Использование инструмента `goimports` и `gofmt` позволяет приводить исходный код Go к каноническому формату.

____

### 2.6.2 Инициализация пакетов

* Инициализация пакета начинается с инициализации переменных уровня пакета в порядке их объявления, при этом сначала
  разрешаются зависимости;
* Если пакет состоит из нескольких `.go` файлов, их инициализация идет в порядке передачи файлов компилятору, инструмент
  `go` сортирует `.go` файлы по имени перед вызовом компилятора;
* Для инициализации некоторых переменных, таких как таблицы данных, можно использовать функцию `init`, которая
  выполняется автоматически при запуске программы;
* Функции `init` нельзя вызывать или обратиться к ним, они имеют вид: `func init() { /*...*/ }`;
* Инициализация пакетов выполняется по одному пакету за раз в порядке объявления пакета в программе, сначала
  инициализируются зависимости, а затем следующий пакет;
* Последним инициализируется пакет `main`, таким образом, все пакеты оказываются полностью инициализированными до начала
  выполнения функции `main` приложения.

____

## 2.7. Область видимости

* Область видимости - часть исходного кода, где объявленное имя ссылается на сущность из этого объявления. Является
  свойством времени компиляции;
* Время жизни переменной - диапазон времени выполнения, когда к переменной можно обращаться из других частей программы.
  Является свойством времени **_выполнения_**;
* Синтаксический блок - последовательность инструкций, заключенных в фигурные скобки (тело функции, цикла и т.д.);
* Лексические блоки - группы объявлений, определяющие область видимости имени (всеобщий блок, уровень пакета, уровень
  файла, блоки конструкций `for`, `if` и `switch`, `case` в `switch` или `select`, явные синтаксические блоки);
* `Всеобщий блок` - область видимости встроенных типов, функций и констант (`int`, `len`, `true` и т.д.), доступны на
  протяжении всей работы программы;
* `Уровень пакета` - область видимости объявлений вне любой функции, доступны из любого файла в том же пакете;
* `Уровень файла` - область видимости импортированных пакетов, доступны только в том же файле;
* `Локальные объявления` - область видимости ограничена пределами функции или ее части;
* Область видимости `метки` управления потоком - вся охватывающая функция;
* Внутреннее объявление затеняет или `скрывает` внешнее, если имя объявлено и во внутреннем, и во внешнем блоках;
* Внутри функции лексические блоки могут быть вложенными с произвольной глубиной вложения, одно локальное объявление
  может затенять другое;
* Цикл `for` создает два лексических блока: `явный блок для тела цикла` и `неявный блок, охватывающий переменные,
  объявленные в инициализации цикла`;
* В Go порядок объявления переменных не влияет на их область видимости на уровне пакета, что позволяет создавать
  рекурсивные и взаимно рекурсивные типы и функции;
* Область видимости переменных, объявленных в циклах `for`, инструкциях `if` и `switch`, ограничивается только их
  блоками, что может привести к ошибкам компиляции при обращении к ним вне этих блоков;
* Часто требуется объявлять переменные до условия, чтобы они были доступны после него, что предотвращает ошибки
  компиляции из-за использования неправильной области видимости;
* Чтобы избежать ошибок из-за использования краткого объявления переменных, можно объявлять переменные в отдельном блоке
  `var`, что позволяет правильно настроить их область видимости;
* Понимание области видимости переменных в Go позволяет избегать ошибок и создавать корректно работающие программы.

____










