# 2.5 Объявления типов

Тип переменной или выражения определяет характеристики значений, которые он может принимать:

* их размер (количество битов или, возможно, количество элементов);
* как они представлены внутренне;
* операции, которые могут быть над ними выполнены;
* связанные с ним методы.

В любой программе есть переменные, которые используют одинаковое внутреннее представление, но значительно различаются в
смысле представляемой ими концепции. Например:

* `int` может использоваться для представления индекса цикла, временной метки, дескриптора файла или месяца;
* `float64` - может представлять скорость в метрах в секунду или температуру в одной из нескольких шкал;
* `string` - может быть паролем или названием цвета.

Объявление `type` определяет новый `именованный тип`, который имеет тот же `базовый тип`, что и существующий.
Именованный тип обеспечивает возможность отличать различные и, возможно, несовместимые использования базового типа с
тем, чтобы они не могли оказаться непреднамеренно смешанными.

```
type имя базовый_тип
```

Объявления типов наиболее часто появляются на уровне пакета, где именованный тип виден всему пакету, и, если это **_имя
экспортируется (начинается с прописной буквы)_**, то оно доступно и в других пакетах.

Этот пакет (см. tempconv0.go) определяет 2 типа, `Celsius` и `Fahrenheit`, для двух шкал температуры. Несмотря на то,
что они оба имеют один и тот же `базовый тип` - `float64`, сами они являются _разными типами_, а потому не могут
сравниваться или объединятся в арифметических выражениях.

Такое различие типов позволяет избежать ошибок непреднамеренного сочетания температур в двух различных масштабах.
Требуется явное преобразование типа для значения `float64`, такое как `Celsius(t)` или `Fahrenheit(t)`. Это именно
преобразование типа, а не вызовы функций `Celsius(t)` и `Fahrenhiet(t)`. Они никоим образом не изменяют значение или его
представление, но явно изменяют его смысл.

С другой стороны, функции `CToF` и `FToC` выполняют преобразование температур между двумя различными шкалами, они
возвращают **_отличающиеся от исходных значения_**.

Для каждого типа `T` имеется соответствующая операция преобразования `T(x)`, которая приводит значение `x` к типу `T`.
Преобразование одного типа к другому разрешено, если оба имеют **_один и тот же базовый тип_** или если
оба являются неименованными указателями на переменные **_одного и того же базового типа_**. Такие преобразования
изменяют, но не представление значения. Если `x` присваиваемо типу `T`, то преобразование разрешено, но обычно является
излишним.

Разрешены также преобразования между числовыми типами и между строками и некоторыми типами срезов. Эти преобразования
могут изменить представление значения. Например, преобразование числа с плавающей запятой в целое - отбрасывает дробную
часть, а преобразование строки в срез []byte - выделяет память для копии данных строки. **_Преобразование никогда не
приводит к сбою времени выполнения программы_**.

Базовый тип для именованного определяет его структуру и представление, а также набор поддерживаемых внутренних
операций, которые являются такими же, как и при использовании базового типа. Это значит, что арифметические операторы
одинаково работают для `Celsius` и `Fahrenheit` как для `float64`.

``` go
fmt.Printf("%g\n", BoilingC-FreezingC) // "100" °C
boilingF := CToF(BoilingC)
fmt.Printf("%g\n", boilingF-CToF(FreezingC)) // "180" °F
fmt.Printf("%g\n", boilingF-FreezingC) // Ошибка компиляции: несоответствие типов
```

Операторы сравнения `==` и `!=` могут использоваться для сравнения значения именованного типа с другим значением того же
типа или со значением неименованного типа с тем же базовым типом. Но два значения различных именованных типов сравнивать
нельзя:

``` go
var c Celsius
var f Fahrenheit
fmt.Println(c == 0) // "true"
fmt.Println(f >= 0) // "true"
fmt.Println(c == f) // Ошибка компиляции: несоответсвие типов
fmt.Println(c == Celsius(f)) // "true"
```

В последнем случае - несмотря на свое название, преобразование типа `Celsius(f)` не изменяет значение своего аргумента,
а изменяет только его тип.
Проверка дает значение `true`, потому что и `c` и `f` равны `0`.

Именованный тип позволяет избежать написания сложных типов снова и снова. Это преимущество не проявляется при
использовании базовых типов, но оказывается существенным для сложных типов - структур.

Именованные типы позволяют также определить новое поведение значений этого типа. Такое поведение выражается в виде
набора функций, связанных с данным типом и именуемых **_методами типа_**.

Код ниже - параметр `c` типа `Celsius` находится
перед именем функции, ассоциирует `c` типом `Celsius` с методом с именем `String`, который возвращает числовое
значение `c`, за которым следуют символы `°C`

``` go
func (c Celsius) String() string { return fmt.Sprintf("%g°C", c) }
```

Многие типы объявляют метод `String` такого вида, т.к. он управляет видом значений данного типа при выводе строк
пакетом `fmt`.

``` go
c :=  FToC(212.0)
fmt.Println(c.String()) // "100°C"
fmt.Printf("%v\n", c) // "100°C"; явный вызов String() не нужен
fmt.Printf("%s\n", c) // "100°C"
fmt.Println(c) // "100°C"
fmt.Printf("%g\n", c) // "100°C"; не вызывает String()
fmt.Println(float64(c)) // "100°C"; не вызывает String()
```